<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RiffHound Chord Machine v0.4</title>
<style>
  /* Minimal, readable, big-click targets */
  body { font-family: sans-serif; background: #fff; color: #000; margin: 0; }
  #top { display: flex; flex-wrap: nowrap; gap: 1vh; padding: 1vh; background: #eee; align-items: stretch; }
  #top button { flex: 1 1 0; font-size: 4vh; padding: 2vh 1vw; }
  button { cursor: pointer; border: 1px solid #bbb; }
  button.primary { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  button.primary.playing { background: #007700; color: #fff; border: 1px solid #007700; }
  button.danger { background: #f4f4f4; color: #000; border: 1px solid #999; }
  button.danger.stopped { background: #770000; color: #fff; border: 1px solid #770000; }
  button.toggle { background: #f4f4f4; border: 1px solid #bbb; }
  button.toggle.on { background: #007700; color: #fff; border: 1px solid #007700; }
  button.mute { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  button.flash { background: #4CAF50; color: #fff; }

  #strip { position: relative; display: flex; gap: 0; height: 30vh; border-top: 1px solid #ccc; border-bottom: 1px solid #ccc; }
  .chord { flex: 1 1 0; min-width: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; border-right: 1px solid #ddd; text-align: center; }
  .chord:last-child { border-right: none; }
  .chord .literal { font-family: monospace; font-size: 8vw; font-weight: bold; line-height: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .chord .roman { font-size: 3.5vw; color: #333; line-height: 1.2; }
  .chord.active { background: #8389ff; }
  .beatProg { position: absolute; left: 0; top: 0; bottom: 0; width: 0%; background: rgba(0,0,0,0.07); pointer-events: none; }
  #loopMarker { width: 3vw; min-width: 20px; background: repeating-linear-gradient(90deg,#000 0,#000 2px,transparent 2px,transparent 6px); display: flex; align-items: center; justify-content: center; font-size: 2vw; }
  .loopFlash { animation: flash 0.35s ease-in-out 1; }
  @keyframes flash { 0%{box-shadow: inset 0 0 0 6px #ff0;} 100%{box-shadow: inset 0 0 0 0px #ff0;} }

  /* Strum pattern display */
  #strumSection { background: #f8f8f8; border-top: 1px solid #ccc; padding: 1vh; }
  #strumHeader { display: flex; align-items: center; gap: 1em; margin-bottom: 0.5vh; }
  #strumHeader label { font-weight: bold; font-size: 2.2vh; }
  #strumContainer { position: relative; display: flex; gap: 0; height: 29vh; background: #fff; border: 2px solid #999; border-bottom: none; border-radius: 4px 4px 0 0; overflow: hidden; }

  /* Motion overlay SVG */
  #motionOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }
  .motionPath {
    fill: none;
    stroke: #bbb;
    stroke-width: 3;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .stringLine {
    stroke: #ddd;
    stroke-width: 2;
  }
  .beatLine {
    stroke: #e8e8e8;
    stroke-width: 1;
    stroke-dasharray: 4 4;
  }
  .stringMarker {
    cursor: pointer;
    pointer-events: all;
  }
  .stringArrow {
    fill: #333;
  }
  .stringArrow.inactive {
    fill: #ddd;
    stroke: #bbb;
    stroke-width: 1;
  }
  .stringX line {
    stroke: #666;
    stroke-width: 3;
    stroke-linecap: round;
  }
  .stringX.inactive line {
    stroke: #ccc;
    stroke-width: 2;
  }
  .activeMarker .stringArrow {
    fill: #4CAF50;
  }
  .activeMarker .stringX line {
    stroke: #4CAF50;
  }
  .strumBeat { flex: 1 1 0; display: flex; flex-direction: column; align-items: center; justify-content: center; border-right: 2px solid #ccc; position: relative; cursor: pointer; transition: background 0.1s; }
  .strumBeat:last-child { border-right: none; }
  .strumBeat:hover { background: #f0f0ff; }
  .strumBeat.active { background: #a0a8ff; }
  .strumBeat .strumIcon { display: none; }
  .strumBeat .strumLabel { display: none; }

  /* Direction toggle at top of beat */
  .strumDirection {
    position: absolute;
    top: 4px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 3.5vh;
    font-weight: bold;
    cursor: pointer;
    padding: 0.1em 0.3em;
    border-radius: 4px;
    z-index: 20;
    user-select: none;
  }
  .strumDirection:hover { background: rgba(0,0,0,0.1); }
  .strumDirection[data-dir="down"] { color: #0044aa; }
  .strumDirection[data-dir="up"] { color: #cc5500; }
  .strumDirection[data-dir="none"] { color: #bbb; }

  /* Mute toggle */
  .strumMute {
    position: absolute;
    top: 4px;
    right: 4px;
    font-size: 2vh;
    cursor: pointer;
    padding: 0.1em 0.2em;
    border-radius: 3px;
    color: #999;
    z-index: 20;
    user-select: none;
  }
  .strumMute:hover { background: rgba(0,0,0,0.1); }
  .strumMute.active { color: #c00; background: rgba(255,0,0,0.1); }
  .strumBeat .beatNum { font-size: 2vh; font-weight: bold; color: #666; position: absolute; top: 4px; left: 50%; transform: translateX(-50%); }

  /* Beat background - subtle based on having active strings */
  .strumBeat { background: #fafafa; }
  .strumBeat.active { background: #d0d8ff; }

  /* Dynamics bar container */
  #dynamicsContainer {
    display: flex;
    gap: 0;
    height: 3vh;
    background: #e8e8e8;
    border: 2px solid #999;
    border-top: none;
    border-radius: 0 0 4px 4px;
    overflow: hidden;
  }
  .dynamicsCell {
    flex: 1 1 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border-right: 2px solid #ccc;
    cursor: pointer;
    padding: 2px;
  }
  .dynamicsCell:last-child { border-right: none; }
  .dynamicsCell:hover { background: #ddd; }
  .dynamicsBar {
    height: 60%;
    background: #666;
    border-radius: 2px;
    transition: width 0.1s;
  }
  .dynamicsCell[data-dynamics="soft"] .dynamicsBar { width: 30%; background: #999; }
  .dynamicsCell[data-dynamics="medium"] .dynamicsBar { width: 60%; background: #666; }
  .dynamicsCell[data-dynamics="loud"] .dynamicsBar { width: 100%; background: #c00; }
  .dynamicsCell[data-type="rest"] .dynamicsBar { width: 0%; }

  /* Icon opacity based on dynamics */
  .strumBeat[data-dynamics="soft"] .strumIcon { opacity: 0.5; }
  .strumBeat[data-dynamics="medium"] .strumIcon { opacity: 0.75; }
  .strumBeat[data-dynamics="loud"] .strumIcon { opacity: 1; }

  /* Animated strum indicator */
  .strumIndicator { position: absolute; bottom: 0; left: 0; right: 0; height: 6px; background: #4CAF50; transform: scaleX(0); transform-origin: left; }
  .strumBeat.active .strumIndicator { animation: strumPulse 0.15s ease-out; }
  @keyframes strumPulse {
    0% { transform: scaleX(0); background: #4CAF50; }
    50% { transform: scaleX(1); background: #8BC34A; }
    100% { transform: scaleX(1); background: #4CAF50; }
  }

  #bottom { padding: 1vh; font-size: 2.2vh; display: flex; flex-wrap: wrap; gap: .6em; align-items: center; }
  input, select { font-size: 2.2vh; }
  #literalInput.editing { outline: 3px solid #66f; background: #eef; }
  #literalInput.invalid { outline: 3px solid #f00; background: #fee; }

  /* Pattern selector */
  #patternSelect { font-size: 2vh; padding: 0.3em; }
</style>
</head>
<body>
  <div id="top">
    <button id="btnPlay"   class="primary">‚ñ∂ Play</button>
    <button id="btnStop"   class="danger stopped">‚èπ Stop</button>
    <button id="btnMute"   class="mute">üîä Sound</button>
    <button id="btnTap">üïí Tap Tempo</button>
    <button id="btnDrums"  class="toggle">ü•Å Drums</button>
    <button id="btnChords" class="toggle on">üéπ Chords</button>
    <button id="btnRandom" class="toggle">üé≤ Random</button>
  </div>

  <div id="strip"></div>

  <div id="strumSection">
    <div id="strumHeader">
      <label>Strum Pattern:</label>
      <select id="patternSelect">
        <option value="basic">Basic (D D D D)</option>
        <option value="folk" selected>Folk (D DU UD U)</option>
        <option value="reggae">Reggae (r Mu r Mu)</option>
        <option value="arpeggio">Arpeggio (B U U U)</option>
        <option value="boom-chick">Boom-Chick (B U D U)</option>
        <option value="custom">Custom</option>
      </select>
    </div>
    <div id="strumContainer"></div>
    <div id="dynamicsContainer"></div>
  </div>

  <div id="bottom">
    Key: <select id="keySelect"></select>
    Progression: <input id="literalInput" size="50" value="C | F | G | C">
    BPM: <input id="bpm" type="range" min="30" max="300" value="110"> <input id="bpmVal" type="number" min="30" max="300" value="110" style="width: 4em;">
  </div>

<script>
// =========================
// v0.4 ‚Äî strumming patterns
// =========================

// --- Strum beat structure ---
// Each beat has: direction ('down'|'up'|'none'), strings {bass, mid, upper}, muted, dynamics

const DIRECTIONS = ['down', 'up'];
const DIRECTION_ICONS = { down: '‚Üì', up: '‚Üë', none: '¬∑' };

// Dynamics levels
const DYNAMICS = {
  soft:   { label: 'S', gain: 0.35 },
  medium: { label: 'M', gain: 0.65 },
  loud:   { label: 'L', gain: 1.0 }
};
const DYNAMICS_ORDER = ['soft', 'medium', 'loud'];

// Helper to create a strum beat
function strum(direction, strings = {bass: true, mid: true, upper: true}, muted = false, dynamics = 'medium') {
  return { direction, strings: {...strings}, muted, dynamics };
}

// Shorthand helpers for presets
const D = (dyn = 'medium') => strum('down', {bass:true, mid:true, upper:true}, false, dyn);
const U = (dyn = 'medium') => strum('up', {bass:true, mid:true, upper:true}, false, dyn);
const R = () => strum('none', {bass:false, mid:false, upper:false}, false, 'medium');
const M = (dyn = 'medium') => strum('down', {bass:true, mid:true, upper:true}, true, dyn);
const B = (dyn = 'medium') => strum('down', {bass:true, mid:false, upper:false}, false, dyn);
const MD = (dyn = 'medium') => strum('down', {bass:false, mid:true, upper:false}, false, dyn);
const UP = (dyn = 'medium') => strum('up', {bass:false, mid:true, upper:true}, false, dyn);

// Preset patterns (8 eighth notes per bar)
const PATTERNS = {
  basic:       [D('loud'), R(), D('medium'), R(), D('loud'), R(), D('medium'), R()],
  folk:        [D('loud'), R(), D('medium'), U('soft'), R(), U('soft'), D('medium'), U('soft')],
  reggae:      [R(), M('medium'), U('soft'), R(), R(), M('medium'), U('soft'), R()],
  arpeggio:    [B('loud'), R(), UP('soft'), R(), UP('soft'), R(), UP('soft'), R()],
  'boom-chick': [B('loud'), R(), UP('medium'), R(), D('loud'), R(), UP('medium'), R()],
  custom:      [D('loud'), R(), D('medium'), U('soft'), R(), U('soft'), D('medium'), U('soft')]
};

// --- Global state ---
let bpm = 92;
let playing = false;
let muted = false;
let editMode = false;
let drumsOn = false;
let chordsOn = true;
let chords = [];
let chordIdx = 0;
let barStart = 0; // audio time of current bar start
let strumPattern = PATTERNS.folk.map(s => ({...s, strings: {...s.strings}}));
let currentStrumIdx = -1;
const taps = [];

// --- DOM refs ---
const el = {};

// --- Audio setup ---
const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const KEYS = ['C','Db','D','Eb','E','F','F#','G','Ab','A','Bb','B'];

const ctx = new (window.AudioContext || window.webkitAudioContext)();
const master = ctx.createGain(); master.connect(ctx.destination);
let chordsGain = ctx.createGain(); chordsGain.connect(master);
let drumsGain  = ctx.createGain(); drumsGain.connect(master);
let metroGain  = ctx.createGain(); metroGain.connect(master);

// --- One-off buffers ---
const noiseBuf = (() => {
  const b = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
  const d = b.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  return b;
})();

// =========================
// Helpers (theory / parsing)
// =========================
function keyToSemi(k) {
  const m = { Db:1, Eb:3, F:5, Gb:6, Ab:8, Bb:10 };
  return (m[k] != null) ? m[k] : (NOTE_NAMES.indexOf(k) >= 0 ? NOTE_NAMES.indexOf(k) : 0);
}

function nameForSemi(s) {
  return NOTE_NAMES[(s + 12) % 12];
}

function parseLiteralToken(tok) {
  tok = tok.trim();
  if (!tok) return null;
  const m = tok.match(/^([A-Ga-g])(b|#)?(m)?/);
  if (!m) return null;
  const letter = m[1].toUpperCase();
  const acc = m[2] || '';
  const minor = !!m[3];
  const enh = { Db:'C#', Eb:'D#', Gb:'F#', Ab:'G#', Bb:'A#' };
  const sharp = enh[letter + acc] || (letter + acc);
  const idx = NOTE_NAMES.indexOf(sharp);
  if (idx < 0) return null;
  return { root: idx, quality: minor ? 'm' : 'M' };
}

function romanFor(rootSemi, quality) {
  try {
    const key = keyToSemi(el.keySelect.value);
    const deg = (rootSemi - key + 12) % 12;
    const map = { 0:'I', 2:'ii', 4:'iii', 5:'IV', 7:'V', 9:'vi', 11:'vii¬∞' };
    let r = map[deg];
    if (!r) return '?';
    if (quality === 'm') r = r.toLowerCase();
    return r;
  } catch {
    return '?';
  }
}

function buildTriad(rootMidi, quality) {
  const third = (quality === 'm') ? 3 : 4;
  return [rootMidi, rootMidi + third, rootMidi + 7];
}

// =========================
// Audio voice utilities
// =========================

// Strum delay for realistic guitar sound (in seconds)
const STRUM_DELAY = 0.035; // 35ms between each string - noticeable stagger

// notes = [bass, mid, upper] sorted low to high
function voiceStrumBeat(notes, t, dur, beat) {
  // Check if any strings are active
  const hasActiveStrings = beat.strings.bass || beat.strings.mid || beat.strings.upper;
  if (beat.direction === 'none' || !hasActiveStrings) return; // Silent (rest)

  const grp = ctx.createGain();
  grp.gain.value = 0;
  grp.connect(chordsGain);

  // Apply dynamics multiplier
  const dynGain = DYNAMICS[beat.dynamics]?.gain || 0.65;

  // Build list of notes to play based on active strings
  // notes array is [bass, mid, upper] (low to high)
  let notesToPlay = [];
  if (beat.strings.bass) notesToPlay.push({ note: notes[0], string: 'bass' });
  if (beat.strings.mid) notesToPlay.push({ note: notes[1], string: 'mid' });
  if (beat.strings.upper) notesToPlay.push({ note: notes[2], string: 'upper' });

  // Sort by strum direction
  if (beat.direction === 'down') {
    // High to low pitch means upper string first (which is highest pitch)
    notesToPlay.sort((a, b) => b.note - a.note);
  } else {
    // Up stroke: low to high pitch means bass string first
    notesToPlay.sort((a, b) => a.note - b.note);
  }

  let delays = notesToPlay.map((_, i) => i * STRUM_DELAY);
  let peak = 0.55 * dynGain;
  let filterFreq = 20000;
  let filterQ = 1;
  let useNoise = false;

  if (beat.muted) {
    delays = notesToPlay.map(() => 0);
    filterFreq = 400;
    filterQ = 4;
    peak = 0.5 * dynGain;
    dur = Math.min(dur, 0.06);
    useNoise = true;
  }

  // Create filter for muted sound
  let filterNode = null;
  if (filterFreq < 20000) {
    filterNode = ctx.createBiquadFilter();
    filterNode.type = 'lowpass';
    filterNode.frequency.value = filterFreq;
    filterNode.Q.value = filterQ;
    filterNode.connect(grp);
  }

  const targetNode = filterNode || grp;

  notesToPlay.forEach((item, i) => {
    const noteStart = t + delays[i];
    const o = ctx.createOscillator();
    o.type = 'triangle';
    o.frequency.value = 440 * Math.pow(2, (item.note - 69) / 12);
    const g = ctx.createGain();
    g.gain.value = 0.6;
    o.connect(g).connect(targetNode);
    o.start(noteStart);
    o.stop(noteStart + dur);
  });

  // Add percussive noise for muted strums
  if (useNoise) {
    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuf;
    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 600;
    noiseFilter.Q.value = 2;
    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.4, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    noise.connect(noiseFilter).connect(noiseGain).connect(grp);
    noise.start(t);
    noise.stop(t + 0.1);
  }

  // Envelope
  const maxDelay = Math.max(...delays);
  const a = 0.02, d = 0.1, s = 0.7, r = 0.06;

  if (beat.muted) {
    // Quick percussive envelope for muted
    grp.gain.setValueAtTime(0, t);
    grp.gain.linearRampToValueAtTime(peak, t + 0.005);
    grp.gain.exponentialRampToValueAtTime(0.001, t + dur);
  } else {
    grp.gain.setValueAtTime(0, t);
    grp.gain.linearRampToValueAtTime(peak, t + maxDelay + a);
    grp.gain.linearRampToValueAtTime(peak * s, t + maxDelay + a + d);
    grp.gain.setValueAtTime(peak * s, t + dur - r);
    grp.gain.linearRampToValueAtTime(0.0001, t + dur);
  }
}

function voiceKick(t) {
  const o = ctx.createOscillator(); o.type = 'sine';
  const g = ctx.createGain();
  o.frequency.setValueAtTime(110, t);
  o.frequency.exponentialRampToValueAtTime(50, t + 0.08);
  g.gain.setValueAtTime(0.9, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  o.connect(g).connect(drumsGain);
  o.start(t); o.stop(t + 0.12);
}

function voiceSnare(t) {
  const s = ctx.createBufferSource(); s.buffer = noiseBuf;
  const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 1800;
  const g = ctx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  s.connect(bp).connect(g).connect(drumsGain);
  s.start(t); s.stop(t + 0.1);
}

function voiceHat(t) {
  const s = ctx.createBufferSource(); s.buffer = noiseBuf;
  const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 6000;
  const g = ctx.createGain(); g.gain.setValueAtTime(0.18, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
  s.connect(hp).connect(g).connect(drumsGain);
  s.start(t); s.stop(t + 0.05);
}

function voiceMetro(t, accent = false) {
  const o = ctx.createOscillator(); o.type = 'square';
  const g = ctx.createGain(); g.gain.value = accent ? 0.25 : 0.12;
  o.frequency.setValueAtTime(accent ? 2000 : 1200, t);
  o.connect(g).connect(metroGain);
  o.start(t); o.stop(t + 0.03);
}

// =========================
// Rendering
// =========================
function renderStrip() {
  el.strip.innerHTML = '';
  if (!chords || chords.length === 0) return;
  chords.forEach((ch, i) => {
    const cell = document.createElement('div');
    cell.className = 'chord';
    cell.dataset.idx = i;
    const lit = nameForSemi(ch.root) + (ch.quality === 'm' ? 'm' : '');
    const rn  = romanFor(ch.root, ch.quality);
    cell.innerHTML = `
      <div class="beatProg"></div>
      <div class="literal">${lit}</div>
      <div class="roman">${rn}</div>
    `;
    el.strip.appendChild(cell);
  });
  const loop = document.createElement('div');
  loop.id = 'loopMarker';
  loop.title = 'Loop start';
  loop.textContent = '‚Ü©';
  el.strip.appendChild(loop);
}

function renderStrumPattern() {
  el.strumContainer.innerHTML = '';
  el.dynamicsContainer.innerHTML = '';

  strumPattern.forEach((beat, i) => {
    // Strum beat cell
    const beatEl = document.createElement('div');
    beatEl.className = 'strumBeat';
    beatEl.dataset.idx = i;
    beatEl.dataset.dynamics = beat.dynamics;

    // Check if any strings are active
    const hasActiveStrings = beat.strings.bass || beat.strings.mid || beat.strings.upper;
    const isRest = beat.direction === 'none' || !hasActiveStrings;

    beatEl.innerHTML = `
      <div class="beatNum">${Math.floor(i/2) + 1}${i % 2 === 0 ? '' : '&'}</div>
      <div class="strumDirection" data-dir="${beat.direction}">${DIRECTION_ICONS[beat.direction]}</div>
      <div class="strumMute ${beat.muted ? 'active' : ''}" title="Mute">M</div>
      <div class="strumIndicator"></div>
    `;

    // Direction toggle at top
    const dirEl = beatEl.querySelector('.strumDirection');
    dirEl.addEventListener('click', (e) => {
      e.stopPropagation();
      const currentIdx = DIRECTIONS.indexOf(beat.direction);
      const nextIdx = (currentIdx + 1) % DIRECTIONS.length;
      strumPattern[i].direction = DIRECTIONS[nextIdx];
      el.patternSelect.value = 'custom';
      renderStrumPattern();
    });

    // Mute toggle
    const muteEl = beatEl.querySelector('.strumMute');
    muteEl.addEventListener('click', (e) => {
      e.stopPropagation();
      strumPattern[i].muted = !strumPattern[i].muted;
      el.patternSelect.value = 'custom';
      renderStrumPattern();
    });

    el.strumContainer.appendChild(beatEl);

    // Dynamics cell
    const dynCell = document.createElement('div');
    dynCell.className = 'dynamicsCell';
    dynCell.dataset.idx = i;
    dynCell.dataset.dynamics = beat.dynamics;
    // Show empty bar for rest
    if (isRest) {
      dynCell.dataset.type = 'rest';
    }
    dynCell.innerHTML = '<div class="dynamicsBar"></div>';

    dynCell.addEventListener('click', () => {
      const currentIdx = DYNAMICS_ORDER.indexOf(beat.dynamics);
      const nextIdx = (currentIdx + 1) % DYNAMICS_ORDER.length;
      strumPattern[i].dynamics = DYNAMICS_ORDER[nextIdx];
      el.patternSelect.value = 'custom';
      renderStrumPattern();
    });

    el.dynamicsContainer.appendChild(dynCell);
  });

  renderMotionOverlay();
}

// Render the motion path SVG overlay
function renderMotionOverlay() {
  // Remove existing overlay
  const existing = document.getElementById('motionOverlay');
  if (existing) existing.remove();

  const container = el.strumContainer;
  const width = container.offsetWidth;
  const height = container.offsetHeight;
  if (width === 0 || height === 0) return;

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.id = 'motionOverlay';
  svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
  svg.setAttribute('preserveAspectRatio', 'none');

  const numBeats = strumPattern.length;
  const beatWidth = width / numBeats;

  // Strings are clustered in the middle, with more room above/below for hand motion
  const stringClusterHeight = height * 0.25; // 25% smaller cluster for strings
  const stringAreaTop = (height - stringClusterHeight) / 2;
  const stringAreaBottom = stringAreaTop + stringClusterHeight;
  const stringSpacing = stringClusterHeight / 2;

  // String Y positions (upper at top, bass at bottom)
  const stringY = {
    upper: stringAreaTop,
    mid: stringAreaTop + stringSpacing,
    bass: stringAreaBottom
  };

  // Overshoot positions for natural hand motion (well past the strings)
  const overshootAmount = height * 0.28;
  const aboveStrings = stringY.upper - overshootAmount;
  const belowStrings = stringY.bass + overshootAmount;

  // Draw string lines
  Object.values(stringY).forEach(y => {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', 0);
    line.setAttribute('y1', y);
    line.setAttribute('x2', width);
    line.setAttribute('y2', y);
    line.setAttribute('class', 'stringLine');
    svg.appendChild(line);
  });

  // Draw vertical beat lines
  for (let i = 0; i <= numBeats; i++) {
    const x = beatWidth * i;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x);
    line.setAttribute('y1', 0);
    line.setAttribute('x2', x);
    line.setAttribute('y2', height);
    line.setAttribute('class', 'beatLine');
    svg.appendChild(line);
  }

  // Motion path: hand makes continuous sinusoidal motion across ALL beats
  // Every beat has a direction for motion purposes (even rests)
  // Rests use natural alternation; only explicit same-direction consecutives need quick return
  const arrowSize = Math.min(beatWidth * 0.12, 12);
  const xSize = arrowSize * 0.6;

  // Get explicit direction ('down', 'up') or null for rest/undefined
  const getExplicitDir = (beat) => {
    const dir = beat.direction;
    if (dir === 'down' || dir === 'up') return dir;
    return null;
  };

  // Build effective direction for each beat:
  // - If beat has explicit direction, use it
  // - If rest, use natural alternation based on neighboring explicit strokes
  const effectiveDirs = [];

  // First pass: copy explicit directions
  for (let i = 0; i < numBeats; i++) {
    effectiveDirs[i] = getExplicitDir(strumPattern[i]);
  }

  // Second pass: fill in rests with natural alternation
  // Find first explicit direction to establish phase
  let firstExplicitIdx = -1;
  let firstExplicitDir = null;
  for (let i = 0; i < numBeats; i++) {
    if (effectiveDirs[i]) {
      firstExplicitIdx = i;
      firstExplicitDir = effectiveDirs[i];
      break;
    }
  }

  // If no explicit strokes, default to alternating starting with down
  if (firstExplicitIdx < 0) {
    firstExplicitIdx = 0;
    firstExplicitDir = 'down';
  }

  // Fill in all beats based on alternation from first explicit
  for (let i = 0; i < numBeats; i++) {
    if (!effectiveDirs[i]) {
      const offset = i - firstExplicitIdx;
      if (firstExplicitDir === 'down') {
        effectiveDirs[i] = (offset % 2 === 0) ? 'down' : 'up';
      } else {
        effectiveDirs[i] = (offset % 2 === 0) ? 'up' : 'down';
      }
    }
  }

  // Build path as a smooth wave that wraps around
  // Each beat has one key point at peak (above) or trough (below)
  // Quick returns add an extra point to reverse direction
  const pathPoints = [];

  for (let i = 0; i < numBeats; i++) {
    const dir = effectiveDirs[i];
    const prevDir = i > 0 ? effectiveDirs[i - 1] : null;
    const beatCenterX = beatWidth * (i + 0.5); // Center of beat

    const needsQuickReturn = prevDir && (dir === prevDir);

    if (needsQuickReturn) {
      // Add quick return point at beat boundary
      const returnX = beatWidth * i;
      const returnY = (dir === 'down') ? aboveStrings : belowStrings;
      pathPoints.push({ x: returnX, y: returnY, type: 'return' });
    }

    // Single point per beat at the peak/trough of the wave
    const y = (dir === 'down') ? belowStrings : aboveStrings;
    pathPoints.push({ x: beatCenterX, y: y, type: 'peak', dir: dir });
  }

  // Wrap around: check if we need quick return to first beat
  const lastDir = effectiveDirs[numBeats - 1];
  const firstDir = effectiveDirs[0];
  const needsWrapReturn = (lastDir === firstDir);

  if (needsWrapReturn) {
    // Quick return at end to get back to start position
    const returnY = (firstDir === 'down') ? aboveStrings : belowStrings;
    pathPoints.push({ x: width - beatWidth * 0.2, y: returnY, type: 'return' });
  }

  // End point wraps to match start position
  const startY = (firstDir === 'down') ? aboveStrings : belowStrings;
  pathPoints.push({ x: width, y: startY, type: 'final' });

  // Build smooth SVG path using cubic beziers
  if (pathPoints.length > 1) {
    let pathD = `M 0 ${startY}`;

    for (let i = 0; i < pathPoints.length; i++) {
      const curr = pathPoints[i];
      const prevX = (i === 0) ? 0 : pathPoints[i - 1].x;
      const prevY = (i === 0) ? startY : pathPoints[i - 1].y;
      const dx = curr.x - prevX;

      if (curr.type === 'return') {
        // Quick return - tighter curve
        const cp1x = prevX + dx * 0.2;
        const cp2x = prevX + dx * 0.8;
        pathD += ` C ${cp1x} ${prevY}, ${cp2x} ${curr.y}, ${curr.x} ${curr.y}`;
      } else {
        // Flattened S-curve - control points closer to middle for less sinusoidal shape
        const cp1x = prevX + dx * 0.42;
        const cp2x = prevX + dx * 0.58;
        pathD += ` C ${cp1x} ${prevY}, ${cp2x} ${curr.y}, ${curr.x} ${curr.y}`;
      }
    }

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathD);
    path.setAttribute('class', 'motionPath');
    svg.appendChild(path);
  }

  // Draw clickable string markers for each beat
  // We need to draw all three string positions per beat (active or not) for clicking
  for (let i = 0; i < numBeats; i++) {
    const beat = strumPattern[i];
    const beatX = beatWidth * i + beatWidth * 0.08; // Slightly offset from beat line
    const direction = beat.direction === 'none' ? 'down' : beat.direction;

    ['upper', 'mid', 'bass'].forEach((stringName) => {
      const y = stringY[stringName];
      const isActive = beat.strings[stringName] && beat.direction !== 'none';

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('class', 'stringMarker' + (isActive ? '' : ' inactive'));
      g.setAttribute('data-beat', i);
      g.setAttribute('data-string', stringName);
      g.style.cursor = 'pointer';

      // Click handler to toggle string
      g.addEventListener('click', (e) => {
        e.stopPropagation();
        strumPattern[i].strings[stringName] = !strumPattern[i].strings[stringName];
        // Don't auto-change direction - motion path stays consistent
        // User must explicitly change direction if they want sound on a rest beat
        el.patternSelect.value = 'custom';
        renderStrumPattern();
      });

      if (beat.muted && isActive) {
        // Draw X for muted
        const xG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        xG.setAttribute('class', 'stringX');
        const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line1.setAttribute('x1', beatX - xSize);
        line1.setAttribute('y1', y - xSize);
        line1.setAttribute('x2', beatX + xSize);
        line1.setAttribute('y2', y + xSize);
        const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line2.setAttribute('x1', beatX - xSize);
        line2.setAttribute('y1', y + xSize);
        line2.setAttribute('x2', beatX + xSize);
        line2.setAttribute('y2', y - xSize);
        xG.appendChild(line1);
        xG.appendChild(line2);
        g.appendChild(xG);
      } else {
        // Draw arrow pointing in strum direction
        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        let points;
        if (direction === 'down') {
          // Arrow pointing down
          points = `${beatX},${y + arrowSize} ${beatX - arrowSize * 0.6},${y - arrowSize * 0.5} ${beatX + arrowSize * 0.6},${y - arrowSize * 0.5}`;
        } else {
          // Arrow pointing up
          points = `${beatX},${y - arrowSize} ${beatX - arrowSize * 0.6},${y + arrowSize * 0.5} ${beatX + arrowSize * 0.6},${y + arrowSize * 0.5}`;
        }
        arrow.setAttribute('points', points);
        arrow.setAttribute('class', 'stringArrow' + (isActive ? '' : ' inactive'));
        g.appendChild(arrow);
      }

      // Invisible larger hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      hitArea.setAttribute('x', beatX - arrowSize);
      hitArea.setAttribute('y', y - arrowSize);
      hitArea.setAttribute('width', arrowSize * 2);
      hitArea.setAttribute('height', arrowSize * 2);
      hitArea.setAttribute('fill', 'transparent');
      g.appendChild(hitArea);

      svg.appendChild(g);
    });
  }

  container.appendChild(svg);
}

function highlightActiveCell() {
  const cells = el.strip.querySelectorAll('.chord');
  cells.forEach(c => c.classList.remove('active'));
  const active = cells[chordIdx];
  if (active) {
    active.classList.add('active');
    const prog = active.querySelector('.beatProg');
    if (prog) prog.style.width = '0%';
  }
}

function highlightActiveStrum(idx) {
  const beats = el.strumContainer.querySelectorAll('.strumBeat');
  beats.forEach(b => b.classList.remove('active'));
  if (idx >= 0 && idx < beats.length) {
    beats[idx].classList.add('active');
  }

  // Update motion overlay markers using data-beat attribute
  const svg = document.getElementById('motionOverlay');
  if (svg) {
    svg.querySelectorAll('.stringMarker').forEach(m => m.classList.remove('activeMarker'));

    if (idx >= 0) {
      svg.querySelectorAll(`.stringMarker[data-beat="${idx}"]:not(.inactive)`).forEach(m => m.classList.add('activeMarker'));
    }
  }
}

function updateBeatProgress(now) {
  const durBar = (60 / bpm) * 4;
  const p = (now - barStart) / durBar; // 0..1 per bar
  const prog = el.strip.querySelector('.chord.active .beatProg');
  if (prog) prog.style.width = Math.max(0, Math.min(100, p * 100)) + '%';

  // Update strum highlight
  const strumIdx = Math.floor(p * strumPattern.length);
  if (strumIdx !== currentStrumIdx && strumIdx < strumPattern.length) {
    currentStrumIdx = strumIdx;
    highlightActiveStrum(currentStrumIdx);
  }
}

// =========================
// Transport & scheduling
// =========================
function scheduleBar(t) {
  if (muted) return; // Skip sound generation when muted

  const beatDur = 60 / bpm;
  const bar  = beatDur * 4;
  const eighthNote = beatDur / 2;

  if (chordsOn && chords.length) {
    const ch = chords[chordIdx];
    const triad = buildTriad(48 + ch.root, ch.quality);

    // Schedule each strum in the pattern
    strumPattern.forEach((strumBeat, i) => {
      const strumTime = t + (i * eighthNote);
      const strumDur = eighthNote * 0.9; // Slightly shorter than full eighth
      voiceStrumBeat(triad, strumTime, strumDur, strumBeat);
    });
  }

  if (drumsOn) {
    for (let b = 0; b < 4; b++) {
      const bt = t + b * beatDur;
      if (b === 0 || b === 2) voiceKick(bt);
      if (b === 1 || b === 3) voiceSnare(bt);
      voiceHat(bt);
      voiceHat(bt + beatDur / 2);
    }
  }

  if (!drumsOn && !chordsOn) {
    for (let b = 0; b < 4; b++) {
      const bt = t + b * beatDur;
      voiceMetro(bt, b === 0);
    }
  }
}

function advanceBar() {
  const durBar = (60 / bpm) * 4;
  chordIdx = (chordIdx + 1) % chords.length;
  barStart += durBar;
  currentStrumIdx = -1;
  if (chordIdx === 0) {
    const first = el.strip.querySelector('.chord[data-idx="0"]');
    if (first) {
      first.classList.add('loopFlash');
      setTimeout(() => first.classList.remove('loopFlash'), 350);
    }
  }
  scheduleBar(barStart);
}

function tickRAF() {
  if (!playing) return;
  const now = ctx.currentTime;
  const durBar = (60 / bpm) * 4;
  const p = (now - barStart) / durBar;
  if (p >= 1) {
    advanceBar();
    highlightActiveCell();
    requestAnimationFrame(tickRAF);
    return;
  }
  updateBeatProgress(now);
  requestAnimationFrame(tickRAF);
}

// =========================
// Parsing & rebuilding
// =========================
function parseProgressionFromInput() {
  const raw = el.literalInput.value;
  const arr = [];
  raw.split('|').forEach(tok => {
    const p = parseLiteralToken(tok);
    if (p) arr.push(p);
  });
  return arr.length ? arr : null;
}

function rebuildFromInputs() {
  const parsed = parseProgressionFromInput();
  if (!parsed) {
    el.literalInput.classList.add('invalid');
    return false;
  }
  el.literalInput.classList.remove('invalid');
  chords = parsed;
  renderStrip();
  highlightActiveCell();
  return true;
}

// =========================
// UI actions (top-level)
// =========================
function actionPlay() { // start transport
  if (playing) return;
  ctx.resume();
  playing = true;
  chordIdx = 0;
  currentStrumIdx = -1;
  barStart = ctx.currentTime + 0.05;
  highlightActiveCell();
  scheduleBar(barStart);
  tickRAF();
  el.btnPlay.classList.add('playing');
  el.btnStop.classList.remove('stopped');
  updateMuteButton();
}

function actionStop() { // stop transport
  if (!playing) return;
  playing = false;
  currentStrumIdx = -1;
  highlightActiveStrum(-1);

  // Immediately silence all sounds by disconnecting and recreating gain nodes
  chordsGain.disconnect();
  drumsGain.disconnect();
  metroGain.disconnect();
  chordsGain = ctx.createGain(); chordsGain.connect(master);
  drumsGain = ctx.createGain(); drumsGain.connect(master);
  metroGain = ctx.createGain(); metroGain.connect(master);

  el.btnPlay.classList.remove('playing');
  el.btnStop.classList.add('stopped');
  updateMuteButton();
}

function actionToggleDrums() { // toggle drums
  drumsOn = !drumsOn;
  el.btnDrums.classList.toggle('on', drumsOn);
}

function actionToggleChords() { // toggle chord playback
  chordsOn = !chordsOn;
  el.btnChords.classList.toggle('on', chordsOn);
}

function actionMuteToggle() { // toggle mute
  muted = !muted;
  updateMuteButton();

  // Flash the mute button
  el.btnMute.classList.add('flash');
  setTimeout(() => el.btnMute.classList.remove('flash'), 150);
}

function updateMuteButton() {
  if (muted && playing) {
    el.btnMute.classList.add('active');
  } else {
    el.btnMute.classList.remove('active');
  }

  // Update icon based on muted state
  el.btnMute.textContent = muted ? 'üîá Muted' : 'üîä Sound';
}

function actionTapSpace() { // handle a tap sample
  const now = performance.now();
  taps.push(now);
  while (taps.length > 6) taps.shift();
  if (taps.length >= 2) {
    const diffs = taps.slice(1).map((t, i) => t - taps[i]);
    const avg = diffs.reduce((a, b) => a + b, 0) / diffs.length;
    const oldBpm = bpm;
    bpm = Math.max(50, Math.min(200, 60000 / avg));
    el.bpm.value = bpm;
    el.bpmVal.value = bpm;

    if (playing && bpm !== oldBpm) {
      // Clear currently scheduled sounds
      chordsGain.disconnect();
      drumsGain.disconnect();
      metroGain.disconnect();
      chordsGain = ctx.createGain(); chordsGain.connect(master);
      drumsGain = ctx.createGain(); drumsGain.connect(master);
      metroGain = ctx.createGain(); metroGain.connect(master);

      // Preserve current position when changing tempo
      const nowTime = ctx.currentTime;
      const oldDur = (60 / oldBpm) * 4; // old bar duration
      const elapsed = nowTime - barStart;
      const progress = Math.min((elapsed / oldDur) % 1, 0.99); // position within current bar
      const newDur = (60 / bpm) * 4; // new bar duration
      barStart = nowTime - (progress * newDur); // adjust start time to maintain position
      scheduleBar(barStart);
    }

    // Flash the tap button
    el.btnTap.classList.add('flash');
    setTimeout(() => el.btnTap.classList.remove('flash'), 150);
  }
}

function actionSetBPM(val) { // slider or text input changed
  const oldBpm = bpm;
  bpm = Math.max(30, Math.min(300, parseInt(val, 10) || bpm));
  el.bpmVal.value = bpm;
  el.bpm.value = bpm;

  if (playing && bpm !== oldBpm) {
    // Clear currently scheduled sounds
    chordsGain.disconnect();
    drumsGain.disconnect();
    metroGain.disconnect();
    chordsGain = ctx.createGain(); chordsGain.connect(master);
    drumsGain = ctx.createGain(); drumsGain.connect(master);
    metroGain = ctx.createGain(); metroGain.connect(master);

    // Preserve current position when changing tempo
    const now = ctx.currentTime;
    const oldDur = (60 / oldBpm) * 4; // old bar duration
    const elapsed = now - barStart;
    const progress = Math.min((elapsed / oldDur) % 1, 0.99); // position within current bar (0-1)
    const newDur = (60 / bpm) * 4; // new bar duration
    barStart = now - (progress * newDur);
    scheduleBar(barStart);
  }
}

function actionRandom() { // pick a random progression
  const t = [
      'C | G | Am | F',
      'C | F | G | C',
      'C | Am | F | G',
      'Dm | G | C | G',
      // House of the rising sun
      'Am | C | D | F | Am | E | Am | E',
      // 12-bar blues
      'C | C | C | C | F | F | C | C | G | F | C | G',
      'E | E | E | E | A | A | E | E | B | A | E | B',
      'A | A | A | A | D | D | A | A | E | D | A | E',
      'B | B | B | B | E | E | B | B | F# | E | B | F#'
  ];
  el.literalInput.value = t[Math.floor(Math.random() * t.length)];
  rebuildFromInputs();
}

function actionPatternChange(patternName) {
  if (PATTERNS[patternName]) {
    strumPattern = PATTERNS[patternName].map(s => ({...s, strings: {...s.strings}}));
    renderStrumPattern();
  }
}

function actionEnterEditMode() { // focus progression input, disable global shortcuts
  editMode = true;
  tapMode = false;
  el.btnTap.classList.remove('on');
  el.literalInput.classList.add('editing');
  el.literalInput.focus();
  el.literalInput.selectionStart = el.literalInput.value.length;
  el.literalInput.selectionEnd = el.literalInput.value.length;
}

function actionExitEditMode() { // validate, update strip, stay if invalid
  const ok = rebuildFromInputs();
  if (!ok) return; // remain in edit mode until fixed
  editMode = false;
  el.literalInput.classList.remove('editing');
  el.literalInput.blur();
}

function actionKeyDown(e) { // global keyboard shortcuts
  // If editing, only Enter exits; allow all other keys (incl. space) to type
  if (editMode) {
    if (e.code === 'Enter') { e.preventDefault(); actionExitEditMode(); }
    return;
  }

  // Space toggles play/stop
  if (e.code === 'Space') {
    e.preventDefault();
    if (playing) actionStop(); else actionPlay();
    return;
  }

  // Drums toggle (D)
  if (e.code === 'KeyD') { actionToggleDrums(); return; }

  // Chords toggle (C) ‚Äî skip if meta/ctrl pressed
  if (e.code === 'KeyC' && !e.metaKey && !e.ctrlKey) { actionToggleChords(); return; }

  // Random (R) ‚Äî avoid Cmd/Ctrl+R
  if (e.code === 'KeyR' && !e.metaKey && !e.ctrlKey) { e.preventDefault(); actionRandom(); return; }

  // Edit mode (E)
  if (e.code === 'KeyE') { e.preventDefault(); actionEnterEditMode(); return; }

  // Tap tempo (T)
  if (e.code === 'KeyT') { e.preventDefault(); actionTapSpace(); return; }

  // Mute toggle (M)
  if (e.code === 'KeyM') { e.preventDefault(); actionMuteToggle(); return; }

  // BPM +/- keys
  if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
    // Round up to nearest 5, then subtract 5
    const rounded = Math.ceil(bpm / 5) * 5;
    const newBpm = rounded - 5;
    actionSetBPM(newBpm >= 30 ? newBpm : 30);
    return;
  }
  if (e.code === 'Equal' || e.code === 'NumpadAdd') {
    // Round down to nearest 5, then add 5
    const rounded = Math.floor(bpm / 5) * 5;
    const newBpm = rounded + 5;
    actionSetBPM(newBpm <= 300 ? newBpm : 300);
  }
}

// =========================
// Wiring (once)
// =========================
function init() {
  // Cache DOM
  el.btnPlay    = document.getElementById('btnPlay');
  el.btnStop    = document.getElementById('btnStop');
  el.btnMute    = document.getElementById('btnMute');
  el.btnTap     = document.getElementById('btnTap');
  el.btnDrums   = document.getElementById('btnDrums');
  el.btnChords  = document.getElementById('btnChords');
  el.btnRandom  = document.getElementById('btnRandom');
  el.strip      = document.getElementById('strip');
  el.keySelect  = document.getElementById('keySelect');
  el.literalInput = document.getElementById('literalInput');
  el.bpm        = document.getElementById('bpm');
  el.bpmVal     = document.getElementById('bpmVal');
  el.strumContainer = document.getElementById('strumContainer');
  el.dynamicsContainer = document.getElementById('dynamicsContainer');
  el.patternSelect = document.getElementById('patternSelect');

  // Populate keys
  KEYS.forEach(k => {
    const o = document.createElement('option');
    o.value = k; o.textContent = k + ' Major';
    el.keySelect.appendChild(o);
  });
  el.keySelect.value = 'C';

  // One-time event wiring to top-level actions
  el.btnPlay.addEventListener('click', actionPlay);
  el.btnStop.addEventListener('click', actionStop);
  el.btnMute.addEventListener('click', actionMuteToggle);
  el.btnTap.addEventListener('click', actionTapSpace);
  el.btnDrums.addEventListener('click', actionToggleDrums);
  el.btnChords.addEventListener('click', actionToggleChords);
  el.btnRandom.addEventListener('click', actionRandom);

  el.bpm.addEventListener('input', e => actionSetBPM(e.target.value));
  el.bpmVal.addEventListener('input', e => actionSetBPM(e.target.value));
  el.keySelect.addEventListener('change', rebuildFromInputs);
  el.literalInput.addEventListener('focus', () => { if (!editMode) actionEnterEditMode(); });
  el.literalInput.addEventListener('change', rebuildFromInputs);
  el.patternSelect.addEventListener('change', e => actionPatternChange(e.target.value));

  document.body.addEventListener('keydown', actionKeyDown);

  // Re-render motion overlay on resize
  window.addEventListener('resize', () => {
    renderMotionOverlay();
  });

  // Initial build
  rebuildFromInputs();
  renderStrumPattern();
}

// Boot
init();
</script>

Key bindings:
<ul>
  <li>
    SPACE: play or stop
  </li>
  <li>
    D: toggle drums on/off
  </li>
  <li>
    C: toggle chords on/off
  </li>
  <li>
    R: pick random chord progression
  </li>
  <li>
    E: enter edit mode for chord progression
  </li>
  <li>
    T: tap to tempo
  </li>
  <li>
    M: mute
  </li>
  <li>
    -: decrease tempo
  </li>
  <li>
    +: increase tempo
  </li>
  </ul>

Tips:
<ul>
  <li>
    Turning off both drums and chords results in a metronome.
  </li>
  <li>
    Repeatedly click <b>Tap Tempo</b> or the T key to set the tempo, drag the tempo slider, or use the plus (+) and (-) keys.
  </li>
  <li>
    <b>Strum Pattern Editing:</b>
    <ul>
      <li>Click the <b>direction arrow</b> (‚Üì/‚Üë/¬∑) at the top of each beat to cycle through down/up/rest</li>
      <li>Click the <b>string arrows</b> to toggle individual strings on/off</li>
      <li>Click <b>M</b> in the corner to toggle muted (percussive) strumming</li>
      <li>Click the <b>dynamics bar</b> below to cycle soft/medium/loud</li>
    </ul>
  </li>
  </ul>


Errata:
<ul>
  </ul>

</body>
</html>
