<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RiffHound Chord Machine v0.4</title>
<style>
  /* Minimal, readable, big-click targets */
  body { font-family: sans-serif; background: #fff; color: #000; margin: 0; }
  #top { display: flex; flex-wrap: nowrap; gap: 1vh; padding: 1vh; background: #eee; align-items: stretch; }
  #top button { flex: 1 1 0; font-size: 4vh; padding: 2vh 1vw; }
  button { cursor: pointer; border: 1px solid #bbb; }
  button.primary { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  button.primary.playing { background: #007700; color: #fff; border: 1px solid #007700; }
  button.danger { background: #f4f4f4; color: #000; border: 1px solid #999; }
  button.danger.stopped { background: #770000; color: #fff; border: 1px solid #770000; }
  button.toggle { background: #f4f4f4; border: 1px solid #bbb; }
  button.toggle.on { background: #007700; color: #fff; border: 1px solid #007700; }
  button.mute { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  button.flash { background: #4CAF50; color: #fff; }

  #strip { position: relative; display: flex; gap: 0; height: 30vh; border-top: 1px solid #ccc; }
  .chord { flex: 1 1 0; min-width: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; border-right: 1px solid #ddd; text-align: center; }
  .chord:last-child { border-right: none; }
  .chord .literal { font-family: monospace; font-size: 8vw; font-weight: bold; line-height: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .chord .roman { font-size: 3.5vw; color: #333; line-height: 1.2; }
  .chord.active { background: #8389ff; }
  .beatProg { position: absolute; left: 0; top: 0; bottom: 0; width: 0%; background: rgba(0,0,0,0.07); pointer-events: none; }
  #loopMarker { width: 3vw; min-width: 20px; background: repeating-linear-gradient(90deg,#000 0,#000 2px,transparent 2px,transparent 6px); display: flex; align-items: center; justify-content: center; font-size: 2vw; }
  .loopFlash { animation: flash 0.35s ease-in-out 1; }
  @keyframes flash { 0%{box-shadow: inset 0 0 0 6px #ff0;} 100%{box-shadow: inset 0 0 0 0px #ff0;} }

  /* Strum pattern display */
  #strumSection { background: #f8f8f8; padding: 1vh; padding-top: 0; }
  #strumHeader { display: flex; align-items: center; gap: 1em; margin-top: 0.5vh; }

  /* Zoom connector between chord strip and strum pattern */
  #zoomConnector { border-top: 1px solid #ccc; }
  #strumHeader label { font-weight: bold; font-size: 2.2vh; }
  #strumContainer { position: relative; display: flex; gap: 0; height: 29vh; background: #fff; border: 2px solid #999; border-bottom: none; border-radius: 4px 4px 0 0; overflow: hidden; }

  /* Motion overlay SVG */
  #motionOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }
  .motionPath {
    fill: none;
    stroke: #999;
    stroke-width: 3;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .motionPath.rest {
    stroke: #ccc;
    stroke-dasharray: 6 4;
  }
  .stringLine {
    stroke: #ddd;
    stroke-width: 2;
  }
  .beatLine {
    stroke: #e8e8e8;
    stroke-width: 1;
    stroke-dasharray: 4 4;
  }
  .stringMarker {
    cursor: pointer;
    pointer-events: all;
  }
  .stringArrow {
    fill: #333;
  }
  .stringArrow.inactive {
    fill: #ddd;
    stroke: #bbb;
    stroke-width: 1;
  }
  .stringX line {
    stroke: #666;
    stroke-width: 3;
    stroke-linecap: round;
  }
  .stringX.inactive line {
    stroke: #ccc;
    stroke-width: 2;
  }
  .activeMarker .stringArrow {
    fill: #4CAF50;
  }
  .activeMarker .stringX line {
    stroke: #4CAF50;
  }
  .strumBeat { flex: 1 1 0; display: flex; flex-direction: column; align-items: center; justify-content: center; border-right: 2px solid #ccc; position: relative; cursor: pointer; }
  .strumBeat:last-child { border-right: none; }
  .strumBeat:hover { background: #f0f0ff; }
  .strumBeat.active { background: #a0a8ff; }
  .strumBeat .strumIcon { display: none; }
  .strumBeat .strumLabel { display: none; }

  /* Tie indicator in complex view */
  .strumBeat.is-tie { background: #f0f0f0; }
  .strumBeat.is-tie.active { background: #d0d8ff; }
  .strumTie {
    position: absolute;
    top: 3.5vh;
    left: 50%;
    transform: translateX(-50%);
    font-size: 3.5vh;
    color: #999;
    cursor: pointer;
    padding: 0.1em 0.3em;
    border-radius: 4px;
    z-index: 20;
    user-select: none;
  }
  .strumTie:hover { background: rgba(0,0,0,0.1); }

  /* Direction toggle at top of beat */
  .strumDirection {
    position: absolute;
    top: 3.5vh;
    left: 50%;
    transform: translateX(-50%);
    font-size: 3.5vh;
    font-weight: bold;
    cursor: pointer;
    padding: 0.1em 0.3em;
    border-radius: 4px;
    z-index: 20;
    user-select: none;
  }
  .strumDirection:hover { background: rgba(0,0,0,0.1); }
  .strumDirection[data-dir="down"] { color: #0044aa; -webkit-text-stroke: 5px #0044aa; paint-order: stroke fill; }
  .strumDirection[data-dir="up"] { color: #cc5500; -webkit-text-stroke: 5px #cc5500; paint-order: stroke fill; }

  /* Mute toggle */
  .strumMute {
    position: absolute;
    top: 4px;
    right: 4px;
    font-size: 2vh;
    cursor: pointer;
    padding: 0.1em 0.2em;
    border-radius: 3px;
    color: #999;
    z-index: 20;
    user-select: none;
  }
  .strumMute:hover { background: rgba(0,0,0,0.1); }
  .strumMute.active { color: #c00; background: rgba(255,0,0,0.1); }
  .strumBeat .beatNum { font-size: 1.8vh; font-weight: bold; color: #666; position: absolute; top: 2px; left: 50%; transform: translateX(-50%); }

  /* Beat background - subtle based on having active strings */
  .strumBeat { background: #fafafa; }
  .strumBeat.active { background: #d0d8ff; }

  /* Dynamics bar container */
  #dynamicsContainer {
    display: flex;
    gap: 0;
    height: 3vh;
    background: #e8e8e8;
    border: 2px solid #999;
    border-top: none;
    border-radius: 0 0 4px 4px;
    overflow: hidden;
  }
  .dynamicsCell {
    flex: 1 1 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border-right: 2px solid #ccc;
    cursor: pointer;
    padding: 2px;
  }
  .dynamicsCell:last-child { border-right: none; }
  .dynamicsCell:hover { background: #ddd; }
  .dynamicsBar {
    height: 60%;
    background: #666;
    border-radius: 2px;
    transition: width 0.1s;
  }
  .dynamicsCell[data-dynamics="soft"] .dynamicsBar { width: 30%; background: #999; }
  .dynamicsCell[data-dynamics="medium"] .dynamicsBar { width: 60%; background: #666; }
  .dynamicsCell[data-dynamics="loud"] .dynamicsBar { width: 100%; background: #c00; }
  .dynamicsCell[data-type="rest"] .dynamicsBar { width: 0%; }

  /* Icon opacity based on dynamics */
  .strumBeat[data-dynamics="soft"] .strumIcon { opacity: 0.5; }
  .strumBeat[data-dynamics="medium"] .strumIcon { opacity: 0.75; }
  .strumBeat[data-dynamics="loud"] .strumIcon { opacity: 1; }

  /* Animated strum indicator */
  .strumIndicator { position: absolute; bottom: 0; left: 0; right: 0; height: 6px; background: #4CAF50; transform: scaleX(0); transform-origin: left; }
  .strumBeat.active .strumIndicator { animation: strumPulse 0.15s ease-out; }
  @keyframes strumPulse {
    0% { transform: scaleX(0); background: #4CAF50; }
    50% { transform: scaleX(1); background: #8BC34A; }
    100% { transform: scaleX(1); background: #4CAF50; }
  }

  #bottom { padding: 1vh; font-size: 2.2vh; display: flex; flex-wrap: wrap; gap: .6em; align-items: center; }
  #bottom button { background: #f4f4f4; border: 1px solid #bbb; border-radius: 4px; font-size: 2.2vh; padding: 0.3em 0.8em; }
  #bottom button.toggle.on { background: #007700; color: #fff; border: 1px solid #007700; }
  input, select { font-size: 2.2vh; }
  #literalInput.editing { outline: 3px solid #66f; background: #eef; }
  #literalInput.invalid { outline: 3px solid #f00; background: #fee; }

  /* Pattern selector */
  #patternSelect { font-size: 2vh; padding: 0.3em; }

  /* Simple strum view */
  #simpleStrumContainer {
    display: flex;
    gap: 0;
    height: 6vh;
    background: #fff;
    border: 2px solid #999;
    border-radius: 4px;
    overflow: hidden;
  }
  .simpleStrumBeat {
    flex: 1 1 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border-right: 2px solid #ccc;
    cursor: pointer;
    user-select: none;
    font-size: 3.5vh;
    font-weight: bold;
    transition: background 0.1s;
    position: relative;
  }
  .simpleStrumBeat:last-child { border-right: none; }
  .simpleStrumBeat:hover { background: #f0f0ff; }
  .simpleStrumBeat.active { background: #d0d8ff; }
  .simpleStrumBeat .simpleBeatNum {
    font-size: 2vh;
    font-weight: 900;
    color: #666;
    position: absolute;
    top: 1px;
    left: 50%;
    transform: translateX(-50%);
    -webkit-text-stroke: 0;
  }
  .simpleStrumBeat { padding-top: calc(2vh + 5px); }
  .simpleStrumBeat[data-simple="down"] { color: #0044aa; -webkit-text-stroke: 5px #0044aa; paint-order: stroke fill; }
  .simpleStrumBeat[data-simple="up"] { color: #cc5500; -webkit-text-stroke: 5px #cc5500; paint-order: stroke fill; }
  .simpleStrumBeat[data-simple="x"] { color: #c00; -webkit-text-stroke: 3px #c00; paint-order: stroke fill; }
  .simpleStrumBeat[data-simple="rest"] { color: #ccc; }
  .simpleStrumBeat[data-simple="tie"] { color: #888; font-size: 4vh; -webkit-text-stroke: 0; }

  #btnSimpleView { background: #f4f4f4; border: 1px solid #bbb; border-radius: 4px; font-size: 2.2vh; padding: 0.3em 0.8em; }
  #btnSimpleView.on { background: #007700; color: #fff; border: 1px solid #007700; }

  /* BPM display in top row */
  #bpmDisplay {
    font-size: 5.5vh;
    font-weight: bold;
    padding: 0.5vh 0.3vw;
    background: #f4f4f4;
    border: 1px solid #bbb;
    border-radius: 4px;
    width: 3.2ch;
    text-align: center;
    box-sizing: border-box;
  }
</style>
</head>
<body>
  <div id="top">
    <button id="btnPlay"   class="primary">‚ñ∂ Play</button>
    <button id="btnStop"   class="danger stopped">‚èπ Stop</button>
    <button id="btnMute"   class="mute">üîä Sound</button>
    <button id="btnTap">üïí Tap</button>
    <input id="bpmDisplay" type="text" value="100" maxlength="3">
    <button id="btnDrums"  class="toggle">ü•Å Drums</button>
    <button id="btnChords" class="toggle on">üéπ Chords</button>
  </div>

  <div id="strip"></div>

  <svg id="zoomConnector" width="100%" height="8vh" style="display:block; background:#f8f8f8;"></svg>

  <div id="strumSection">
    <div id="strumContainer" style="display:none;"></div>
    <div id="dynamicsContainer" style="display:none;"></div>
    <div id="simpleStrumContainer"></div>
    <div id="strumHeader">
      <label>Strum Pattern:</label>
      <button id="btnSimpleView" class="toggle on">Simple</button>
      <select id="patternSelect">
        <option value="standard" selected>Standard (D‚åíDUDU)</option>
        <option value="quarters">Quarter Notes (D‚åíD‚åíD‚åíD‚åí)</option>
        <option value="basic">Basic (D-D-D-D-)</option>
        <option value="folk">Folk (D-DU-UDU)</option>
        <option value="reggae">Reggae (-M-M-M-M)</option>
        <option value="arpeggio">Arpeggio (B-U-U-U-)</option>
        <option value="boom-chick">Boom-Chick (B-U-D-U-)</option>
        <option value="custom">Custom</option>
      </select>
    </div>
  </div>

  <div id="bottom">
    <label style="font-weight:bold">Chords:</label>
    <input id="literalInput" size="40" value="C: C | F | G | C">
    <select id="progressionSelect"></select>
    <button id="btnRandom">Random</button>
    Transpose: <select id="transposeSelect"></select>
    <button id="btnDouble" class="toggle">Double</button>
    <button id="btnHelp" onclick="document.getElementById('helpSection').scrollIntoView({behavior:'smooth'})">?</button>
  </div>

<script>
// =========================
// v0.4 ‚Äî strumming patterns
// =========================

// --- Strum beat structure ---
// Each beat has: direction ('down'|'up'), strings {bass, mid, upper}, muted, dynamics
// A rest is when no strings are voiced (all false) - direction still indicates hand motion

const DIRECTIONS = ['down', 'up'];
const DIRECTION_ICONS = { down: '‚Üì', up: '‚Üë' };

// Dynamics levels
const DYNAMICS = {
  soft:   { label: 'S', gain: 0.35 },
  medium: { label: 'M', gain: 0.65 },
  loud:   { label: 'L', gain: 1.0 }
};
const DYNAMICS_ORDER = ['soft', 'medium', 'loud'];

// Helper to create a strum beat
function strum(direction, strings = {bass: true, mid: true, upper: true}, muted = false, dynamics = 'medium', tie = false) {
  return { direction, strings: {...strings}, muted, dynamics, tie };
}

// Shorthand helpers for presets
const D = (dyn = 'medium') => strum('down', {bass:true, mid:true, upper:true}, false, dyn);
const U = (dyn = 'medium') => strum('up', {bass:true, mid:true, upper:true}, false, dyn);
// Rest: direction still alternates but no strings are voiced
const Rd = (dyn = 'medium') => strum('down', {bass:false, mid:false, upper:false}, false, dyn);
const Ru = (dyn = 'medium') => strum('up', {bass:false, mid:false, upper:false}, false, dyn);
const M = (dyn = 'medium') => strum('down', {bass:true, mid:true, upper:true}, true, dyn);
const Mu = (dyn = 'medium') => strum('up', {bass:true, mid:true, upper:true}, true, dyn);
const B = (dyn = 'medium') => strum('down', {bass:true, mid:false, upper:false}, false, dyn);
const MD = (dyn = 'medium') => strum('down', {bass:false, mid:true, upper:false}, false, dyn);
const UP = (dyn = 'medium') => strum('up', {bass:false, mid:true, upper:true}, false, dyn);
// Tie: let previous strum ring, no new attack
const Ti = () => strum('down', {bass:false, mid:false, upper:false}, false, 'medium', true);

// Preset patterns (8 eighth notes per bar)
const PATTERNS = {
  standard:    [D('loud'), Ti(), D('soft'), U('soft'), D('soft'), U('soft'), D('soft'), U('soft')],
  quarters:    [D('loud'), Ti(), D('medium'), Ti(), D('loud'), Ti(), D('medium'), Ti()],
  basic:       [D('loud'), Rd(), D('medium'), Rd(), D('loud'), Rd(), D('medium'), Rd()],
  folk:        [D('loud'), Ru(), D('medium'), U('soft'), Rd(), U('soft'), D('medium'), U('soft')],
  reggae:      [Rd(), Mu('medium'), Rd(), Mu('soft'), Rd(), Mu('medium'), Rd(), Mu('soft')],
  arpeggio:    [B('loud'), Ru(), UP('soft'), Rd(), UP('soft'), Rd(), UP('soft'), Rd()],
  'boom-chick': [B('loud'), Ru(), UP('medium'), Rd(), D('loud'), Ru(), UP('medium'), Rd()],
  custom:      [D('loud'), U('soft'), D('medium'), U('soft'), D('loud'), U('soft'), D('medium'), U('soft')]
};

// --- Global state ---
let bpm = 100;
let playing = false;
let muted = false;
let editMode = false;
let drumsOn = false;
let chordsOn = true;
let doubleTime = false;
let originalKey = null;    // Key specified in input (e.g., "C" from "C: C | Am | F"), or null
let originalKeyName = null; // Raw key name string from input (e.g., "Eb", "D#", "C") to detect flat/sharp preference
let originalChords = [];   // Chords as parsed from input (before transposition)
let chords = [];           // Chords after transposition (used for playback/display)
let chordIdx = 0;
let barStart = 0; // audio time of current bar start
let strumPattern = PATTERNS.standard.map(s => ({...s, strings: {...s.strings}}));
let simpleStrumView = true;
let currentStrumIdx = -1;
let doubleTimeAdvanced = false;
let barStartChordIdx = 0;
const taps = [];

// --- DOM refs ---
const el = {};

// --- Audio setup ---
const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const NOTE_NAMES_FLAT = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];
const KEYS = ['C','Db','D','Eb','E','F','F#','G','Ab','A','Bb','B'];

const ctx = new (window.AudioContext || window.webkitAudioContext)();
const master = ctx.createGain(); master.connect(ctx.destination);
let chordsGain = ctx.createGain(); chordsGain.connect(master);
let drumsGain  = ctx.createGain(); drumsGain.connect(master);
let metroGain  = ctx.createGain(); metroGain.connect(master);

// --- One-off buffers ---
const noiseBuf = (() => {
  const b = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
  const d = b.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  return b;
})();

// =========================
// Helpers (theory / parsing)
// =========================
function keyToSemi(k) {
  const m = { Db:1, Eb:3, F:5, Gb:6, Ab:8, Bb:10 };
  return (m[k] != null) ? m[k] : (NOTE_NAMES.indexOf(k) >= 0 ? NOTE_NAMES.indexOf(k) : 0);
}

const NOTE_NAMES_DISPLAY = ['C','C‚ôØ','D','D‚ôØ','E','F','F‚ôØ','G','G‚ôØ','A','A‚ôØ','B'];
const NOTE_NAMES_FLAT_DISPLAY = ['C','D‚ô≠','D','E‚ô≠','E','F','G‚ô≠','G','A‚ô≠','A','B‚ô≠','B'];

function nameForSemi(s, useFlats) {
  const names = useFlats ? NOTE_NAMES_FLAT : NOTE_NAMES;
  return names[(s + 12) % 12];
}

function displayNameForSemi(s, useFlats) {
  const names = useFlats ? NOTE_NAMES_FLAT_DISPLAY : NOTE_NAMES_DISPLAY;
  return names[(s + 12) % 12];
}

function shouldUseFlats() {
  const transposeVal = el.transposeSelect.value;
  if (transposeVal !== '') {
    return transposeVal.includes('b');
  }
  if (originalKeyName) {
    return originalKeyName.includes('b');
  }
  return false;
}

function parseLiteralToken(tok) {
  tok = tok.trim();
  if (!tok) return null;
  const m = tok.match(/^([A-Ga-g])(b|#)?(m)?/);
  if (!m) return null;
  const letter = m[1].toUpperCase();
  const acc = m[2] || '';
  const minor = !!m[3];
  const enh = { Db:'C#', Eb:'D#', Gb:'F#', Ab:'G#', Bb:'A#' };
  const sharp = enh[letter + acc] || (letter + acc);
  const idx = NOTE_NAMES.indexOf(sharp);
  if (idx < 0) return null;
  return { root: idx, quality: minor ? 'm' : 'M' };
}

function romanFor(rootSemi, quality) {
  try {
    // Use effective key (transposed key or original key)
    const key = getEffectiveKey();
    if (key === null) return ''; // No key context, don't show roman numerals
    const deg = (rootSemi - key + 12) % 12;
    const map = { 0:'I', 2:'ii', 4:'iii', 5:'IV', 7:'V', 9:'vi', 11:'vii¬∞' };
    let r = map[deg];
    if (!r) return '?';
    if (quality === 'm') r = r.toLowerCase();
    return r;
  } catch {
    return '?';
  }
}

function buildTriad(rootMidi, quality) {
  const third = (quality === 'm') ? 3 : 4;
  return [rootMidi, rootMidi + third, rootMidi + 7];
}

// =========================
// Audio voice utilities
// =========================

// Strum delay for realistic guitar sound (in seconds)
const STRUM_DELAY = 0.035; // 35ms between each string - noticeable stagger

// notes = [bass, mid, upper] sorted low to high
function voiceStrumBeat(notes, t, dur, beat) {
  // Check if any strings are active - a rest is when no strings are voiced
  const hasActiveStrings = beat.strings.bass || beat.strings.mid || beat.strings.upper;
  if (!hasActiveStrings) return; // Silent (rest)

  const grp = ctx.createGain();
  grp.gain.value = 0;
  grp.connect(chordsGain);

  // Apply dynamics multiplier
  const dynGain = DYNAMICS[beat.dynamics]?.gain || 0.65;

  // Build list of notes to play based on active strings
  // notes array is [bass, mid, upper] (low to high)
  let notesToPlay = [];
  if (beat.strings.bass) notesToPlay.push({ note: notes[0], string: 'bass' });
  if (beat.strings.mid) notesToPlay.push({ note: notes[1], string: 'mid' });
  if (beat.strings.upper) notesToPlay.push({ note: notes[2], string: 'upper' });

  // Sort by strum direction
  if (beat.direction === 'down') {
    // High to low pitch means upper string first (which is highest pitch)
    notesToPlay.sort((a, b) => b.note - a.note);
  } else {
    // Up stroke: low to high pitch means bass string first
    notesToPlay.sort((a, b) => a.note - b.note);
  }

  let delays = notesToPlay.map((_, i) => i * STRUM_DELAY);
  let peak = 0.55 * dynGain;
  let filterFreq = 20000;
  let filterQ = 1;
  let useNoise = false;

  if (beat.muted) {
    delays = notesToPlay.map(() => 0);
    filterFreq = 400;
    filterQ = 4;
    peak = 0.5 * dynGain;
    dur = Math.min(dur, 0.06);
    useNoise = true;
  }

  // Create filter for muted sound
  let filterNode = null;
  if (filterFreq < 20000) {
    filterNode = ctx.createBiquadFilter();
    filterNode.type = 'lowpass';
    filterNode.frequency.value = filterFreq;
    filterNode.Q.value = filterQ;
    filterNode.connect(grp);
  }

  const targetNode = filterNode || grp;

  notesToPlay.forEach((item, i) => {
    const noteStart = t + delays[i];
    const o = ctx.createOscillator();
    o.type = 'triangle';
    o.frequency.value = 440 * Math.pow(2, (item.note - 69) / 12);
    const g = ctx.createGain();
    g.gain.value = 0.6;
    o.connect(g).connect(targetNode);
    o.start(noteStart);
    o.stop(noteStart + dur);
  });

  // Add percussive noise for muted strums
  if (useNoise) {
    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuf;
    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 600;
    noiseFilter.Q.value = 2;
    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.4, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    noise.connect(noiseFilter).connect(noiseGain).connect(grp);
    noise.start(t);
    noise.stop(t + 0.1);
  }

  // Envelope
  const maxDelay = Math.max(...delays);
  const a = 0.02, d = 0.1, s = 0.7, r = 0.06;

  if (beat.muted) {
    // Quick percussive envelope for muted
    grp.gain.setValueAtTime(0, t);
    grp.gain.linearRampToValueAtTime(peak, t + 0.005);
    grp.gain.exponentialRampToValueAtTime(0.001, t + dur);
  } else {
    grp.gain.setValueAtTime(0, t);
    grp.gain.linearRampToValueAtTime(peak, t + maxDelay + a);
    grp.gain.linearRampToValueAtTime(peak * s, t + maxDelay + a + d);
    grp.gain.setValueAtTime(peak * s, t + dur - r);
    grp.gain.linearRampToValueAtTime(0.0001, t + dur);
  }
}

function voiceKick(t) {
  const o = ctx.createOscillator(); o.type = 'sine';
  const g = ctx.createGain();
  o.frequency.setValueAtTime(110, t);
  o.frequency.exponentialRampToValueAtTime(50, t + 0.08);
  g.gain.setValueAtTime(0.9, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  o.connect(g).connect(drumsGain);
  o.start(t); o.stop(t + 0.12);
}

function voiceSnare(t) {
  const s = ctx.createBufferSource(); s.buffer = noiseBuf;
  const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 1800;
  const g = ctx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  s.connect(bp).connect(g).connect(drumsGain);
  s.start(t); s.stop(t + 0.1);
}

function voiceHat(t) {
  const s = ctx.createBufferSource(); s.buffer = noiseBuf;
  const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 6000;
  const g = ctx.createGain(); g.gain.setValueAtTime(0.18, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
  s.connect(hp).connect(g).connect(drumsGain);
  s.start(t); s.stop(t + 0.05);
}

function voiceMetro(t, accent = false) {
  const o = ctx.createOscillator(); o.type = 'square';
  const g = ctx.createGain(); g.gain.value = accent ? 0.25 : 0.12;
  o.frequency.setValueAtTime(accent ? 2000 : 1200, t);
  o.connect(g).connect(metroGain);
  o.start(t); o.stop(t + 0.03);
}

// =========================
// Rendering
// =========================
function renderStrip() {
  el.strip.innerHTML = '';
  if (!chords || chords.length === 0) return;
  const useFlats = shouldUseFlats();
  chords.forEach((ch, i) => {
    const cell = document.createElement('div');
    cell.className = 'chord';
    cell.dataset.idx = i;
    const lit = displayNameForSemi(ch.root, useFlats) + (ch.quality === 'm' ? 'm' : '');
    const rn  = romanFor(ch.root, ch.quality);
    cell.innerHTML = `
      <div class="beatProg"></div>
      <div class="literal">${lit}</div>
      <div class="roman">${rn}</div>
    `;
    el.strip.appendChild(cell);
  });
  const loop = document.createElement('div');
  loop.id = 'loopMarker';
  loop.title = 'Loop start';
  loop.textContent = '‚Ü©';
  el.strip.appendChild(loop);
}

function renderStrumPattern() {
  el.strumContainer.innerHTML = '';
  el.dynamicsContainer.innerHTML = '';

  strumPattern.forEach((beat, i) => {
    // Strum beat cell
    const beatEl = document.createElement('div');
    beatEl.className = 'strumBeat';
    beatEl.dataset.idx = i;
    beatEl.dataset.dynamics = beat.dynamics;

    // Check if any strings are active - a rest is when no strings are voiced
    const hasActiveStrings = beat.strings.bass || beat.strings.mid || beat.strings.upper;
    const isRest = !hasActiveStrings;
    const isTie = !!beat.tie;

    if (isTie) {
      beatEl.classList.add('is-tie');
      beatEl.innerHTML = `
        <div class="beatNum">${Math.floor(i/2) + 1}${i % 2 === 0 ? '' : '&'}</div>
        <div class="strumTie">‚åí</div>
        <div class="strumIndicator"></div>
      `;
      // Clicking the tie symbol removes the tie (reverts to a down strum)
      beatEl.querySelector('.strumTie').addEventListener('click', (e) => {
        e.stopPropagation();
        applySimpleState(i, 'down');
        el.patternSelect.value = 'custom';
        renderStrumPattern();
      });
    } else {
      beatEl.innerHTML = `
        <div class="beatNum">${Math.floor(i/2) + 1}${i % 2 === 0 ? '' : '&'}</div>
        <div class="strumDirection" data-dir="${beat.direction}">${DIRECTION_ICONS[beat.direction]}</div>
        <div class="strumMute ${beat.muted ? 'active' : ''}" title="Mute">M</div>
        <div class="strumIndicator"></div>
      `;

      // Direction toggle at top - cycles down ‚Üí up ‚Üí tie
      const dirEl = beatEl.querySelector('.strumDirection');
      dirEl.addEventListener('click', (e) => {
        e.stopPropagation();
        if (beat.direction === 'down') {
          strumPattern[i].direction = 'up';
        } else {
          applySimpleState(i, 'tie');
        }
        el.patternSelect.value = 'custom';
        renderStrumPattern();
      });

      // Mute toggle
      const muteEl = beatEl.querySelector('.strumMute');
      muteEl.addEventListener('click', (e) => {
        e.stopPropagation();
        strumPattern[i].muted = !strumPattern[i].muted;
        el.patternSelect.value = 'custom';
        renderStrumPattern();
      });
    }

    el.strumContainer.appendChild(beatEl);

    // Dynamics cell
    const dynCell = document.createElement('div');
    dynCell.className = 'dynamicsCell';
    dynCell.dataset.idx = i;
    dynCell.dataset.dynamics = beat.dynamics;
    // Show empty bar for rest or tie
    if (isRest || isTie) {
      dynCell.dataset.type = 'rest';
    }
    dynCell.innerHTML = '<div class="dynamicsBar"></div>';

    dynCell.addEventListener('click', () => {
      const currentIdx = DYNAMICS_ORDER.indexOf(beat.dynamics);
      const nextIdx = (currentIdx + 1) % DYNAMICS_ORDER.length;
      strumPattern[i].dynamics = DYNAMICS_ORDER[nextIdx];
      el.patternSelect.value = 'custom';
      renderStrumPattern();
    });

    el.dynamicsContainer.appendChild(dynCell);
  });

  renderMotionOverlay();
}

// Render the motion path SVG overlay
function renderMotionOverlay() {
  // Remove existing overlay
  const existing = document.getElementById('motionOverlay');
  if (existing) existing.remove();

  const container = el.strumContainer;
  const width = container.clientWidth;
  const height = container.clientHeight;
  if (width === 0 || height === 0) return;

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.id = 'motionOverlay';
  svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
  svg.setAttribute('preserveAspectRatio', 'none');

  const numBeats = strumPattern.length;
  const beatWidth = width / numBeats;

  // Strings are clustered in the middle, with more room above/below for hand motion
  const stringClusterHeight = height * 0.25;
  const stringAreaTop = (height - stringClusterHeight) / 2;
  const stringAreaBottom = stringAreaTop + stringClusterHeight;
  const stringSpacing = stringClusterHeight / 2;

  // String Y positions (upper at top, bass at bottom)
  const stringY = {
    upper: stringAreaTop,
    mid: stringAreaTop + stringSpacing,
    bass: stringAreaBottom
  };

  // Overshoot positions for natural hand motion (well past the strings)
  const overshootAmount = height * 0.28;
  const aboveStrings = stringY.upper - overshootAmount;
  const belowStrings = stringY.bass + overshootAmount;

  // Draw string lines
  Object.values(stringY).forEach(y => {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', 0);
    line.setAttribute('y1', y);
    line.setAttribute('x2', width);
    line.setAttribute('y2', y);
    line.setAttribute('class', 'stringLine');
    svg.appendChild(line);
  });

  // Draw vertical beat lines
  for (let i = 0; i <= numBeats; i++) {
    const x = beatWidth * i;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x);
    line.setAttribute('y1', 0);
    line.setAttribute('x2', x);
    line.setAttribute('y2', height);
    line.setAttribute('class', 'beatLine');
    svg.appendChild(line);
  }

  const arrowSize = Math.min(beatWidth * 0.12, 12);
  const xSize = arrowSize * 0.6;

  // Helper to check if a beat is a rest (no strings voiced)
  const isRestBeat = (beat) => !beat.strings.bass && !beat.strings.mid && !beat.strings.upper;

  // Helper to get start/end Y positions for a direction
  const getStartY = (dir) => (dir === 'down') ? aboveStrings : belowStrings;
  const getEndY = (dir) => (dir === 'down') ? belowStrings : aboveStrings;

  // Helper to create a motion path element
  const createMotionPath = (pathD, isRest) => {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathD);
    path.setAttribute('class', 'motionPath' + (isRest ? ' rest' : ''));
    svg.appendChild(path);
  };

  // Draw motion paths for each beat
  // - Stroke portion: first half of beat (beatStartX to beatCenterX)
  // - Return portion: second half of beat, only if next beat alternates and is not a tie
  for (let i = 0; i < numBeats; i++) {
    const beat = strumPattern[i];

    // Ties: no hand motion shown
    if (beat.tie) continue;

    const dir = beat.direction;
    const isRest = isRestBeat(beat);

    const beatStartX = beatWidth * i;
    const beatCenterX = beatWidth * (i + 0.5);
    const beatEndX = beatWidth * (i + 1);

    const startY = getStartY(dir);
    const endY = getEndY(dir);

    // Draw stroke portion (first half of beat): from startY to endY
    const strokeDx = beatCenterX - beatStartX;
    const cp1x = beatStartX + strokeDx * 0.35;
    const cp2x = beatStartX + strokeDx * 0.65;
    const strokeD = `M ${beatStartX} ${startY} C ${cp1x} ${startY}, ${cp2x} ${endY}, ${beatCenterX} ${endY}`;
    createMotionPath(strokeD, isRest);

    // Check if next beat alternates and is not a tie (don't wrap around to first beat)
    if (i < numBeats - 1) {
      const nextBeat = strumPattern[i + 1];
      if (!nextBeat.tie) {
        const nextDir = nextBeat.direction;
        const alternates = (dir !== nextDir);

        if (alternates) {
          // Draw return portion (second half of beat): connects to next beat's start
          const nextStartY = getStartY(nextDir);
          const returnDx = beatEndX - beatCenterX;
          const rcp1x = beatCenterX + returnDx * 0.35;
          const rcp2x = beatCenterX + returnDx * 0.65;
          const returnD = `M ${beatCenterX} ${endY} C ${rcp1x} ${endY}, ${rcp2x} ${nextStartY}, ${beatEndX} ${nextStartY}`;
          createMotionPath(returnD, isRest);
        }
        // If same direction as next, don't draw return - creates the visual gap
      }
      // If next beat is a tie, leave the second half blank
    }
  }

  // Draw clickable string markers for each beat (skip ties)
  for (let i = 0; i < numBeats; i++) {
    const beat = strumPattern[i];
    if (beat.tie) continue;
    const beatX = beatWidth * i + beatWidth * 0.08;
    const direction = beat.direction;

    ['upper', 'mid', 'bass'].forEach((stringName) => {
      const y = stringY[stringName];
      const isActive = beat.strings[stringName];

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('class', 'stringMarker' + (isActive ? '' : ' inactive'));
      g.setAttribute('data-beat', i);
      g.setAttribute('data-string', stringName);
      g.style.cursor = 'pointer';

      // Click handler to toggle string
      g.addEventListener('click', (e) => {
        e.stopPropagation();
        strumPattern[i].strings[stringName] = !strumPattern[i].strings[stringName];
        el.patternSelect.value = 'custom';
        renderStrumPattern();
      });

      if (beat.muted && isActive) {
        // Draw X for muted
        const xG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        xG.setAttribute('class', 'stringX');
        const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line1.setAttribute('x1', beatX - xSize);
        line1.setAttribute('y1', y - xSize);
        line1.setAttribute('x2', beatX + xSize);
        line1.setAttribute('y2', y + xSize);
        const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line2.setAttribute('x1', beatX - xSize);
        line2.setAttribute('y1', y + xSize);
        line2.setAttribute('x2', beatX + xSize);
        line2.setAttribute('y2', y - xSize);
        xG.appendChild(line1);
        xG.appendChild(line2);
        g.appendChild(xG);
      } else {
        // Draw arrow pointing in strum direction
        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        let points;
        if (direction === 'down') {
          points = `${beatX},${y + arrowSize} ${beatX - arrowSize * 0.6},${y - arrowSize * 0.5} ${beatX + arrowSize * 0.6},${y - arrowSize * 0.5}`;
        } else {
          points = `${beatX},${y - arrowSize} ${beatX - arrowSize * 0.6},${y + arrowSize * 0.5} ${beatX + arrowSize * 0.6},${y + arrowSize * 0.5}`;
        }
        arrow.setAttribute('points', points);
        arrow.setAttribute('class', 'stringArrow' + (isActive ? '' : ' inactive'));
        g.appendChild(arrow);
      }

      // Invisible larger hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      hitArea.setAttribute('x', beatX - arrowSize);
      hitArea.setAttribute('y', y - arrowSize);
      hitArea.setAttribute('width', arrowSize * 2);
      hitArea.setAttribute('height', arrowSize * 2);
      hitArea.setAttribute('fill', 'transparent');
      g.appendChild(hitArea);

      svg.appendChild(g);
    });
  }

  container.appendChild(svg);
}

// Get the simple-view state for a beat
function getSimpleState(beat) {
  if (beat.tie) return 'tie';
  const hasStrings = beat.strings.bass || beat.strings.mid || beat.strings.upper;
  if (!hasStrings) return 'rest';
  if (beat.muted) return 'x';
  return beat.direction; // 'down' or 'up'
}

const SIMPLE_DISPLAY = { down: '‚Üì', up: '‚Üë', x: '‚úï', rest: '', tie: '‚åí' };
const SIMPLE_CYCLE = ['down', 'up', 'x', 'rest', 'tie'];

function applySimpleState(i, newState) {
  const beat = strumPattern[i];
  switch (newState) {
    case 'down':
      beat.tie = false;
      beat.direction = 'down';
      beat.muted = false;
      // Restore strings if currently a rest or tie
      if (!beat.strings.bass && !beat.strings.mid && !beat.strings.upper) {
        beat.strings = { bass: true, mid: true, upper: true };
      }
      break;
    case 'up':
      beat.tie = false;
      beat.direction = 'up';
      beat.muted = false;
      if (!beat.strings.bass && !beat.strings.mid && !beat.strings.upper) {
        beat.strings = { bass: true, mid: true, upper: true };
      }
      break;
    case 'x':
      beat.tie = false;
      beat.muted = true;
      if (!beat.strings.bass && !beat.strings.mid && !beat.strings.upper) {
        beat.strings = { bass: true, mid: true, upper: true };
      }
      break;
    case 'rest':
      beat.tie = false;
      beat.muted = false;
      beat.strings = { bass: false, mid: false, upper: false };
      break;
    case 'tie':
      beat.tie = true;
      beat.muted = false;
      beat.strings = { bass: false, mid: false, upper: false };
      break;
  }
}

function renderSimpleStrumPattern() {
  el.simpleStrumContainer.innerHTML = '';
  strumPattern.forEach((beat, i) => {
    const state = getSimpleState(beat);
    const cell = document.createElement('div');
    cell.className = 'simpleStrumBeat';
    cell.dataset.idx = i;
    cell.dataset.simple = state;
    cell.innerHTML = `<div class="simpleBeatNum">${Math.floor(i/2) + 1}${i % 2 === 0 ? '' : '&'}</div>${SIMPLE_DISPLAY[state]}`;

    cell.addEventListener('click', () => {
      const curState = getSimpleState(strumPattern[i]);
      const nextIdx = (SIMPLE_CYCLE.indexOf(curState) + 1) % SIMPLE_CYCLE.length;
      applySimpleState(i, SIMPLE_CYCLE[nextIdx]);
      el.patternSelect.value = 'custom';
      renderSimpleStrumPattern();
    });

    el.simpleStrumContainer.appendChild(cell);
  });
}

function actionToggleSimpleView() {
  simpleStrumView = !simpleStrumView;
  el.btnSimpleView.classList.toggle('on', simpleStrumView);
  if (simpleStrumView) {
    el.strumContainer.style.display = 'none';
    el.dynamicsContainer.style.display = 'none';
    el.simpleStrumContainer.style.display = 'flex';
    renderSimpleStrumPattern();
  } else {
    el.strumContainer.style.display = 'flex';
    el.dynamicsContainer.style.display = 'flex';
    el.simpleStrumContainer.style.display = 'none';
    renderStrumPattern();
  }
}

function highlightChordCell(idx) {
  const cells = el.strip.querySelectorAll('.chord');
  cells.forEach(c => c.classList.remove('active'));
  const active = cells[idx];
  if (active) {
    active.classList.add('active');
    const prog = active.querySelector('.beatProg');
    if (prog) prog.style.width = '0%';
  }
  renderZoomConnector(idx);
}

function highlightActiveCell() {
  highlightChordCell(chordIdx);
}

function renderZoomConnector(activeIdx) {
  const svg = document.getElementById('zoomConnector');
  svg.innerHTML = '';
  const cells = el.strip.querySelectorAll('.chord');
  if (!cells.length) return;

  const svgRect = svg.getBoundingClientRect();
  const svgW = svgRect.width;
  const svgH = svgRect.height;
  if (svgW === 0 || svgH === 0) return;

  svg.setAttribute('viewBox', `0 0 ${svgW} ${svgH}`);
  svg.setAttribute('preserveAspectRatio', 'none');

  // Get strum section bounds (the visible strum container or simple view)
  const strumEl = simpleStrumView ? el.simpleStrumContainer : el.strumContainer;
  const strumRect = strumEl.getBoundingClientRect();
  // Bottom targets are full width of strum section
  const botLeft = strumRect.left - svgRect.left;
  const botRight = strumRect.right - svgRect.left;

  const drawTrapezoid = (cellIdx, bl, br) => {
    if (cellIdx < 0 || cellIdx >= cells.length) return;
    const cell = cells[cellIdx];
    if (!cell) return;
    const cellRect = cell.getBoundingClientRect();
    const topLeft = cellRect.left - svgRect.left;
    const topRight = cellRect.right - svgRect.left;

    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    poly.setAttribute('points', `${topLeft},0 ${topRight},0 ${br},${svgH} ${bl},${svgH}`);
    poly.setAttribute('fill', 'rgba(131,137,255,0.15)');
    poly.setAttribute('stroke', 'rgba(131,137,255,0.4)');
    poly.setAttribute('stroke-width', '1');
    svg.appendChild(poly);
  };

  if (doubleTime) {
    const idx = activeIdx != null ? activeIdx : chordIdx;
    const inSecondHalf = doubleTimeAdvanced;
    const bl = inSecondHalf ? (botLeft + botRight) / 2 : botLeft;
    const br = inSecondHalf ? botRight : (botLeft + botRight) / 2;
    drawTrapezoid(idx, bl, br);
  } else {
    const idx = activeIdx != null ? activeIdx : chordIdx;
    drawTrapezoid(idx, botLeft, botRight);
  }
}

function highlightActiveStrum(idx) {
  const beats = el.strumContainer.querySelectorAll('.strumBeat');
  beats.forEach(b => b.classList.remove('active'));
  if (idx >= 0 && idx < beats.length) {
    beats[idx].classList.add('active');
  }

  // Simple view highlight
  const simpleBeats = el.simpleStrumContainer.querySelectorAll('.simpleStrumBeat');
  simpleBeats.forEach(b => b.classList.remove('active'));
  if (idx >= 0 && idx < simpleBeats.length) {
    simpleBeats[idx].classList.add('active');
  }

  // Update motion overlay markers using data-beat attribute
  const svg = document.getElementById('motionOverlay');
  if (svg) {
    svg.querySelectorAll('.stringMarker').forEach(m => m.classList.remove('activeMarker'));

    if (idx >= 0) {
      svg.querySelectorAll(`.stringMarker[data-beat="${idx}"]:not(.inactive)`).forEach(m => m.classList.add('activeMarker'));
    }
  }
}

function updateBeatProgress(now) {
  const durBar = (60 / bpm) * 4;
  const p = (now - barStart) / durBar; // 0..1 per bar

  // In double time, visually highlight the second chord at the half-bar
  if (doubleTime && !doubleTimeAdvanced && p >= 0.5 && chords.length > 0) {
    doubleTimeAdvanced = true;
    highlightChordCell((chordIdx + 1) % chords.length);
  }

  // Progress bar: in double time, show progress within each half
  const chordProgress = doubleTime ? ((p % 0.5) / 0.5) : p;
  const prog = el.strip.querySelector('.chord.active .beatProg');
  if (prog) prog.style.width = Math.max(0, Math.min(100, chordProgress * 100)) + '%';

  // Update strum highlight
  const strumIdx = Math.floor(p * strumPattern.length);
  if (strumIdx !== currentStrumIdx && strumIdx < strumPattern.length) {
    currentStrumIdx = strumIdx;
    highlightActiveStrum(currentStrumIdx);
  }
}

// =========================
// Transport & scheduling
// =========================

// Compute strum duration, extending through any consecutive tie beats that follow,
// but not past maxIdx (used to keep double-time halves independent).
function tieDuration(i, eighthNote, maxIdx) {
  let count = 1;
  for (let j = i + 1; j <= maxIdx && strumPattern[j] && strumPattern[j].tie; j++) count++;
  return eighthNote * count * 0.95;
}

function scheduleBar(t) {
  const beatDur = 60 / bpm;
  const bar  = beatDur * 4;
  const eighthNote = beatDur / 2;
  const halfBeats = strumPattern.length / 2;

  if (chordsOn && chords.length) {
    if (doubleTime) {
      // First half: current chord
      const ch1 = chords[chordIdx];
      const triad1 = buildTriad(48 + ch1.root, ch1.quality);
      for (let i = 0; i < halfBeats; i++) {
        const strumTime = t + (i * eighthNote);
        const strumDur = tieDuration(i, eighthNote, halfBeats - 1);
        voiceStrumBeat(triad1, strumTime, strumDur, strumPattern[i]);
      }
      // Second half: next chord
      const ch2 = chords[(chordIdx + 1) % chords.length];
      const triad2 = buildTriad(48 + ch2.root, ch2.quality);
      for (let i = halfBeats; i < strumPattern.length; i++) {
        const strumTime = t + (i * eighthNote);
        const strumDur = tieDuration(i, eighthNote, strumPattern.length - 1);
        voiceStrumBeat(triad2, strumTime, strumDur, strumPattern[i]);
      }
    } else {
      const ch = chords[chordIdx];
      const triad = buildTriad(48 + ch.root, ch.quality);
      strumPattern.forEach((strumBeat, i) => {
        const strumTime = t + (i * eighthNote);
        const strumDur = tieDuration(i, eighthNote, strumPattern.length - 1);
        voiceStrumBeat(triad, strumTime, strumDur, strumBeat);
      });
    }
  }

  if (drumsOn) {
    for (let b = 0; b < 4; b++) {
      const bt = t + b * beatDur;
      if (b === 0 || b === 2) voiceKick(bt);
      if (b === 1 || b === 3) voiceSnare(bt);
      voiceHat(bt);
      voiceHat(bt + beatDur / 2);
    }
  }

  if (!drumsOn && !chordsOn) {
    for (let b = 0; b < 4; b++) {
      const bt = t + b * beatDur;
      voiceMetro(bt, b === 0);
    }
  }
}

function advanceBar() {
  const durBar = (60 / bpm) * 4;
  const advance = doubleTime ? 2 : 1;
  chordIdx = (chordIdx + advance) % chords.length;
  barStartChordIdx = chordIdx;
  barStart += durBar;
  currentStrumIdx = -1;
  doubleTimeAdvanced = false;
  if (chordIdx === 0) {
    const first = el.strip.querySelector('.chord[data-idx="0"]');
    if (first) {
      first.classList.add('loopFlash');
      setTimeout(() => first.classList.remove('loopFlash'), 350);
    }
  }
  scheduleBar(barStart);
}

function tickRAF() {
  if (!playing) return;
  const now = ctx.currentTime;
  const durBar = (60 / bpm) * 4;
  const p = (now - barStart) / durBar;
  if (p >= 1) {
    advanceBar();
    highlightActiveCell();
    requestAnimationFrame(tickRAF);
    return;
  }
  updateBeatProgress(now);
  requestAnimationFrame(tickRAF);
}

// =========================
// Parsing & rebuilding
// =========================
function parseProgressionFromInput() {
  let raw = el.literalInput.value.trim();
  let parsedKey = null;
  let keyName = null;

  // Check for key prefix like "C:" or "Am:" at the start
  const keyMatch = raw.match(/^([A-Ga-g][b#]?m?)\s*:\s*/);
  if (keyMatch) {
    const keyToken = keyMatch[1];
    const keyParsed = parseLiteralToken(keyToken);
    if (keyParsed) {
      // For key, we just need the root (ignore minor for key signature purposes)
      parsedKey = keyParsed.root;
      keyName = keyToken.replace(/m$/, ''); // Store raw name without minor suffix
    }
    // Remove the key prefix from raw
    raw = raw.slice(keyMatch[0].length);
  }

  const arr = [];
  raw.split('|').forEach(tok => {
    const p = parseLiteralToken(tok);
    if (p) arr.push(p);
  });

  return arr.length ? { key: parsedKey, keyName: keyName, chords: arr } : null;
}

// Transpose chords from originalKey to targetKey
function transposeChords(chordList, fromKey, toKey) {
  if (fromKey === null || toKey === null || fromKey === toKey) {
    // No transposition needed
    return chordList.map(ch => ({ ...ch }));
  }
  const interval = (toKey - fromKey + 12) % 12;
  return chordList.map(ch => ({
    root: (ch.root + interval) % 12,
    quality: ch.quality
  }));
}

// Get the effective key for display (transpose target or original)
function getEffectiveKey() {
  // If no original key specified in input, can't determine key context
  if (originalKey === null) return null;

  const transposeVal = el.transposeSelect.value;
  if (transposeVal === '') {
    // No transposition - use original key
    return originalKey;
  }
  return keyToSemi(transposeVal);
}

function rebuildFromInputs() {
  const parsed = parseProgressionFromInput();
  if (!parsed) {
    el.literalInput.classList.add('invalid');
    return false;
  }
  el.literalInput.classList.remove('invalid');

  // Store original key and chords
  originalKey = parsed.key;
  originalKeyName = parsed.keyName;
  originalChords = parsed.chords;

  // Apply transposition if a target key is selected
  const transposeVal = el.transposeSelect.value;
  if (transposeVal === '' || originalKey === null) {
    // No transposition
    chords = originalChords.map(ch => ({ ...ch }));
  } else {
    const targetKey = keyToSemi(transposeVal);
    chords = transposeChords(originalChords, originalKey, targetKey);
  }

  renderStrip();
  highlightActiveCell();
  return true;
}

// =========================
// UI actions (top-level)
// =========================
function actionPlay() { // start transport
  if (playing) return;
  ctx.resume();
  playing = true;
  chordIdx = 0;
  barStartChordIdx = 0;
  currentStrumIdx = -1;
  doubleTimeAdvanced = false;
  barStart = ctx.currentTime + 0.05;
  highlightActiveCell();
  scheduleBar(barStart);
  tickRAF();
  el.btnPlay.classList.add('playing');
  el.btnStop.classList.remove('stopped');
  updateMuteButton();
}

function actionStop() { // stop transport
  if (!playing) return;
  playing = false;
  currentStrumIdx = -1;
  highlightActiveStrum(-1);

  // Immediately silence all sounds by disconnecting and recreating gain nodes
  chordsGain.disconnect();
  drumsGain.disconnect();
  metroGain.disconnect();
  chordsGain = ctx.createGain(); chordsGain.connect(master);
  drumsGain = ctx.createGain(); drumsGain.connect(master);
  metroGain = ctx.createGain(); metroGain.connect(master);

  el.btnPlay.classList.remove('playing');
  el.btnStop.classList.add('stopped');
  updateMuteButton();
}

function actionToggleDrums() { // toggle drums
  drumsOn = !drumsOn;
  el.btnDrums.classList.toggle('on', drumsOn);
}

function actionToggleChords() { // toggle chord playback
  chordsOn = !chordsOn;
  el.btnChords.classList.toggle('on', chordsOn);
}

function actionToggleDouble() { // toggle double time (chords change every 2 beats)
  doubleTime = !doubleTime;
  el.btnDouble.classList.toggle('on', doubleTime);
}

function actionMuteToggle() { // toggle mute
  muted = !muted;
  master.gain.value = muted ? 0 : 1;
  updateMuteButton();

  // Flash the mute button
  el.btnMute.classList.add('flash');
  setTimeout(() => el.btnMute.classList.remove('flash'), 150);
}

function updateMuteButton() {
  if (muted && playing) {
    el.btnMute.classList.add('active');
  } else {
    el.btnMute.classList.remove('active');
  }

  // Update icon based on muted state
  el.btnMute.textContent = muted ? 'üîá Muted' : 'üîä Sound';
}

function actionTapSpace() { // handle a tap sample
  const now = performance.now();
  taps.push(now);
  while (taps.length > 6) taps.shift();
  if (taps.length >= 2) {
    const diffs = taps.slice(1).map((t, i) => t - taps[i]);
    const avg = diffs.reduce((a, b) => a + b, 0) / diffs.length;
    const oldBpm = bpm;
    bpm = Math.max(50, Math.min(200, 60000 / avg));

    el.bpmDisplay.value = Math.round(bpm).toString().slice(0, 3);

    if (playing && bpm !== oldBpm) {
      rescheduleAtNewTempo(oldBpm);
    }

    // Flash the tap button
    el.btnTap.classList.add('flash');
    setTimeout(() => el.btnTap.classList.remove('flash'), 150);
  }
}

function actionSetBPM(val) { // text input or keyboard changed
  const oldBpm = bpm;
  bpm = Math.max(30, Math.min(300, parseInt(val, 10) || bpm));
  el.bpmDisplay.value = Math.round(bpm).toString().slice(0, 3);

  if (playing && bpm !== oldBpm) {
    rescheduleAtNewTempo(oldBpm);
  }
}

function rescheduleAtNewTempo(oldBpm) {
  // Clear currently scheduled sounds
  chordsGain.disconnect();
  drumsGain.disconnect();
  metroGain.disconnect();
  chordsGain = ctx.createGain(); chordsGain.connect(master);
  drumsGain = ctx.createGain(); drumsGain.connect(master);
  metroGain = ctx.createGain(); metroGain.connect(master);

  // Preserve current position when changing tempo
  const now = ctx.currentTime;
  const oldDur = (60 / oldBpm) * 4;
  const elapsed = now - barStart;
  const progress = Math.min((elapsed / oldDur) % 1, 0.99);
  const newDur = (60 / bpm) * 4;
  barStart = now - (progress * newDur);

  // Only schedule remaining portion of the bar from now
  const beatDur = 60 / bpm;
  const eighthNote = beatDur / 2;
  const currentEighth = Math.floor(progress * strumPattern.length);
  const halfBeats = strumPattern.length / 2;

  if (chordsOn && chords.length) {
    if (doubleTime) {
      const ch1 = chords[chordIdx];
      const triad1 = buildTriad(48 + ch1.root, ch1.quality);
      const nextChordIdx = (chordIdx + 1) % chords.length;
      const ch2 = chords[doubleTimeAdvanced ? nextChordIdx : nextChordIdx];
      const triad2 = buildTriad(48 + ch2.root, ch2.quality);
      for (let i = currentEighth; i < strumPattern.length; i++) {
        const strumTime = barStart + (i * eighthNote);
        const maxIdx = i < halfBeats ? halfBeats - 1 : strumPattern.length - 1;
        const strumDur = tieDuration(i, eighthNote, maxIdx);
        const triad = i < halfBeats ? triad1 : triad2;
        voiceStrumBeat(triad, strumTime, strumDur, strumPattern[i]);
      }
    } else {
      const ch = chords[chordIdx];
      const triad = buildTriad(48 + ch.root, ch.quality);
      for (let i = currentEighth; i < strumPattern.length; i++) {
        const strumTime = barStart + (i * eighthNote);
        const strumDur = tieDuration(i, eighthNote, strumPattern.length - 1);
        voiceStrumBeat(triad, strumTime, strumDur, strumPattern[i]);
      }
    }
  }

  if (drumsOn) {
    for (let b = 0; b < 4; b++) {
      const bt = barStart + b * beatDur;
      if (bt < now) continue;
      if (b === 0 || b === 2) voiceKick(bt);
      if (b === 1 || b === 3) voiceSnare(bt);
      voiceHat(bt);
      voiceHat(bt + beatDur / 2);
    }
  }

  if (!drumsOn && !chordsOn) {
    for (let b = 0; b < 4; b++) {
      const bt = barStart + b * beatDur;
      if (bt < now) continue;
      voiceMetro(bt, b === 0);
    }
  }
}

// Preset chord progressions with labels
const PROGRESSIONS = [
  { label: "I-V-vi-IV (Don't Stop Believin')", value: 'C: C | G | Am | F' },
  { label: "I-vi-IV-V - 50s (Stand By Me)", value: 'C: C | Am | F | G' },
  { label: "vi-IV-I-V (With or Without You)", value: 'C: Am | F | C | G' },
  { label: "I-IV-V-IV (La Bamba)", value: 'C: C | F | G | F' },
  { label: "Pachelbel's Canon", value: 'C: C | G | Am | Em | F | C | F | G' },
  { label: "ii-V-I Jazz (Sunday Morning)", value: 'C: Dm | G | C | C' },
  { label: "I-IV-vi-V (What Makes You Beautiful)", value: 'C: C | F | Am | G' },
  { label: "12-Bar Blues", value: 'C: C | C | C | C | F | F | C | C | G | F | C | G' },
  { label: "House of the Rising Sun", value: 'Am: Am | C | D | F | Am | E | Am | E' },
  { label: "Sweet Home Alabama", value: 'G: D | C | G | G' },
  { label: "Knockin' on Heaven's Door", value: 'G: G | D | Am | Am | G | D | C | C' },
  { label: "Country Roads", value: 'G: G | Em | C | G | G | Em | D | D' },
  { label: "Wagon Wheel", value: 'G: G | D | Em | C | G | D | C | C' },
  { label: "Ring of Fire", value: 'G: G | C | G | G | G | D | G | G' },
  { label: "Hallelujah", value: 'C: C | Am | C | Am | F | G | C | G' },
  { label: "Let It Be", value: 'C: C | G | Am | F | C | G | F | C' },
  { label: "Someone Like You (Adele)", value: 'A: A | E | F#m | D' },
  { label: "Rolling in the Deep", value: 'Am: Am | G | F | G' },
  { label: "Creep (Radiohead)", value: 'G: G | B | C | Cm' },
];

function actionRandom() { // pick a random progression
  const prog = PROGRESSIONS[Math.floor(Math.random() * PROGRESSIONS.length)];
  el.literalInput.value = prog.value;
  el.progressionSelect.value = '';  // Reset dropdown to show it's been randomized
  rebuildFromInputs();
}

function actionProgressionChange(value) {
  if (!value) return;  // Ignore empty selection
  el.literalInput.value = value;
  rebuildFromInputs();
}

function actionPatternChange(patternName) {
  if (PATTERNS[patternName]) {
    strumPattern = PATTERNS[patternName].map(s => ({...s, strings: {...s.strings}}));
    if (simpleStrumView) renderSimpleStrumPattern();
    else renderStrumPattern();
  }
}

function actionEnterEditMode() { // focus progression input, disable global shortcuts
  editMode = true;
  tapMode = false;
  el.btnTap.classList.remove('on');
  el.literalInput.classList.add('editing');
  el.literalInput.focus();
  el.literalInput.selectionStart = el.literalInput.value.length;
  el.literalInput.selectionEnd = el.literalInput.value.length;
}

function actionExitEditMode() { // validate, update strip, stay if invalid
  const ok = rebuildFromInputs();
  if (!ok) return; // remain in edit mode until fixed
  editMode = false;
  el.literalInput.classList.remove('editing');
  el.literalInput.blur();
}

function actionKeyDown(e) { // global keyboard shortcuts
  // If editing, only Enter exits; allow all other keys (incl. space) to type
  if (editMode) {
    if (e.code === 'Enter') { e.preventDefault(); actionExitEditMode(); }
    return;
  }

  // Space toggles play/stop
  if (e.code === 'Space') {
    e.preventDefault();
    if (playing) actionStop(); else actionPlay();
    return;
  }

  // Drums toggle (D)
  if (e.code === 'KeyD') { actionToggleDrums(); return; }

  // Chords toggle (C) ‚Äî skip if meta/ctrl pressed
  if (e.code === 'KeyC' && !e.metaKey && !e.ctrlKey) { actionToggleChords(); return; }

  // Random (R) ‚Äî avoid Cmd/Ctrl+R
  if (e.code === 'KeyR' && !e.metaKey && !e.ctrlKey) { e.preventDefault(); actionRandom(); return; }

  // Edit mode (E)
  if (e.code === 'KeyE') { e.preventDefault(); actionEnterEditMode(); return; }

  // Tap tempo (T)
  if (e.code === 'KeyT') { e.preventDefault(); actionTapSpace(); return; }

  // Mute toggle (M)
  if (e.code === 'KeyM') { e.preventDefault(); actionMuteToggle(); return; }

  // BPM +/- keys
  if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
    // Round up to nearest 5, then subtract 5
    const rounded = Math.ceil(bpm / 5) * 5;
    const newBpm = rounded - 5;
    actionSetBPM(newBpm >= 30 ? newBpm : 30);
    return;
  }
  if (e.code === 'Equal' || e.code === 'NumpadAdd') {
    // Round down to nearest 5, then add 5
    const rounded = Math.floor(bpm / 5) * 5;
    const newBpm = rounded + 5;
    actionSetBPM(newBpm <= 300 ? newBpm : 300);
  }
}

// =========================
// Wiring (once)
// =========================
function init() {
  // Cache DOM
  el.btnPlay    = document.getElementById('btnPlay');
  el.btnStop    = document.getElementById('btnStop');
  el.btnMute    = document.getElementById('btnMute');
  el.btnTap     = document.getElementById('btnTap');
  el.btnDrums   = document.getElementById('btnDrums');
  el.btnChords  = document.getElementById('btnChords');
  el.btnRandom  = document.getElementById('btnRandom');
  el.strip      = document.getElementById('strip');
  el.transposeSelect = document.getElementById('transposeSelect');
  el.progressionSelect = document.getElementById('progressionSelect');
  el.literalInput = document.getElementById('literalInput');
  el.bpmDisplay = document.getElementById('bpmDisplay');
  el.btnDouble  = document.getElementById('btnDouble');
  el.strumContainer = document.getElementById('strumContainer');
  el.dynamicsContainer = document.getElementById('dynamicsContainer');
  el.patternSelect = document.getElementById('patternSelect');
  el.btnSimpleView = document.getElementById('btnSimpleView');
  el.simpleStrumContainer = document.getElementById('simpleStrumContainer');

  // Populate transpose dropdown
  // First option is empty (no transposition) - this is the default
  const noTranspose = document.createElement('option');
  noTranspose.value = '';
  noTranspose.textContent = '(none)';
  el.transposeSelect.appendChild(noTranspose);

  KEYS.forEach(k => {
    const o = document.createElement('option');
    o.value = k;
    o.textContent = k;
    el.transposeSelect.appendChild(o);
  });
  el.transposeSelect.value = '';

  // Populate progression dropdown
  const defaultProg = document.createElement('option');
  defaultProg.value = '';
  defaultProg.textContent = '(select progression)';
  el.progressionSelect.appendChild(defaultProg);

  PROGRESSIONS.forEach(prog => {
    const o = document.createElement('option');
    o.value = prog.value;
    o.textContent = prog.label;
    el.progressionSelect.appendChild(o);
  });
  el.progressionSelect.value = '';

  // One-time event wiring to top-level actions
  el.btnPlay.addEventListener('click', actionPlay);
  el.btnStop.addEventListener('click', actionStop);
  el.btnMute.addEventListener('click', actionMuteToggle);
  el.btnTap.addEventListener('click', actionTapSpace);
  el.btnDrums.addEventListener('click', actionToggleDrums);
  el.btnChords.addEventListener('click', actionToggleChords);
  el.btnRandom.addEventListener('click', actionRandom);

  el.btnDouble.addEventListener('click', actionToggleDouble);
  el.bpmDisplay.addEventListener('input', e => {
    // Filter to only allow digits
    e.target.value = e.target.value.replace(/[^0-9]/g, '').slice(0, 3);
  });
  el.bpmDisplay.addEventListener('change', e => {
    const val = parseInt(e.target.value, 10);
    if (val >= 30 && val <= 300) {
      actionSetBPM(val);
    } else {
      // Reset to current BPM if invalid
      e.target.value = Math.round(bpm).toString();
    }
  });
  el.transposeSelect.addEventListener('change', rebuildFromInputs);
  el.progressionSelect.addEventListener('change', e => actionProgressionChange(e.target.value));
  el.literalInput.addEventListener('focus', () => { if (!editMode) actionEnterEditMode(); });
  el.literalInput.addEventListener('change', rebuildFromInputs);
  el.patternSelect.addEventListener('change', e => actionPatternChange(e.target.value));
  el.btnSimpleView.addEventListener('click', actionToggleSimpleView);

  document.body.addEventListener('keydown', actionKeyDown);

  // Re-render motion overlay and zoom connector on resize
  window.addEventListener('resize', () => {
    renderMotionOverlay();
    renderZoomConnector(chordIdx);
  });

  // Initial build
  rebuildFromInputs();
  renderSimpleStrumPattern();
  renderZoomConnector(chordIdx);
  el.btnPlay.focus();
}

// Boot
init();
</script>

<div style="height: 100vh;"></div>
<div id="helpSection" style="padding: 1vh 2vw;">
<h3>Key bindings:</h3>
<ul>
  <li>
    SPACE: play or stop
  </li>
  <li>
    D: toggle drums on/off
  </li>
  <li>
    C: toggle chords on/off
  </li>
  <li>
    R: pick random chord progression
  </li>
  <li>
    E: enter edit mode for chord progression
  </li>
  <li>
    T: tap to tempo
  </li>
  <li>
    M: mute
  </li>
  <li>
    -: decrease tempo
  </li>
  <li>
    +: increase tempo
  </li>
  </ul>

Tips:
<ul>
  <li>
    Turning off both drums and chords results in a metronome.
  </li>
  <li>
    Repeatedly click <b>Tap</b> or press the T key to set the tempo. The BPM is displayed next to the Tap button. You can also drag the tempo slider or use the plus (+) and (-) keys.
  </li>
  <li>
    Select a chord progression from the <b>Progression</b> dropdown, or click <b>Random</b> for a surprise.
  </li>
  <li>
    <b>Key and Transposition:</b>
    <ul>
      <li>Specify a key at the start of the progression: <code>C: C | Am | F | G</code></li>
      <li>Roman numerals are shown when a key is specified</li>
      <li>Use the <b>Transpose</b> dropdown to transpose to a different key</li>
    </ul>
  </li>
  <li>
    <b>Strum Pattern Editing:</b>
    <ul>
      <li>Click the <b>direction arrow</b> (‚Üì/‚Üë) at the top of each beat to toggle down/up</li>
      <li>Click the <b>string arrows</b> to toggle individual strings on/off (turn all off for a rest)</li>
      <li>Click <b>M</b> in the corner to toggle muted (percussive) strumming</li>
      <li>Click the <b>dynamics bar</b> below to cycle soft/medium/loud</li>
    </ul>
  </li>
  </ul>


Errata:
<ul>
  </ul>
</div>

</body>
</html>
