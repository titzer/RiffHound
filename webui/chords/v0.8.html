<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RiffHound Chord Machine v0.8</title>
<style>
  /* Minimal, readable, big-click targets */
  body { font-family: sans-serif; background: #fff; color: #000; margin: 0; }
  #top { display: flex; flex-wrap: nowrap; gap: 1vh; padding: 1vh; background: #eee; align-items: stretch; }
  #top button { flex: 1 1 0; font-size: 3.2vh; padding: 1.2vh 1vw; }
  button { cursor: pointer; border: 1px solid #bbb; }
  button.primary { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  button.primary.playing { background: #007700; color: #fff; border: 1px solid #007700; }
  button.danger { background: #f4f4f4; color: #000; border: 1px solid #999; }
  button.danger.stopped { background: #770000; color: #fff; border: 1px solid #770000; }
  button.toggle { background: #f4f4f4; border: 1px solid #bbb; }
  button.toggle.on { background: #8389ff; color: #fff; border: 1px solid #8389ff; }
  body.playing button.toggle.on { background: #007700; color: #fff; border: 1px solid #007700; }
  button.mute { background: #8389ff; color: #fff; border: 1px solid #8389ff; }
  body.playing button.mute:not(.active) { background: #007700; color: #fff; border: 1px solid #007700; }
  button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  button.flash { background: #4CAF50; color: #fff; }

  #strip { position: relative; display: flex; gap: 0; height: 30vh; border-top: 1px solid #ccc; }
  .chord { flex: 1 1 0; min-width: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; border-right: 1px solid #ddd; text-align: center; }
  .chord:last-child { border-right: none; }
  .chord .literal { font-family: monospace; font-size: 8vw; font-weight: bold; line-height: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .chord .literal .acc { margin-left: -0.1em; letter-spacing: -0.1em; }
  .chord .roman { font-size: 3.5vw; color: #333; line-height: 1.2; }
  .chord.active { background: #8389ff; }
  body.playing .chord.active { background: #007700; }
  body.playing .chord.active .literal { color: #fff; }
  body.playing .chord.active .roman { color: rgba(255,255,255,0.75); }
  .beatProg { position: absolute; left: 0; top: 0; bottom: 0; width: 0%; background: rgba(0,0,0,0.07); pointer-events: none; }
  .loopFlash { animation: flash 0.35s ease-in-out 1; }
  @keyframes flash { 0%{box-shadow: inset 0 0 0 6px #ff0;} 100%{box-shadow: inset 0 0 0 0px #ff0;} }

  /* Strum pattern display */
  #strumSection { background: #f8f8f8; padding: 1vh; padding-top: 0; }
  #strumHeader { display: flex; align-items: center; gap: 1em; margin-top: 0.5vh; }

  /* Zoom connector between chord strip and strum pattern */
  #zoomConnector { border-top: 1px solid #ccc; }
  #strumHeader label { font-weight: bold; font-size: 2.2vh; }
  #strumContainer { position: relative; display: flex; gap: 0; height: 29vh; background: #fff; border: 2px solid #999; border-bottom: none; border-radius: 4px 4px 0 0; overflow: hidden; }

  /* Motion overlay SVG */
  #motionOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }
  .motionPath {
    fill: none;
    stroke: #999;
    stroke-width: 3;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .motionPath.rest {
    stroke: #ccc;
    stroke-dasharray: 6 4;
  }
  .stringLine {
    stroke: #ddd;
    stroke-width: 2;
  }
  .beatLine {
    stroke: #e8e8e8;
    stroke-width: 1;
    stroke-dasharray: 4 4;
  }
  .stringMarker {
    cursor: pointer;
    pointer-events: all;
  }
  .stringArrow {
    fill: #333;
  }
  .stringArrow.inactive {
    fill: #ddd;
    stroke: #bbb;
    stroke-width: 1;
  }
  .stringX line {
    stroke: #666;
    stroke-width: 3;
    stroke-linecap: round;
  }
  .stringX.inactive line {
    stroke: #ccc;
    stroke-width: 2;
  }
  .activeMarker .stringArrow {
    fill: #4CAF50;
  }
  .activeMarker .stringX line {
    stroke: #4CAF50;
  }
  .strumBeat { flex: 1 1 0; display: flex; flex-direction: column; align-items: center; justify-content: center; border-right: 2px solid #ccc; position: relative; cursor: pointer; }
  .strumBeat:last-child { border-right: none; }
  .strumBeat:hover { background: #f0f0ff; }
  .strumBeat.active { background: #a0a8ff; }
  .strumBeat .strumIcon { display: none; }
  .strumBeat .strumLabel { display: none; }

  /* Tie indicator in complex view */
  .strumBeat.is-tie { background: #f0f0f0; }
  .strumBeat.is-tie.active { background: #d0d8ff; }
  body.playing .strumBeat.is-tie.active { background: #c0eac0; }
  .strumTie {
    position: absolute;
    top: 3.5vh;
    left: 50%;
    transform: translateX(-50%);
    font-size: 3.5vh;
    color: #999;
    cursor: pointer;
    padding: 0.1em 0.3em;
    border-radius: 4px;
    z-index: 20;
    user-select: none;
  }
  .strumTie:hover { background: rgba(0,0,0,0.1); }

  /* Direction toggle at top of beat */
  .strumDirection {
    position: absolute;
    top: 3.5vh;
    left: 50%;
    transform: translateX(-50%);
    font-size: 3.5vh;
    font-weight: bold;
    cursor: pointer;
    padding: 0.1em 0.3em;
    border-radius: 4px;
    z-index: 20;
    user-select: none;
  }
  .strumDirection:hover { background: rgba(0,0,0,0.1); }
  .strumDirection[data-dir="down"] { color: #0044aa; -webkit-text-stroke: 1.5px #0044aa; paint-order: stroke fill; }
  .strumDirection[data-dir="up"] { color: #cc5500; -webkit-text-stroke: 1.5px #cc5500; paint-order: stroke fill; }

  /* Mute toggle */
  .strumMute {
    position: absolute;
    top: 4px;
    right: 4px;
    font-size: 2vh;
    cursor: pointer;
    padding: 0.1em 0.2em;
    border-radius: 3px;
    color: #999;
    z-index: 20;
    user-select: none;
  }
  .strumMute:hover { background: rgba(0,0,0,0.1); }
  .strumMute.active { color: #c00; background: rgba(255,0,0,0.1); }
  .strumBeat .beatNum { font-size: 1.8vh; font-weight: bold; color: #666; position: absolute; bottom: 2px; left: 3px; }

  /* Beat background - subtle based on having active strings */
  .strumBeat { background: #fafafa; }
  .strumBeat.active { background: #d0d8ff; }
  body.playing .strumBeat.active { background: #c0eac0; }

  /* Dynamics bar container */
  #dynamicsContainer {
    display: flex;
    gap: 0;
    height: 3vh;
    background: #e8e8e8;
    border: 2px solid #999;
    border-top: none;
    border-radius: 0 0 4px 4px;
    overflow: hidden;
  }
  .dynamicsCell {
    flex: 1 1 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border-right: 2px solid #ccc;
    cursor: pointer;
    padding: 2px;
  }
  .dynamicsCell:last-child { border-right: none; }
  .dynamicsCell:hover { background: #ddd; }
  .dynamicsBar {
    height: 60%;
    background: #666;
    border-radius: 2px;
    transition: width 0.1s;
  }
  .dynamicsCell[data-dynamics="soft"] .dynamicsBar { width: 30%; background: #999; }
  .dynamicsCell[data-dynamics="medium"] .dynamicsBar { width: 60%; background: #666; }
  .dynamicsCell[data-dynamics="loud"] .dynamicsBar { width: 100%; background: #c00; }
  .dynamicsCell[data-type="rest"] .dynamicsBar { width: 0%; }

  /* Icon opacity based on dynamics */
  .strumBeat[data-dynamics="soft"] .strumIcon { opacity: 0.5; }
  .strumBeat[data-dynamics="medium"] .strumIcon { opacity: 0.75; }
  .strumBeat[data-dynamics="loud"] .strumIcon { opacity: 1; }

  /* Animated strum indicator */
  .strumIndicator { position: absolute; bottom: 0; left: 0; right: 0; height: 6px; background: #4CAF50; transform: scaleX(0); transform-origin: left; }
  .strumBeat.active .strumIndicator { animation: strumPulse 0.15s ease-out; }
  @keyframes strumPulse {
    0% { transform: scaleX(0); background: #4CAF50; }
    50% { transform: scaleX(1); background: #8BC34A; }
    100% { transform: scaleX(1); background: #4CAF50; }
  }

  #bottom { padding: 1vh; font-size: 2.2vh; display: flex; flex-wrap: wrap; gap: .6em; align-items: center; }
  #bottom button { background: #f4f4f4; border: 1px solid #bbb; border-radius: 4px; font-size: 2.2vh; padding: 0.3em 0.8em; }
  #bottom button.toggle.on { background: #007700; color: #fff; border: 1px solid #007700; }
  input, select { font-size: 2.2vh; }
  #literalInput.editing { outline: 3px solid #66f; background: #aaf; }
  #literalInput.invalid { outline: 3px solid #f00; background: #fee; }

  /* Pattern selector */
  #patternSelect { font-size: 2vh; padding: 0.3em; }
  #bpcLabel { font-size: 2vh; margin-left: 0.5em; }
  #bpcGroup { display: flex; gap: 0.1em; }
  #bpcGroup label { display: flex; align-items: center; gap: 0.2em; font-size: 2vh; padding: 0.2em 0.5em; border: 1px solid #bbb; border-radius: 3px; cursor: pointer; background: #f4f4f4; }
  #bpcGroup label:has(input:checked) { background: #007700; color: #fff; border-color: #007700; }
  #bpcGroup input[type=radio] { display: none; }

  /* Simple strum view */
  #simpleStrumContainer {
    display: flex;
    gap: 0;
    flex: 1 1 0;
    min-width: 0;
    height: 6vh;
    background: #fff;
    border: 2px solid #999;
    border-radius: 4px;
    overflow: hidden;
  }
  .simpleStrumBeat {
    flex: 1 1 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border-right: 2px solid #ccc;
    cursor: pointer;
    user-select: none;
    font-size: 3.5vh;
    font-weight: bold;
    transition: background 0.1s;
    position: relative;
  }
  .simpleStrumBeat:last-child { border-right: none; }
  .simpleStrumBeat:hover { background: #f0f0ff; }
  .simpleStrumBeat.active { background: #d0d8ff; }
  body.playing .simpleStrumBeat.active { background: #c0eac0; }
  .simpleStrumBeat .simpleBeatNum {
    font-size: 1.8vh;
    font-weight: bold;
    color: #666;
    position: absolute;
    bottom: 2px;
    left: 3px;
    -webkit-text-stroke: 0;
  }
  .simpleStrumBeat { padding-top: 0; }
  .simpleStrumBeat[data-simple="down"] { color: #0044aa; -webkit-text-stroke: 1.5px #0044aa; paint-order: stroke fill; }
  .simpleStrumBeat[data-simple="up"] { color: #cc5500; -webkit-text-stroke: 1.5px #cc5500; paint-order: stroke fill; }
  .simpleStrumBeat[data-simple="x"] { color: #c00; -webkit-text-stroke: 1.5px #c00; paint-order: stroke fill; }
  .simpleStrumBeat[data-simple="rest"] { color: #ccc; }
  .simpleStrumBeat[data-simple="tie"] { color: #888; font-size: 4vh; }

  #rhythmLabel { font-weight: bold; font-size: 2.2vh; cursor: pointer; user-select: none; white-space: nowrap; }

  /* Repeat indicator (right side of chord strip) */
  #repeatIndicator {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 1vw;
    border-left: 2px solid #ddd;
    background: #f8f8f8;
    cursor: pointer;
    flex-shrink: 0;
  }
  .repeatDots {
    display: grid;
    grid-template-rows: repeat(4, 4vh);
    grid-auto-columns: 4vh;
    grid-auto-flow: column;
    gap: 1vh;
  }
  .repeatDot {
    width: 4vh; height: 4vh; border-radius: 50%;
    box-sizing: border-box;
    border: 2.5px solid #555; background: transparent;
    transition: background 0.15s;
  }
  .repeatDot.filled { background: #555; }
  .repeatInfinity { font-size: 7vh; color: #555; line-height: 1; }

  /* Sections panel */
  #sectionsPanel { background: #f0f0f0; border-top: 2px solid #ccc; padding: 0.5vh 1vh; }
.sectionRow {
    display: flex; align-items: center; gap: 0.4em;
    padding: 0.4vh 0.5vh; border-radius: 4px; cursor: pointer;
    font-size: 2vh; border: 1.5px solid transparent; margin-bottom: 2px;
  }
  .sectionRow.active { background: #e0e4ff; border-color: #8389ff; flex-direction: column; align-items: stretch; }
  body.playing .sectionRow.active { background: #d0eed0; border-color: #007700; }
  .sectionRow:hover:not(.active) { background: #e8e8e8; }
  .sectionActiveDot {
    width: 1vh; height: 1vh; border-radius: 50%;
    background: #ccc; border: 1.5px solid #999; flex-shrink: 0;
  }
  .sectionRow.active .sectionActiveDot { background: #8389ff; border-color: #8389ff; }
  body.playing .sectionRow.active .sectionActiveDot { background: #007700; border-color: #007700; }
  .sectionNameInput {
    font-size: 2vh; border: 1px solid transparent; background: transparent;
    border-radius: 3px; padding: 0 0.3em; width: 8em; font-weight: bold;
  }
  .sectionNameInput:focus { border-color: #bbb; background: #fff; outline: none; }
  .sectionProg { flex: 1; font-family: monospace; color: #666; font-size: 1.8vh; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .sectionRepeatArea { display: flex; align-items: center; gap: 3px; min-width: 5em; margin-left: auto; }
  .sectionDots { display: flex; gap: 3px; flex-wrap: wrap; max-width: 8em; }
  .sectionDot { width: 1vh; height: 1vh; border-radius: 50%; border: 1.5px solid #555; background: transparent; }
  .sectionDot.filled { background: #555; }
  .sectionInfSymbol { font-size: 2.5vh; color: #555; line-height: 1; }
  .sectionBtn { background: #f4f4f4; border: 1px solid #bbb; border-radius: 3px; font-size: 1.8vh; padding: 0.1em 0.4em; cursor: pointer; flex-shrink: 0; }
  .sectionBtn:hover { background: #e0e0e0; }
  .sectionBtnDel { color: #c00; border-color: #faa; }
  .sectionBtnDel:hover { background: #fee; }
  .sectionMainRow { display: flex; align-items: center; gap: 0.4em; flex: 1; }
  #sectionEditor { padding: 0.5vh 1vh; background: #f0f0f0; border-top: 1px solid #ccc; display: flex; flex-wrap: wrap; gap: 0.5em; align-items: center; }
  body.chord-editing #sectionEditor { background: #ffaaaa; border-top-color: #f8b8b8; }
  #literalInput { flex: 1; min-width: 14em; font-family: monospace; font-size: 2.2vh; }
  .sectionProg.linked { border-radius: 3px; padding: 0 0.3em; }
  body.chord-editing .sectionProg.linked { background: #ffaaaa; }

  /* Cue strip */
  #cueStrip {
    display: block;
    width: 100%;
    height: 8vh;
    border-bottom: 1px solid #ddd;
    background: #f4f4f8;
  }

  /* BPM display in top row */
  #bpmDisplay {
    font-size: 5.5vh;
    font-weight: bold;
    padding: 0.5vh 0.3vw;
    background: #f4f4f4;
    border: 1px solid #bbb;
    border-radius: 4px;
    width: 3.2ch;
    text-align: center;
    box-sizing: border-box;
  }
</style>
</head>
<body>
  <div id="top">
    <button id="btnPlay"   class="primary">‚ñ∂ Play</button>
    <button id="btnStop"   class="danger stopped">‚èπ Stop</button>
    <button id="btnAgain" title="Add one repeat to current section">Again</button>
    <button id="btnMute"   class="mute">üîä Sound</button>
    <button id="btnTap">üïí Tap</button>
    <input id="bpmDisplay" type="text" value="100" maxlength="3">
    <button id="btnDrums"  class="toggle">ü•Å Drums</button>
    <button id="btnChords" class="toggle on">üéπ Chords</button>
  </div>

  <canvas id="cueStrip"></canvas>

  <div id="strip"></div>

  <svg id="zoomConnector" width="100%" height="8vh" style="display:block; background:#f8f8f8;"></svg>

  <div id="strumSection">
    <div id="strumContainer" style="display:none;"></div>
    <div id="dynamicsContainer" style="display:none;"></div>
    <div id="strumHeader">
      <label id="rhythmLabel">Rhythm ‚ñ∏</label>
      <div id="simpleStrumContainer"></div>
      <select id="patternSelect">
        <option value="standard" selected>Standard (D‚åíDUDU)</option>
        <option value="quarters">Quarter Notes (D‚åíD‚åíD‚åíD‚åí)</option>
        <option value="basic">Basic (D-D-D-D-)</option>
        <option value="folk">Folk (D-DU-UDU)</option>
        <option value="reggae">Reggae (-M-M-M-M)</option>
        <option value="arpeggio">Arpeggio (B-U-U-U-)</option>
        <option value="boom-chick">Boom-Chick (B-U-D-U-)</option>
        <option value="custom">Custom</option>
      </select>
      <label id="bpcLabel">Beats/chord:</label>
      <div id="bpcGroup">
        <label><input type="radio" name="bpc" value="1"> 1</label>
        <label><input type="radio" name="bpc" value="2"> 2</label>
        <label><input type="radio" name="bpc" value="3"> 3</label>
        <label><input type="radio" name="bpc" value="4" checked> 4</label>
      </div>
    </div>
  </div>

  <div id="sectionsPanel">
    <div id="sectionsList"></div>
  </div>

  <div id="sectionEditor">
    <label>Edit Chords:</label>
    <input id="literalInput" value="C: C F G C">
    <select id="progressionSelect"></select>
    <button id="btnRandom">Random</button>
    <span>Transpose:</span>
    <select id="transposeSelect"></select>
  </div>

  <div id="bottom">
    <button id="btnHelp" onclick="document.getElementById('helpSection').scrollIntoView({behavior:'smooth'})">Help ‚Üì</button>
  </div>

<script>
// =========================
// v0.4 ‚Äî strumming patterns
// =========================

// --- Strum beat structure ---
// Each beat has: direction ('down'|'up'), strings {bass, mid, upper}, muted, dynamics
// A rest is when no strings are voiced (all false) - direction still indicates hand motion

const DIRECTIONS = ['down', 'up'];
const DIRECTION_ICONS = { down: '‚Üì', up: '‚Üë' };

// Dynamics levels
const DYNAMICS = {
  soft:   { label: 'S', gain: 0.35 },
  medium: { label: 'M', gain: 0.65 },
  loud:   { label: 'L', gain: 1.0 }
};
const DYNAMICS_ORDER = ['soft', 'medium', 'loud'];

// Helper to create a strum beat
function strum(direction, strings = {bass: true, mid: true, upper: true}, muted = false, dynamics = 'medium', tie = false) {
  return { direction, strings: {...strings}, muted, dynamics, tie };
}

// Shorthand helpers for presets
const D = (dyn = 'medium') => strum('down', {bass:true, mid:true, upper:true}, false, dyn);
const U = (dyn = 'medium') => strum('up', {bass:true, mid:true, upper:true}, false, dyn);
// Rest: direction still alternates but no strings are voiced
const Rd = (dyn = 'medium') => strum('down', {bass:false, mid:false, upper:false}, false, dyn);
const Ru = (dyn = 'medium') => strum('up', {bass:false, mid:false, upper:false}, false, dyn);
const M = (dyn = 'medium') => strum('down', {bass:true, mid:true, upper:true}, true, dyn);
const Mu = (dyn = 'medium') => strum('up', {bass:true, mid:true, upper:true}, true, dyn);
const B = (dyn = 'medium') => strum('down', {bass:true, mid:false, upper:false}, false, dyn);
const MD = (dyn = 'medium') => strum('down', {bass:false, mid:true, upper:false}, false, dyn);
const UP = (dyn = 'medium') => strum('up', {bass:false, mid:true, upper:true}, false, dyn);
// Tie: let previous strum ring, no new attack
const Ti = () => strum('down', {bass:false, mid:false, upper:false}, false, 'medium', true);

// Preset patterns (8 eighth notes per bar)
const PATTERNS = {
  standard:    [D('loud'), Ti(), D('soft'), U('soft'), D('soft'), U('soft'), D('soft'), U('soft')],
  quarters:    [D('loud'), Ti(), D('medium'), Ti(), D('loud'), Ti(), D('medium'), Ti()],
  basic:       [D('loud'), Rd(), D('medium'), Rd(), D('loud'), Rd(), D('medium'), Rd()],
  folk:        [D('loud'), Ru(), D('medium'), U('soft'), Rd(), U('soft'), D('medium'), U('soft')],
  reggae:      [Rd(), Mu('medium'), Rd(), Mu('soft'), Rd(), Mu('medium'), Rd(), Mu('soft')],
  arpeggio:    [B('loud'), Ru(), UP('soft'), Rd(), UP('soft'), Rd(), UP('soft'), Rd()],
  'boom-chick': [B('loud'), Ru(), UP('medium'), Rd(), D('loud'), Ru(), UP('medium'), Rd()],
  custom:      [D('loud'), U('soft'), D('medium'), U('soft'), D('loud'), U('soft'), D('medium'), U('soft')]
};

// --- Global state ---
let bpm = 100;
let playing = false;
let muted = false;
let editMode = false;
let drumsOn = false;
let chordsOn = true;
let beatsPerChord = 4;
let originalKey = null;    // Key specified in input (e.g., "C" from "C: C Am F"), or null
let originalKeyName = null; // Raw key name string from input (e.g., "Eb", "D#", "C") to detect flat/sharp preference
let originalChords = [];   // Chords as parsed from input (before transposition)
let chords = [];           // Chords after transposition (used for playback/display)
let chordIdx = 0;
let barStart = 0; // audio time of current bar start
let cueNow = 0;   // frozen audio time for cue strip (live when playing, frozen when stopped)
let strumPattern = PATTERNS.standard.map(s => ({...s, strings: {...s.strings}}));
let simpleStrumView = true;
let currentStrumIdx = -1;
let beatsIntoChord = 0;   // beats already used from current chord at start of current bar
let barSections = [];     // [{ci, startFrac, endFrac}] chord sections within current bar
let currentBarSection = 0;
let barStartChordIdx = 0;
let prevBarEndChordCi = -1; // chord index at end of the previous bar (for cue strip)
const taps = [];

// --- Song structure ---
function makeSection(name, progression, repeats, patternName) {
  return { name, progression, repeats, repeatsLeft: repeats, patternName: patternName || 'standard', customBeats: null };
}
let sections = [];  // initialized in init()
let sectionIdx = 0;
let editSectionIdx = 0; // which section the editor is showing (may differ from sectionIdx during playback)

// --- DOM refs ---
const el = {};

// --- Audio setup ---
const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const NOTE_NAMES_FLAT = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];
const KEYS = ['C','Db','D','Eb','E','F','F#','G','Ab','A','Bb','B'];

const ctx = new (window.AudioContext || window.webkitAudioContext)();
const master = ctx.createGain(); master.connect(ctx.destination);
let chordsGain = ctx.createGain(); chordsGain.connect(master);
let drumsGain  = ctx.createGain(); drumsGain.connect(master);
let metroGain  = ctx.createGain(); metroGain.connect(master);

// --- One-off buffers ---
const noiseBuf = (() => {
  const b = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
  const d = b.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  return b;
})();

// =========================
// Helpers (theory / parsing)
// =========================
function keyToSemi(k) {
  const m = { Db:1, Eb:3, F:5, Gb:6, Ab:8, Bb:10 };
  return (m[k] != null) ? m[k] : (NOTE_NAMES.indexOf(k) >= 0 ? NOTE_NAMES.indexOf(k) : 0);
}

const NOTE_NAMES_DISPLAY = ['C','C‚ôØ','D','D‚ôØ','E','F','F‚ôØ','G','G‚ôØ','A','A‚ôØ','B'];
const NOTE_NAMES_FLAT_DISPLAY = ['C','D‚ô≠','D','E‚ô≠','E','F','G‚ô≠','G','A‚ô≠','A','B‚ô≠','B'];

function nameForSemi(s, useFlats) {
  const names = useFlats ? NOTE_NAMES_FLAT : NOTE_NAMES;
  return names[(s + 12) % 12];
}

function displayNameForSemi(s, useFlats) {
  const names = useFlats ? NOTE_NAMES_FLAT_DISPLAY : NOTE_NAMES_DISPLAY;
  return names[(s + 12) % 12];
}

function shouldUseFlats() {
  const transposeVal = el.transposeSelect.value;
  if (transposeVal !== '') {
    return transposeVal.includes('b');
  }
  if (originalKeyName) {
    return originalKeyName.includes('b');
  }
  return false;
}

function parseLiteralToken(tok) {
  tok = tok.trim();
  if (!tok) return null;
  const m = tok.match(/^([A-Ga-g])(b|#)?(m)?/);
  if (!m) return null;
  const letter = m[1].toUpperCase();
  const acc = m[2] || '';
  const minor = !!m[3];
  const enh = { Db:'C#', Eb:'D#', Gb:'F#', Ab:'G#', Bb:'A#' };
  const sharp = enh[letter + acc] || (letter + acc);
  const idx = NOTE_NAMES.indexOf(sharp);
  if (idx < 0) return null;
  return { root: idx, quality: minor ? 'm' : 'M' };
}

function romanFor(rootSemi, quality) {
  try {
    // Use effective key (transposed key or original key)
    const key = getEffectiveKey();
    if (key === null) return ''; // No key context, don't show roman numerals
    const deg = (rootSemi - key + 12) % 12;
    const map = { 0:'I', 2:'ii', 4:'iii', 5:'IV', 7:'V', 9:'vi', 11:'vii¬∞' };
    let r = map[deg];
    if (!r) return '?';
    if (quality === 'm') r = r.toLowerCase();
    return r;
  } catch {
    return '?';
  }
}

function buildTriad(rootMidi, quality) {
  const third = (quality === 'm') ? 3 : 4;
  return [rootMidi, rootMidi + third, rootMidi + 7];
}

// =========================
// Audio voice utilities
// =========================

// Strum delay for realistic guitar sound (in seconds)
const STRUM_DELAY = 0.035; // 35ms between each string - noticeable stagger

// notes = [bass, mid, upper] sorted low to high
function voiceStrumBeat(notes, t, dur, beat) {
  // Check if any strings are active - a rest is when no strings are voiced
  const hasActiveStrings = beat.strings.bass || beat.strings.mid || beat.strings.upper;
  if (!hasActiveStrings) return; // Silent (rest)

  const grp = ctx.createGain();
  grp.gain.value = 0;
  grp.connect(chordsGain);

  // Apply dynamics multiplier
  const dynGain = DYNAMICS[beat.dynamics]?.gain || 0.65;

  // Build list of notes to play based on active strings
  // notes array is [bass, mid, upper] (low to high)
  let notesToPlay = [];
  if (beat.strings.bass) notesToPlay.push({ note: notes[0], string: 'bass' });
  if (beat.strings.mid) notesToPlay.push({ note: notes[1], string: 'mid' });
  if (beat.strings.upper) notesToPlay.push({ note: notes[2], string: 'upper' });

  // Sort by strum direction
  if (beat.direction === 'down') {
    // High to low pitch means upper string first (which is highest pitch)
    notesToPlay.sort((a, b) => b.note - a.note);
  } else {
    // Up stroke: low to high pitch means bass string first
    notesToPlay.sort((a, b) => a.note - b.note);
  }

  let delays = notesToPlay.map((_, i) => i * STRUM_DELAY);
  let peak = 0.55 * dynGain;
  let filterFreq = 20000;
  let filterQ = 1;
  let useNoise = false;

  if (beat.muted) {
    delays = notesToPlay.map(() => 0);
    filterFreq = 400;
    filterQ = 4;
    peak = 0.5 * dynGain;
    dur = Math.min(dur, 0.06);
    useNoise = true;
  }

  // Create filter for muted sound
  let filterNode = null;
  if (filterFreq < 20000) {
    filterNode = ctx.createBiquadFilter();
    filterNode.type = 'lowpass';
    filterNode.frequency.value = filterFreq;
    filterNode.Q.value = filterQ;
    filterNode.connect(grp);
  }

  const targetNode = filterNode || grp;

  notesToPlay.forEach((item, i) => {
    const noteStart = t + delays[i];
    const o = ctx.createOscillator();
    o.type = 'triangle';
    o.frequency.value = 440 * Math.pow(2, (item.note - 69) / 12);
    const g = ctx.createGain();
    g.gain.value = 0.6;
    o.connect(g).connect(targetNode);
    o.start(noteStart);
    o.stop(noteStart + dur);
  });

  // Add percussive noise for muted strums
  if (useNoise) {
    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuf;
    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 600;
    noiseFilter.Q.value = 2;
    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.4, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    noise.connect(noiseFilter).connect(noiseGain).connect(grp);
    noise.start(t);
    noise.stop(t + 0.1);
  }

  // Envelope
  const maxDelay = Math.max(...delays);
  const a = 0.02, d = 0.1, s = 0.7, r = 0.06;

  if (beat.muted) {
    // Quick percussive envelope for muted
    grp.gain.setValueAtTime(0, t);
    grp.gain.linearRampToValueAtTime(peak, t + 0.005);
    grp.gain.exponentialRampToValueAtTime(0.001, t + dur);
  } else {
    grp.gain.setValueAtTime(0, t);
    grp.gain.linearRampToValueAtTime(peak, t + maxDelay + a);
    grp.gain.linearRampToValueAtTime(peak * s, t + maxDelay + a + d);
    grp.gain.setValueAtTime(peak * s, t + dur - r);
    grp.gain.linearRampToValueAtTime(0.0001, t + dur);
  }
}

function voiceKick(t) {
  const o = ctx.createOscillator(); o.type = 'sine';
  const g = ctx.createGain();
  o.frequency.setValueAtTime(110, t);
  o.frequency.exponentialRampToValueAtTime(50, t + 0.08);
  g.gain.setValueAtTime(0.9, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  o.connect(g).connect(drumsGain);
  o.start(t); o.stop(t + 0.12);
}

function voiceSnare(t) {
  const s = ctx.createBufferSource(); s.buffer = noiseBuf;
  const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 1800;
  const g = ctx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  s.connect(bp).connect(g).connect(drumsGain);
  s.start(t); s.stop(t + 0.1);
}

function voiceHat(t) {
  const s = ctx.createBufferSource(); s.buffer = noiseBuf;
  const hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 6000;
  const g = ctx.createGain(); g.gain.setValueAtTime(0.18, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
  s.connect(hp).connect(g).connect(drumsGain);
  s.start(t); s.stop(t + 0.05);
}

function voiceMetro(t, accent = false) {
  const o = ctx.createOscillator(); o.type = 'square';
  const g = ctx.createGain(); g.gain.value = accent ? 0.25 : 0.12;
  o.frequency.setValueAtTime(accent ? 2000 : 1200, t);
  o.connect(g).connect(metroGain);
  o.start(t); o.stop(t + 0.03);
}

// =========================
// Rendering
// =========================
function renderStrip() {
  el.strip.innerHTML = '';
  if (!chords || chords.length === 0) return;
  const useFlats = shouldUseFlats();
  chords.forEach((ch, i) => {
    const cell = document.createElement('div');
    cell.className = 'chord';
    cell.dataset.idx = i;
    const lit = (displayNameForSemi(ch.root, useFlats) + (ch.quality === 'm' ? 'm' : ''))
                  .replace(/(‚ôØ|‚ô≠)/g, '<span class="acc">$1</span>');
    const rn  = romanFor(ch.root, ch.quality);
    cell.innerHTML = `
      <div class="beatProg"></div>
      <div class="literal">${lit}</div>
      <div class="roman">${rn}</div>
    `;
    el.strip.appendChild(cell);
  });
  // Repeat indicator (rebuilt each time since strip innerHTML is cleared)
  const ri = document.createElement('div');
  ri.id = 'repeatIndicator';
  el.strip.appendChild(ri);
  el.repeatIndicator = ri;
  renderRepeatIndicator();
}

function renderStrumPattern() {
  el.strumContainer.innerHTML = '';
  el.dynamicsContainer.innerHTML = '';

  strumPattern.forEach((beat, i) => {
    // Strum beat cell
    const beatEl = document.createElement('div');
    beatEl.className = 'strumBeat';
    beatEl.dataset.idx = i;
    beatEl.dataset.dynamics = beat.dynamics;

    // Check if any strings are active - a rest is when no strings are voiced
    const hasActiveStrings = beat.strings.bass || beat.strings.mid || beat.strings.upper;
    const isRest = !hasActiveStrings;
    const isTie = !!beat.tie;

    if (isTie) {
      beatEl.classList.add('is-tie');
      beatEl.innerHTML = `
        <div class="beatNum">${i % 2 === 0 ? Math.floor(i/2) + 1 : ''}</div>
        <div class="strumTie">‚åí</div>
        <div class="strumIndicator"></div>
      `;
      // Clicking the tie symbol removes the tie (reverts to a down strum)
      beatEl.querySelector('.strumTie').addEventListener('click', (e) => {
        e.stopPropagation();
        applySimpleState(i, 'down');
        el.patternSelect.value = 'custom';
        renderStrumPattern();
      });
    } else {
      beatEl.innerHTML = `
        <div class="beatNum">${i % 2 === 0 ? Math.floor(i/2) + 1 : ''}</div>
        <div class="strumDirection" data-dir="${beat.direction}">${DIRECTION_ICONS[beat.direction]}</div>
        <div class="strumMute ${beat.muted ? 'active' : ''}" title="Mute">M</div>
        <div class="strumIndicator"></div>
      `;

      // Direction toggle at top - cycles down ‚Üí up ‚Üí tie
      const dirEl = beatEl.querySelector('.strumDirection');
      dirEl.addEventListener('click', (e) => {
        e.stopPropagation();
        if (beat.direction === 'down') {
          strumPattern[i].direction = 'up';
        } else {
          applySimpleState(i, 'tie');
        }
        el.patternSelect.value = 'custom';
        renderStrumPattern();
      });

      // Mute toggle
      const muteEl = beatEl.querySelector('.strumMute');
      muteEl.addEventListener('click', (e) => {
        e.stopPropagation();
        strumPattern[i].muted = !strumPattern[i].muted;
        el.patternSelect.value = 'custom';
        renderStrumPattern();
      });
    }

    el.strumContainer.appendChild(beatEl);

    // Dynamics cell
    const dynCell = document.createElement('div');
    dynCell.className = 'dynamicsCell';
    dynCell.dataset.idx = i;
    dynCell.dataset.dynamics = beat.dynamics;
    // Show empty bar for rest or tie
    if (isRest || isTie) {
      dynCell.dataset.type = 'rest';
    }
    dynCell.innerHTML = '<div class="dynamicsBar"></div>';

    dynCell.addEventListener('click', () => {
      const currentIdx = DYNAMICS_ORDER.indexOf(beat.dynamics);
      const nextIdx = (currentIdx + 1) % DYNAMICS_ORDER.length;
      strumPattern[i].dynamics = DYNAMICS_ORDER[nextIdx];
      el.patternSelect.value = 'custom';
      renderStrumPattern();
    });

    el.dynamicsContainer.appendChild(dynCell);
  });

  renderMotionOverlay();
}

// Render the motion path SVG overlay
function renderMotionOverlay() {
  // Remove existing overlay
  const existing = document.getElementById('motionOverlay');
  if (existing) existing.remove();

  const container = el.strumContainer;
  const width = container.clientWidth;
  const height = container.clientHeight;
  if (width === 0 || height === 0) return;

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.id = 'motionOverlay';
  svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
  svg.setAttribute('preserveAspectRatio', 'none');

  const numBeats = strumPattern.length;
  const beatWidth = width / numBeats;

  // Strings are clustered in the middle, with more room above/below for hand motion
  const stringClusterHeight = height * 0.25;
  const stringAreaTop = (height - stringClusterHeight) / 2;
  const stringAreaBottom = stringAreaTop + stringClusterHeight;
  const stringSpacing = stringClusterHeight / 2;

  // String Y positions (upper at top, bass at bottom)
  const stringY = {
    upper: stringAreaTop,
    mid: stringAreaTop + stringSpacing,
    bass: stringAreaBottom
  };

  // Overshoot positions for natural hand motion (well past the strings)
  const overshootAmount = height * 0.28;
  const aboveStrings = stringY.upper - overshootAmount;
  const belowStrings = stringY.bass + overshootAmount;

  // Draw string lines
  Object.values(stringY).forEach(y => {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', 0);
    line.setAttribute('y1', y);
    line.setAttribute('x2', width);
    line.setAttribute('y2', y);
    line.setAttribute('class', 'stringLine');
    svg.appendChild(line);
  });

  // Draw vertical beat lines
  for (let i = 0; i <= numBeats; i++) {
    const x = beatWidth * i;
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x);
    line.setAttribute('y1', 0);
    line.setAttribute('x2', x);
    line.setAttribute('y2', height);
    line.setAttribute('class', 'beatLine');
    svg.appendChild(line);
  }

  const arrowSize = Math.min(beatWidth * 0.12, 12);
  const xSize = arrowSize * 0.6;

  // Helper to check if a beat is a rest (no strings voiced)
  const isRestBeat = (beat) => !beat.strings.bass && !beat.strings.mid && !beat.strings.upper;

  // Helper to get start/end Y positions for a direction
  const getStartY = (dir) => (dir === 'down') ? aboveStrings : belowStrings;
  const getEndY = (dir) => (dir === 'down') ? belowStrings : aboveStrings;

  // Helper to create a motion path element
  const createMotionPath = (pathD, isRest) => {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathD);
    path.setAttribute('class', 'motionPath' + (isRest ? ' rest' : ''));
    svg.appendChild(path);
  };

  // Draw motion paths for each beat
  // - Stroke portion: first half of beat (beatStartX to beatCenterX)
  // - Return portion: second half of beat, only if next beat alternates and is not a tie
  for (let i = 0; i < numBeats; i++) {
    const beat = strumPattern[i];

    // Ties: no hand motion shown
    if (beat.tie) continue;

    const dir = beat.direction;
    const isRest = isRestBeat(beat);

    const beatStartX = beatWidth * i;
    const beatCenterX = beatWidth * (i + 0.5);
    const beatEndX = beatWidth * (i + 1);

    const startY = getStartY(dir);
    const endY = getEndY(dir);

    // Draw stroke portion (first half of beat): from startY to endY
    const strokeDx = beatCenterX - beatStartX;
    const cp1x = beatStartX + strokeDx * 0.35;
    const cp2x = beatStartX + strokeDx * 0.65;
    const strokeD = `M ${beatStartX} ${startY} C ${cp1x} ${startY}, ${cp2x} ${endY}, ${beatCenterX} ${endY}`;
    createMotionPath(strokeD, isRest);

    // Check if next beat alternates and is not a tie (don't wrap around to first beat)
    if (i < numBeats - 1) {
      const nextBeat = strumPattern[i + 1];
      if (!nextBeat.tie) {
        const nextDir = nextBeat.direction;
        const alternates = (dir !== nextDir);

        if (alternates) {
          // Draw return portion (second half of beat): connects to next beat's start
          const nextStartY = getStartY(nextDir);
          const returnDx = beatEndX - beatCenterX;
          const rcp1x = beatCenterX + returnDx * 0.35;
          const rcp2x = beatCenterX + returnDx * 0.65;
          const returnD = `M ${beatCenterX} ${endY} C ${rcp1x} ${endY}, ${rcp2x} ${nextStartY}, ${beatEndX} ${nextStartY}`;
          createMotionPath(returnD, isRest);
        }
        // If same direction as next, don't draw return - creates the visual gap
      }
      // If next beat is a tie, leave the second half blank
    }
  }

  // Draw clickable string markers for each beat (skip ties)
  for (let i = 0; i < numBeats; i++) {
    const beat = strumPattern[i];
    if (beat.tie) continue;
    const beatX = beatWidth * i + beatWidth * 0.08;
    const direction = beat.direction;

    ['upper', 'mid', 'bass'].forEach((stringName) => {
      const y = stringY[stringName];
      const isActive = beat.strings[stringName];

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('class', 'stringMarker' + (isActive ? '' : ' inactive'));
      g.setAttribute('data-beat', i);
      g.setAttribute('data-string', stringName);
      g.style.cursor = 'pointer';

      // Click handler to toggle string
      g.addEventListener('click', (e) => {
        e.stopPropagation();
        strumPattern[i].strings[stringName] = !strumPattern[i].strings[stringName];
        el.patternSelect.value = 'custom';
        renderStrumPattern();
      });

      if (beat.muted && isActive) {
        // Draw X for muted
        const xG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        xG.setAttribute('class', 'stringX');
        const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line1.setAttribute('x1', beatX - xSize);
        line1.setAttribute('y1', y - xSize);
        line1.setAttribute('x2', beatX + xSize);
        line1.setAttribute('y2', y + xSize);
        const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line2.setAttribute('x1', beatX - xSize);
        line2.setAttribute('y1', y + xSize);
        line2.setAttribute('x2', beatX + xSize);
        line2.setAttribute('y2', y - xSize);
        xG.appendChild(line1);
        xG.appendChild(line2);
        g.appendChild(xG);
      } else {
        // Draw arrow pointing in strum direction
        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        let points;
        if (direction === 'down') {
          points = `${beatX},${y + arrowSize} ${beatX - arrowSize * 0.6},${y - arrowSize * 0.5} ${beatX + arrowSize * 0.6},${y - arrowSize * 0.5}`;
        } else {
          points = `${beatX},${y - arrowSize} ${beatX - arrowSize * 0.6},${y + arrowSize * 0.5} ${beatX + arrowSize * 0.6},${y + arrowSize * 0.5}`;
        }
        arrow.setAttribute('points', points);
        arrow.setAttribute('class', 'stringArrow' + (isActive ? '' : ' inactive'));
        g.appendChild(arrow);
      }

      // Invisible larger hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      hitArea.setAttribute('x', beatX - arrowSize);
      hitArea.setAttribute('y', y - arrowSize);
      hitArea.setAttribute('width', arrowSize * 2);
      hitArea.setAttribute('height', arrowSize * 2);
      hitArea.setAttribute('fill', 'transparent');
      g.appendChild(hitArea);

      svg.appendChild(g);
    });
  }

  container.appendChild(svg);
}

// Get the simple-view state for a beat
function getSimpleState(beat) {
  if (beat.tie) return 'tie';
  const hasStrings = beat.strings.bass || beat.strings.mid || beat.strings.upper;
  if (!hasStrings) return 'rest';
  if (beat.muted) return 'x';
  return beat.direction; // 'down' or 'up'
}

const SIMPLE_DISPLAY = { down: '‚Üì', up: '‚Üë', x: '‚úï', rest: '', tie: '‚åí' };
const SIMPLE_CYCLE = ['down', 'up', 'x', 'rest', 'tie'];

function applySimpleState(i, newState) {
  const beat = strumPattern[i];
  switch (newState) {
    case 'down':
      beat.tie = false;
      beat.direction = 'down';
      beat.muted = false;
      // Restore strings if currently a rest or tie
      if (!beat.strings.bass && !beat.strings.mid && !beat.strings.upper) {
        beat.strings = { bass: true, mid: true, upper: true };
      }
      break;
    case 'up':
      beat.tie = false;
      beat.direction = 'up';
      beat.muted = false;
      if (!beat.strings.bass && !beat.strings.mid && !beat.strings.upper) {
        beat.strings = { bass: true, mid: true, upper: true };
      }
      break;
    case 'x':
      beat.tie = false;
      beat.muted = true;
      if (!beat.strings.bass && !beat.strings.mid && !beat.strings.upper) {
        beat.strings = { bass: true, mid: true, upper: true };
      }
      break;
    case 'rest':
      beat.tie = false;
      beat.muted = false;
      beat.strings = { bass: false, mid: false, upper: false };
      break;
    case 'tie':
      beat.tie = true;
      beat.muted = false;
      beat.strings = { bass: false, mid: false, upper: false };
      break;
  }
}

function renderSimpleStrumPattern() {
  el.simpleStrumContainer.innerHTML = '';
  strumPattern.forEach((beat, i) => {
    const state = getSimpleState(beat);
    const cell = document.createElement('div');
    cell.className = 'simpleStrumBeat';
    cell.dataset.idx = i;
    cell.dataset.simple = state;
    cell.innerHTML = `<div class="simpleBeatNum">${i % 2 === 0 ? Math.floor(i/2) + 1 : ''}</div>${SIMPLE_DISPLAY[state]}`;

    cell.addEventListener('click', () => {
      const curState = getSimpleState(strumPattern[i]);
      const nextIdx = (SIMPLE_CYCLE.indexOf(curState) + 1) % SIMPLE_CYCLE.length;
      applySimpleState(i, SIMPLE_CYCLE[nextIdx]);
      el.patternSelect.value = 'custom';
      renderSimpleStrumPattern();
    });

    el.simpleStrumContainer.appendChild(cell);
  });
}

function actionToggleSimpleView() {
  simpleStrumView = !simpleStrumView;
  el.rhythmLabel.textContent = simpleStrumView ? 'Rhythm ‚ñ∏' : 'Rhythm ‚ñæ';
  if (simpleStrumView) {
    el.strumContainer.style.display = 'none';
    el.dynamicsContainer.style.display = 'none';
    el.simpleStrumContainer.style.display = 'flex';
    renderSimpleStrumPattern();
  } else {
    el.strumContainer.style.display = 'flex';
    el.dynamicsContainer.style.display = 'flex';
    el.simpleStrumContainer.style.display = 'none';
    renderStrumPattern();
  }
}

function highlightChordCell(idx) {
  const cells = el.strip.querySelectorAll('.chord');
  cells.forEach(c => c.classList.remove('active'));
  const active = cells[idx];
  if (active) {
    active.classList.add('active');
    const prog = active.querySelector('.beatProg');
    if (prog) prog.style.width = '0%';
  }
  renderZoomConnector(idx);
}

function highlightActiveCell() {
  highlightChordCell(chordIdx);
}

function renderZoomConnector(activeIdx) {
  const svg = document.getElementById('zoomConnector');
  svg.innerHTML = '';
  const cells = el.strip.querySelectorAll('.chord');
  if (!cells.length) return;

  const svgRect = svg.getBoundingClientRect();
  const svgW = svgRect.width;
  const svgH = svgRect.height;
  if (svgW === 0 || svgH === 0) return;

  svg.setAttribute('viewBox', `0 0 ${svgW} ${svgH}`);
  svg.setAttribute('preserveAspectRatio', 'none');

  // Get strum section bounds (the visible strum container or simple view)
  const strumEl = simpleStrumView ? el.simpleStrumContainer : el.strumContainer;
  const strumRect = strumEl.getBoundingClientRect();
  // Bottom targets are full width of strum section
  const botLeft = strumRect.left - svgRect.left;
  const botRight = strumRect.right - svgRect.left;

  const drawTrapezoid = (cellIdx, bl, br) => {
    if (cellIdx < 0 || cellIdx >= cells.length) return;
    const cell = cells[cellIdx];
    if (!cell) return;
    const cellRect = cell.getBoundingClientRect();
    const topLeft = cellRect.left - svgRect.left;
    const topRight = cellRect.right - svgRect.left;

    const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    poly.setAttribute('points', `${topLeft},0 ${topRight},0 ${br},${svgH} ${bl},${svgH}`);
    const zc = playing ? '0,119,0' : '131,137,255';
    poly.setAttribute('fill', `rgba(${zc},0.15)`);
    poly.setAttribute('stroke', `rgba(${zc},0.4)`);
    poly.setAttribute('stroke-width', '1');
    svg.appendChild(poly);
  };

  const cs = barSections[currentBarSection];
  const startFrac = cs ? cs.startFrac : 0;
  const endFrac   = cs ? cs.endFrac   : 1;
  const bl = botLeft + startFrac * (botRight - botLeft);
  const br = botLeft + endFrac   * (botRight - botLeft);
  const idx = activeIdx != null ? activeIdx : chordIdx;
  drawTrapezoid(idx, bl, br);
}

function highlightActiveStrum(idx) {
  const beats = el.strumContainer.querySelectorAll('.strumBeat');
  beats.forEach(b => b.classList.remove('active'));
  if (idx >= 0 && idx < beats.length) {
    beats[idx].classList.add('active');
  }

  // Simple view highlight
  const simpleBeats = el.simpleStrumContainer.querySelectorAll('.simpleStrumBeat');
  simpleBeats.forEach(b => b.classList.remove('active'));
  if (idx >= 0 && idx < simpleBeats.length) {
    simpleBeats[idx].classList.add('active');
  }

  // Update motion overlay markers using data-beat attribute
  const svg = document.getElementById('motionOverlay');
  if (svg) {
    svg.querySelectorAll('.stringMarker').forEach(m => m.classList.remove('activeMarker'));

    if (idx >= 0) {
      svg.querySelectorAll(`.stringMarker[data-beat="${idx}"]:not(.inactive)`).forEach(m => m.classList.add('activeMarker'));
    }
  }
}

function updateBeatProgress(now) {
  const durBar = (60 / bpm) * 4;
  const p = (now - barStart) / durBar; // 0..1 per bar

  // Advance through mid-bar chord sections as time progresses
  for (let s = currentBarSection + 1; s < barSections.length; s++) {
    if (p >= barSections[s].startFrac) {
      currentBarSection = s;
      highlightChordCell(barSections[s].ci);
    }
  }

  // Progress bar: show progress within the current chord's section
  const cs = barSections[currentBarSection];
  const chordProgress = cs ? (p - cs.startFrac) / (cs.endFrac - cs.startFrac) : p;
  const prog = el.strip.querySelector('.chord.active .beatProg');
  if (prog) prog.style.width = Math.max(0, Math.min(100, chordProgress * 100)) + '%';

  // Update strum highlight
  const strumIdx = Math.floor(p * strumPattern.length);
  if (strumIdx !== currentStrumIdx && strumIdx < strumPattern.length) {
    currentStrumIdx = strumIdx;
    highlightActiveStrum(currentStrumIdx);
  }
}

// =========================
// Transport & scheduling
// =========================

// Compute strum duration, extending through any consecutive tie beats that follow,
// but not past maxIdx (used to keep double-time halves independent).
function tieDuration(i, eighthNote, maxIdx) {
  let count = 1;
  for (let j = i + 1; j <= maxIdx && strumPattern[j] && strumPattern[j].tie; j++) count++;
  return eighthNote * count * 0.95;
}

// Build barSections from current bar-start state (chordIdx, beatsIntoChord, beatsPerChord).
// Always called unconditionally so barSections is valid even in metronome mode.
function buildBarSections() {
  barSections = [];
  currentBarSection = 0;
  if (!chords.length) return;
  const totalEighths = strumPattern.length;
  const eighthsPerChord = beatsPerChord * 2;
  let eighth = 0, chordPos = beatsIntoChord * 2, localAdvance = 0;
  while (eighth < totalEighths) {
    const count = Math.min(eighthsPerChord - chordPos, totalEighths - eighth);
    const ci = (chordIdx + localAdvance) % chords.length;
    barSections.push({ ci, startFrac: eighth / totalEighths, endFrac: (eighth + count) / totalEighths });
    eighth += count; chordPos = 0; localAdvance++;
  }
}

function scheduleBar(t) {
  const beatDur = 60 / bpm;
  const eighthNote = beatDur / 2;

  buildBarSections();

  if (chordsOn && chords.length) {
    for (const section of barSections) {
      const ch = chords[section.ci];
      const triad = buildTriad(48 + ch.root, ch.quality);
      const startEighth = Math.round(section.startFrac * strumPattern.length);
      const endEighth   = Math.round(section.endFrac   * strumPattern.length);
      const sectionEnd  = endEighth - 1;
      for (let i = startEighth; i < endEighth; i++) {
        voiceStrumBeat(triad, t + i * eighthNote, tieDuration(i, eighthNote, sectionEnd), strumPattern[i]);
      }
    }
  }

  if (drumsOn) {
    for (let b = 0; b < 4; b++) {
      const bt = t + b * beatDur;
      if (b === 0 || b === 2) voiceKick(bt);
      if (b === 1 || b === 3) voiceSnare(bt);
      voiceHat(bt);
      voiceHat(bt + beatDur / 2);
    }
  }

  if (!drumsOn && !chordsOn) {
    for (let b = 0; b < 4; b++) {
      const bt = t + b * beatDur;
      voiceMetro(bt, b === 0);
    }
  }
}

function advanceBar() {
  const durBar = (60 / bpm) * 4;
  // Save end chord of current bar before clearing sections (used by cue strip)
  if (barSections.length > 0) {
    prevBarEndChordCi = barSections[barSections.length - 1].ci;
  }
  // Compute how many chord advances happen in one bar
  const eighthsPerChord = beatsPerChord * 2;
  let pos = beatsIntoChord * 2, remaining = strumPattern.length, advances = 0;
  while (remaining > 0) {
    const left = eighthsPerChord - pos;
    if (remaining >= left) { remaining -= left; pos = 0; advances++; }
    else { pos += remaining; remaining = 0; }
  }
  beatsIntoChord = pos / 2;
  chordIdx = (chordIdx + advances) % chords.length;
  barStartChordIdx = chordIdx;
  barStart += durBar;
  currentStrumIdx = -1;
  barSections = [];
  currentBarSection = 0;
  if (chordIdx === 0) {
    const first = el.strip.querySelector('.chord[data-idx="0"]');
    if (first) {
      first.classList.add('loopFlash');
      setTimeout(() => first.classList.remove('loopFlash'), 350);
    }
    // Section repeat countdown
    const currSection = sections[sectionIdx];
    if (currSection && currSection.repeats !== Infinity) {
      currSection.repeatsLeft--;
      if (currSection.repeatsLeft <= 0) {
        // Advance to next section before scheduling ‚Äî updates chords/pattern
        advanceSection();
      } else {
        renderRepeatIndicator();
        renderSectionsList();
      }
    }
  }
  scheduleBar(barStart);
}

function tickRAF() {
  if (!playing) return;
  const now = ctx.currentTime;
  const durBar = (60 / bpm) * 4;
  const p = (now - barStart) / durBar;
  if (p >= 1) {
    advanceBar();
    highlightActiveCell();
  } else {
    updateBeatProgress(now);
  }
  cueNow = now;
  drawCueStrip();
  requestAnimationFrame(tickRAF);
}

// =========================
// Parsing & rebuilding
// =========================
function parseProgressionFromInput() {
  let raw = el.literalInput.value.trim();
  let parsedKey = null;
  let keyName = null;

  // Check for key prefix like "C:" or "Am:" at the start
  const keyMatch = raw.match(/^([A-Ga-g][b#]?m?)\s*:\s*/);
  if (keyMatch) {
    const keyToken = keyMatch[1];
    const keyParsed = parseLiteralToken(keyToken);
    if (keyParsed) {
      // For key, we just need the root (ignore minor for key signature purposes)
      parsedKey = keyParsed.root;
      keyName = keyToken.replace(/m$/, ''); // Store raw name without minor suffix
    }
    // Remove the key prefix from raw
    raw = raw.slice(keyMatch[0].length);
  }

  const arr = [];
  raw.split(/\s+/).forEach(tok => {
    const p = parseLiteralToken(tok);
    if (p) arr.push(p);
  });

  return arr.length ? { key: parsedKey, keyName: keyName, chords: arr } : null;
}

// Transpose chords from originalKey to targetKey
function transposeChords(chordList, fromKey, toKey) {
  if (fromKey === null || toKey === null || fromKey === toKey) {
    // No transposition needed
    return chordList.map(ch => ({ ...ch }));
  }
  const interval = (toKey - fromKey + 12) % 12;
  return chordList.map(ch => ({
    root: (ch.root + interval) % 12,
    quality: ch.quality
  }));
}

// Get the effective key for display (transpose target or original)
function getEffectiveKey() {
  // If no original key specified in input, can't determine key context
  if (originalKey === null) return null;

  const transposeVal = el.transposeSelect.value;
  if (transposeVal === '') {
    // No transposition - use original key
    return originalKey;
  }
  return keyToSemi(transposeVal);
}

// Load chords for a progression string directly, without touching literalInput.
// Used by advanceSection() during playback when user is editing.
function applyProgressionStr(str) {
  const saved = el.literalInput.value;
  el.literalInput.value = str;
  const parsed = parseProgressionFromInput();
  el.literalInput.value = saved;
  if (!parsed) return;
  originalKey = parsed.key;
  originalKeyName = parsed.keyName;
  originalChords = parsed.chords;
  const transposeVal = el.transposeSelect.value;
  if (transposeVal === '' || originalKey === null) {
    chords = originalChords.map(ch => ({ ...ch }));
  } else {
    const targetKey = keyToSemi(transposeVal);
    chords = transposeChords(originalChords, originalKey, targetKey);
  }
  renderStrip();
  highlightActiveCell();
}

function rebuildFromInputs() {
  const parsed = parseProgressionFromInput();
  if (!parsed) {
    el.literalInput.classList.add('invalid');
    return false;
  }
  el.literalInput.classList.remove('invalid');

  // Save progression back to the section being edited
  if (sections.length > 0) {
    sections[editSectionIdx].progression = el.literalInput.value.trim();
    if (el.sectionsList) renderSectionsList();
  }

  // Store original key and chords
  originalKey = parsed.key;
  originalKeyName = parsed.keyName;
  originalChords = parsed.chords;

  // Apply transposition if a target key is selected
  const transposeVal = el.transposeSelect.value;
  if (transposeVal === '' || originalKey === null) {
    // No transposition
    chords = originalChords.map(ch => ({ ...ch }));
  } else {
    const targetKey = keyToSemi(transposeVal);
    chords = transposeChords(originalChords, originalKey, targetKey);
  }

  renderStrip();
  highlightActiveCell();
  return true;
}

// =========================
// UI actions (top-level)
// =========================
function actionPlay() { // start transport
  if (playing) return;
  ctx.resume();
  playing = true;
  chordIdx = 0;
  barStartChordIdx = 0;
  currentStrumIdx = -1;
  beatsIntoChord = 0;
  barSections = [];
  currentBarSection = 0;
  barStart = ctx.currentTime + 0.05;
  highlightActiveCell();
  scheduleBar(barStart);
  tickRAF();
  el.btnPlay.classList.add('playing');
  el.btnStop.classList.remove('stopped');
  document.body.classList.add('playing');
  updateMuteButton();
}

function actionStop() { // stop transport
  if (!playing) return;
  playing = false;
  currentStrumIdx = -1;
  highlightActiveStrum(-1);

  // Immediately silence all sounds by disconnecting and recreating gain nodes
  chordsGain.disconnect();
  drumsGain.disconnect();
  metroGain.disconnect();
  chordsGain = ctx.createGain(); chordsGain.connect(master);
  drumsGain = ctx.createGain(); drumsGain.connect(master);
  metroGain = ctx.createGain(); metroGain.connect(master);

  el.btnPlay.classList.remove('playing');
  el.btnStop.classList.add('stopped');
  document.body.classList.remove('playing');
  updateMuteButton();
  highlightActiveCell();
  drawCueStrip();
}

function actionToggleDrums() { // toggle drums
  drumsOn = !drumsOn;
  el.btnDrums.classList.toggle('on', drumsOn);
  rescheduleCurrentBar();
}

function actionToggleChords() { // toggle chord playback
  chordsOn = !chordsOn;
  el.btnChords.classList.toggle('on', chordsOn);
  rescheduleCurrentBar();
}


function actionMuteToggle() { // toggle mute
  muted = !muted;
  master.gain.value = muted ? 0 : 1;
  updateMuteButton();

  // Flash the mute button
  el.btnMute.classList.add('flash');
  setTimeout(() => el.btnMute.classList.remove('flash'), 150);
}

function updateMuteButton() {
  el.btnMute.classList.toggle('active', muted);

  // Update icon based on muted state
  el.btnMute.textContent = muted ? 'üîá Muted' : 'üîä Sound';
}

function actionTapSpace() { // handle a tap sample
  const now = performance.now();
  taps.push(now);
  while (taps.length > 6) taps.shift();
  if (taps.length >= 2) {
    const diffs = taps.slice(1).map((t, i) => t - taps[i]);
    const avg = diffs.reduce((a, b) => a + b, 0) / diffs.length;
    const oldBpm = bpm;
    bpm = Math.max(50, Math.min(200, 60000 / avg));

    el.bpmDisplay.value = Math.round(bpm).toString().slice(0, 3);

    if (playing && bpm !== oldBpm) {
      rescheduleAtNewTempo(oldBpm);
    }

    // Flash the tap button
    el.btnTap.classList.add('flash');
    setTimeout(() => el.btnTap.classList.remove('flash'), 150);
  }
}

function actionSetBPM(val) { // text input or keyboard changed
  const oldBpm = bpm;
  bpm = Math.max(30, Math.min(300, parseInt(val, 10) || bpm));
  el.bpmDisplay.value = Math.round(bpm).toString().slice(0, 3);

  if (playing && bpm !== oldBpm) {
    rescheduleAtNewTempo(oldBpm);
  }
}

function rescheduleCurrentBar() {
  if (!playing) return;
  // Cancel all scheduled sounds by recreating gain nodes
  chordsGain.disconnect();
  drumsGain.disconnect();
  metroGain.disconnect();
  chordsGain = ctx.createGain(); chordsGain.connect(master);
  drumsGain = ctx.createGain(); drumsGain.connect(master);
  metroGain = ctx.createGain(); metroGain.connect(master);

  // Schedule remaining portion of current bar from now
  const now = ctx.currentTime;
  const beatDur = 60 / bpm;
  const eighthNote = beatDur / 2;
  const durBar = beatDur * 4;
  const progress = Math.min((now - barStart) / durBar, 0.99);
  const currentEighth = Math.max(0, Math.floor(progress * strumPattern.length));

  // Rebuild barSections ‚Äî may be empty if we were in metronome mode
  buildBarSections();

  if (chordsOn && chords.length) {
    for (let i = currentEighth; i < strumPattern.length; i++) {
      const frac = (i + 0.5) / strumPattern.length;
      let section = barSections[0];
      for (const s of barSections) { if (frac >= s.startFrac) section = s; }
      const ch = chords[section.ci];
      const triad = buildTriad(48 + ch.root, ch.quality);
      const sectionEnd = Math.round(section.endFrac * strumPattern.length) - 1;
      voiceStrumBeat(triad, barStart + i * eighthNote, tieDuration(i, eighthNote, sectionEnd), strumPattern[i]);
    }
  }

  if (drumsOn) {
    for (let b = 0; b < 4; b++) {
      const bt = barStart + b * beatDur;
      if (bt < now) continue;
      if (b === 0 || b === 2) voiceKick(bt);
      if (b === 1 || b === 3) voiceSnare(bt);
      voiceHat(bt);
      voiceHat(bt + beatDur / 2);
    }
  }

  if (!drumsOn && !chordsOn) {
    for (let b = 0; b < 4; b++) {
      const bt = barStart + b * beatDur;
      if (bt < now) continue;
      voiceMetro(bt, b === 0);
    }
  }
}

function rescheduleAtNewTempo(oldBpm) {
  // Adjust barStart to preserve position within the bar at new tempo
  const now = ctx.currentTime;
  const oldDur = (60 / oldBpm) * 4;
  const progress = Math.min((now - barStart) / oldDur % 1, 0.99);
  barStart = now - (progress * (60 / bpm) * 4);
  rescheduleCurrentBar();
}

// =========================
// Section management
// =========================

function loadSectionIntoDisplay(idx) {
  // Snapshot current pattern into the section we're leaving
  if (sections[editSectionIdx]) {
    sections[editSectionIdx].customBeats = strumPattern.map(b => ({...b, strings: {...b.strings}}));
  }
  sectionIdx = idx;
  editSectionIdx = idx;
  const section = sections[idx];
  el.literalInput.value = section.progression;
  rebuildFromInputs();
  if (section.customBeats) {
    strumPattern = section.customBeats.map(b => ({...b, strings: {...b.strings}}));
    el.patternSelect.value = section.patternName;
  } else {
    const patName = PATTERNS[section.patternName] ? section.patternName : 'standard';
    strumPattern = PATTERNS[patName].map(s => ({...s, strings: {...s.strings}}));
    el.patternSelect.value = patName;
  }
  if (simpleStrumView) renderSimpleStrumPattern();
  else renderStrumPattern();
}

function renderRepeatIndicator() {
  if (!el.repeatIndicator || !sections.length) return;
  el.repeatIndicator.innerHTML = '';
  const section = sections[sectionIdx];

  if (section.repeats === Infinity) {
    const inf = document.createElement('div');
    inf.className = 'repeatInfinity';
    inf.textContent = '‚àû';
    inf.title = 'Infinite loop ‚Äî click to set repeat count';
    inf.addEventListener('click', e => {
      e.stopPropagation();
      sections[sectionIdx].repeats = 4;
      sections[sectionIdx].repeatsLeft = 4;
      renderRepeatIndicator();
      renderSectionsList();
    });
    el.repeatIndicator.appendChild(inf);
  } else {
    const total = Math.max(section.repeats, section.repeatsLeft);
    const left = Math.max(0, section.repeatsLeft);
    const dots = document.createElement('div');
    dots.className = 'repeatDots';
    dots.title = `${left} of ${total} repeat(s) remaining ‚Äî click to toggle infinite`;
    for (let i = 0; i < total; i++) {
      const dot = document.createElement('div');
      dot.className = 'repeatDot' + (i < left ? ' filled' : '');
      dots.appendChild(dot);
    }
    dots.addEventListener('click', e => {
      e.stopPropagation();
      sections[sectionIdx].repeats = Infinity;
      sections[sectionIdx].repeatsLeft = Infinity;
      renderRepeatIndicator();
      renderSectionsList();
    });
    el.repeatIndicator.appendChild(dots);
  }
}

function renderSectionsList() {
  if (!el.sectionsList) return;
  el.sectionsList.innerHTML = '';
  sections.forEach((section, i) => {
    const isActive = i === sectionIdx;
    const row = document.createElement('div');
    row.className = 'sectionRow' + (isActive ? ' active' : '');

    // All visible content goes into mainRow
    const mainRow = document.createElement('div');
    mainRow.className = 'sectionMainRow';

    const activeDot = document.createElement('div');
    activeDot.className = 'sectionActiveDot';

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.className = 'sectionNameInput';
    nameInput.value = section.name;
    nameInput.addEventListener('change', e => { sections[i].name = e.target.value; });
    nameInput.addEventListener('click', e => e.stopPropagation());
    nameInput.addEventListener('keydown', e => e.stopPropagation());

    const progEl = document.createElement('span');
    progEl.className = 'sectionProg' + (i === editSectionIdx ? ' linked' : '');
    const normProg = section.progression.replace(/\s+/g, ' ');
    progEl.textContent = normProg;
    progEl.title = normProg;

    // Repeat display
    const repeatArea = document.createElement('div');
    repeatArea.className = 'sectionRepeatArea';
    if (section.repeats === Infinity) {
      const inf = document.createElement('span');
      inf.className = 'sectionInfSymbol';
      inf.textContent = '‚àû';
      repeatArea.appendChild(inf);
    } else {
      const total = section.repeats;
      const left = isActive ? Math.max(0, Math.min(section.repeatsLeft, total)) : total;
      const dotsEl = document.createElement('div');
      dotsEl.className = 'sectionDots';
      const show = Math.min(total, 8);
      for (let j = 0; j < show; j++) {
        const d = document.createElement('div');
        d.className = 'sectionDot' + (j < left ? ' filled' : '');
        dotsEl.appendChild(d);
      }
      if (total > 8) {
        const more = document.createElement('span');
        more.style.cssText = 'font-size:1.5vh;color:#555;';
        more.textContent = `+${total - 8}`;
        dotsEl.appendChild(more);
      }
      repeatArea.appendChild(dotsEl);
    }

    // Controls
    const btnInf = document.createElement('button');
    btnInf.className = 'sectionBtn';
    btnInf.textContent = '‚àû';
    btnInf.title = 'Toggle infinite';
    btnInf.addEventListener('click', e => {
      e.stopPropagation();
      if (sections[i].repeats === Infinity) {
        sections[i].repeats = 4; sections[i].repeatsLeft = 4;
      } else {
        sections[i].repeats = Infinity; sections[i].repeatsLeft = Infinity;
      }
      renderSectionsList();
      if (i === sectionIdx) renderRepeatIndicator();
    });

    const btnMinus = document.createElement('button');
    btnMinus.className = 'sectionBtn';
    btnMinus.textContent = '‚àí';
    btnMinus.title = 'Fewer repeats';
    btnMinus.addEventListener('click', e => {
      e.stopPropagation();
      if (sections[i].repeats !== Infinity && sections[i].repeats > 1) {
        sections[i].repeats--;
        sections[i].repeatsLeft = Math.min(sections[i].repeatsLeft, sections[i].repeats);
      }
      renderSectionsList();
      if (i === sectionIdx) renderRepeatIndicator();
    });

    const btnPlus = document.createElement('button');
    btnPlus.className = 'sectionBtn';
    btnPlus.textContent = '+';
    btnPlus.title = 'More repeats';
    btnPlus.addEventListener('click', e => {
      e.stopPropagation();
      if (sections[i].repeats !== Infinity) sections[i].repeats++;
      renderSectionsList();
      if (i === sectionIdx) renderRepeatIndicator();
    });

    const btnDel = document.createElement('button');
    btnDel.className = 'sectionBtn sectionBtnDel';
    btnDel.textContent = '‚úï';
    btnDel.title = 'Delete section';
    btnDel.addEventListener('click', e => {
      e.stopPropagation();
      if (sections.length > 1) {
        sections.splice(i, 1);
        const newIdx = Math.min(sectionIdx, sections.length - 1);
        loadSectionIntoDisplay(newIdx);
        renderRepeatIndicator();
        renderSectionsList();
      }
    });

    const btnAdd = document.createElement('button');
    btnAdd.className = 'sectionBtn';
    btnAdd.textContent = 'add';
    btnAdd.title = 'Add section after';
    btnAdd.addEventListener('click', e => {
      e.stopPropagation();
      actionAddSectionAfter(i);
    });

    mainRow.append(activeDot, nameInput, progEl, repeatArea, btnInf, btnMinus, btnPlus, btnDel, btnAdd);
    row.appendChild(mainRow);

    row.addEventListener('click', () => {
      if (i !== sectionIdx) {
        loadSectionIntoDisplay(i);
        renderRepeatIndicator();
        renderSectionsList();
      }
    });
    el.sectionsList.appendChild(row);
  });
}

function advanceSection() {
  // Reset outgoing section countdown for next time through
  const curr = sections[sectionIdx];
  curr.repeatsLeft = curr.repeats;
  // Move to next section
  sectionIdx = (sectionIdx + 1) % sections.length;
  const next = sections[sectionIdx];
  next.repeatsLeft = next.repeats;
  // Load chords and pattern for new section.
  // If user is actively editing, don't clobber the editor.
  if (editMode) {
    // Save the pattern being left, then restore the next section's saved pattern
    if (sections[editSectionIdx]) {
      sections[editSectionIdx].customBeats = strumPattern.map(b => ({...b, strings: {...b.strings}}));
    }
    editSectionIdx = sectionIdx;
    applyProgressionStr(next.progression);
    if (next.customBeats) {
      strumPattern = next.customBeats.map(b => ({...b, strings: {...b.strings}}));
      el.patternSelect.value = next.patternName;
    } else {
      const patName = PATTERNS[next.patternName] ? next.patternName : 'standard';
      strumPattern = PATTERNS[patName].map(s => ({...s, strings: {...s.strings}}));
      el.patternSelect.value = patName;
    }
    if (simpleStrumView) renderSimpleStrumPattern(); else renderStrumPattern();
    renderSectionsList();
    renderRepeatIndicator();
  } else {
    loadSectionIntoDisplay(sectionIdx);
    renderRepeatIndicator();
    renderSectionsList();
  }
}

function actionAddSectionAfter(afterIdx) {
  const newSection = makeSection(
    `Section ${sections.length + 1}`,
    el.literalInput.value.trim(),
    4,
    el.patternSelect.value
  );
  sections.splice(afterIdx + 1, 0, newSection);
  loadSectionIntoDisplay(afterIdx + 1);
  renderRepeatIndicator();
  renderSectionsList();
}

function actionAddRepeat() {
  const section = sections[sectionIdx];
  if (section.repeats === Infinity) return;
  section.repeatsLeft++;
  renderRepeatIndicator();
}

// Preset chord progressions with labels
const PROGRESSIONS = [
  { label: "I-V-vi-IV (Don't Stop Believin')", value: 'C: C G Am F' },
  { label: "I-vi-IV-V - 50s (Stand By Me)", value: 'C: C Am F G' },
  { label: "vi-IV-I-V (With or Without You)", value: 'C: Am F C G' },
  { label: "I-IV-V-IV (La Bamba)", value: 'C: C F G F' },
  { label: "Pachelbel's Canon", value: 'C: C G Am Em F C F G' },
  { label: "ii-V-I Jazz (Sunday Morning)", value: 'C: Dm G C C' },
  { label: "I-IV-vi-V (What Makes You Beautiful)", value: 'C: C F Am G' },
  { label: "12-Bar Blues", value: 'C: C C C C F F C C G F C G' },
  { label: "House of the Rising Sun", value: 'Am: Am C D F Am E Am E' },
  { label: "Sweet Home Alabama", value: 'G: D C G G' },
  { label: "Knockin' on Heaven's Door", value: 'G: G D Am Am G D C C' },
  { label: "Country Roads", value: 'G: G Em C G G Em D D' },
  { label: "Wagon Wheel", value: 'G: G D Em C G D C C' },
  { label: "Ring of Fire", value: 'G: G C G G G D G G' },
  { label: "Hallelujah", value: 'C: C Am C Am F G C G' },
  { label: "Let It Be", value: 'C: C G Am F C G F C' },
  { label: "Someone Like You (Adele)", value: 'A: A E F#m D' },
  { label: "Rolling in the Deep", value: 'Am: Am G F G' },
  { label: "Creep (Radiohead)", value: 'G: G B C Cm' },
];

function actionRandom() { // pick a random progression
  const prog = PROGRESSIONS[Math.floor(Math.random() * PROGRESSIONS.length)];
  el.literalInput.value = prog.value;
  el.progressionSelect.value = '';  // Reset dropdown to show it's been randomized
  rebuildFromInputs();
}

function actionProgressionChange(value) {
  if (!value) return;  // Ignore empty selection
  el.literalInput.value = value;
  rebuildFromInputs();
}

function actionPatternChange(patternName) {
  if (PATTERNS[patternName]) {
    strumPattern = PATTERNS[patternName].map(s => ({...s, strings: {...s.strings}}));
    if (sections.length > 0) {
      sections[sectionIdx].patternName = patternName;
      sections[sectionIdx].customBeats = null; // preset selection replaces any custom edits
    }
    if (simpleStrumView) renderSimpleStrumPattern();
    else renderStrumPattern();
  }
}

function actionEnterEditMode() { // focus progression input, disable global shortcuts
  editMode = true;
  tapMode = false;
  el.btnTap.classList.remove('on');
  el.literalInput.classList.add('editing');
  document.body.classList.add('chord-editing');
  el.literalInput.focus();
  el.literalInput.selectionStart = el.literalInput.value.length;
  el.literalInput.selectionEnd = el.literalInput.value.length;
}

function actionExitEditMode() { // validate, update strip, stay if invalid
  const ok = rebuildFromInputs();
  if (!ok) return; // remain in edit mode until fixed
  editMode = false;
  el.literalInput.classList.remove('editing');
  document.body.classList.remove('chord-editing');
  el.literalInput.blur();
}

function actionKeyDown(e) { // global keyboard shortcuts
  // If editing, only Enter exits; allow all other keys (incl. space) to type
  if (editMode) {
    if (e.code === 'Enter') { e.preventDefault(); actionExitEditMode(); }
    return;
  }

  // Space toggles play/stop
  if (e.code === 'Space') {
    e.preventDefault();
    if (playing) actionStop(); else actionPlay();
    return;
  }

  // Drums toggle (D)
  if (e.code === 'KeyD') { actionToggleDrums(); return; }

  // Chords toggle (C) ‚Äî skip if meta/ctrl pressed
  if (e.code === 'KeyC' && !e.metaKey && !e.ctrlKey) { actionToggleChords(); return; }

  // Random (R) ‚Äî avoid Cmd/Ctrl+R
  if (e.code === 'KeyR' && !e.metaKey && !e.ctrlKey) { e.preventDefault(); actionRandom(); return; }

  // Again (A) ‚Äî avoid Cmd/Ctrl+A
  if (e.code === 'KeyA' && !e.metaKey && !e.ctrlKey) { e.preventDefault(); actionAddRepeat(); return; }

  // Edit mode (E)
  if (e.code === 'KeyE') { e.preventDefault(); actionEnterEditMode(); return; }

  // Tap tempo (T)
  if (e.code === 'KeyT') { e.preventDefault(); actionTapSpace(); return; }

  // Mute toggle (M)
  if (e.code === 'KeyM') { e.preventDefault(); actionMuteToggle(); return; }

  // BPM +/- keys
  if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
    // Round up to nearest 5, then subtract 5
    const rounded = Math.ceil(bpm / 5) * 5;
    const newBpm = rounded - 5;
    actionSetBPM(newBpm >= 30 ? newBpm : 30);
    return;
  }
  if (e.code === 'Equal' || e.code === 'NumpadAdd') {
    // Round down to nearest 5, then add 5
    const rounded = Math.floor(bpm / 5) * 5;
    const newBpm = rounded + 5;
    actionSetBPM(newBpm <= 300 ? newBpm : 300);
  }
}

// =========================
// Cue Strip (scrolling event display)
// =========================

function chordDisplayName(ci) {
  if (!chords.length) return '';
  const ch = chords[((ci % chords.length) + chords.length) % chords.length];
  const useFlats = shouldUseFlats();
  return displayNameForSemi(ch.root, useFlats) + (ch.quality === 'm' ? 'm' : '');
}

// Generate upcoming cue events between windowStart and windowEnd (audio context times)
function generateCueEvents(windowStart, windowEnd) {
  if (!chords.length) return [];
  const beatDur = 60 / bpm;
  const eighthNote = beatDur / 2;
  const barDur = beatDur * 4;
  const events = [];

  // Compute bar sections given a starting state and bar start time
  function computeSections(ci0, bic0, barT) {
    const n8pc = beatsPerChord * 2;
    const total8 = strumPattern.length;
    const sects = [];
    let e = 0, cpos = bic0 * 2, adv = 0;
    while (e < total8) {
      const count = Math.min(n8pc - cpos, total8 - e);
      sects.push({ ci: (ci0 + adv) % chords.length, t: barT + e * eighthNote, startE: e, endE: e + count, barT });
      e += count; cpos = 0; adv++;
    }
    return sects;
  }

  // Compute chord state at start of next bar
  function nextSt(ci, bic) {
    const n8pc = beatsPerChord * 2;
    let pos = bic * 2, rem = strumPattern.length, adv = 0;
    while (rem > 0) {
      const left = n8pc - pos;
      if (rem >= left) { rem -= left; pos = 0; adv++; }
      else { pos += rem; rem = 0; }
    }
    return { ci: (ci + adv) % chords.length, bic: pos / 2 };
  }

  // Build sections for current + future bars covering the window
  let ci = barStartChordIdx, bic = beatsIntoChord, bt = barStart;
  const allSections = [];
  for (let bar = 0; bar < 4; bar++) {
    if (bt > windowEnd) break;
    computeSections(ci, bic, bt).forEach(s => allSections.push(s));
    const ns = nextSt(ci, bic);
    ci = ns.ci; bic = ns.bic; bt += barDur;
  }

  // Start prevCi from end chord of previous bar
  let prevCi = prevBarEndChordCi;

  for (const sect of allSections) {
    // Chord change event: only when chord actually changes
    if (sect.ci !== prevCi && sect.t >= windowStart && sect.t <= windowEnd) {
      events.push({ t: sect.t, kind: 'chord', name: chordDisplayName(sect.ci) });
    }
    prevCi = sect.ci;

    // Strum events within the window (skip rests only)
    for (let i = sect.startE; i < sect.endE; i++) {
      const t = sect.barT + i * eighthNote;
      if (t < windowStart || t > windowEnd) continue;
      const beat = strumPattern[i];
      const state = getSimpleState(beat);
      if (state === 'rest') continue;
      events.push({ t, kind: 'strum', state });
    }
  }
  return events;
}

function roundRect2d(ctx2d, x, y, w, h, r) {
  r = Math.min(r, w / 2, h / 2);
  ctx2d.beginPath();
  ctx2d.moveTo(x + r, y);
  ctx2d.lineTo(x + w - r, y);
  ctx2d.arcTo(x + w, y, x + w, y + r, r);
  ctx2d.lineTo(x + w, y + h - r);
  ctx2d.arcTo(x + w, y + h, x + w - r, y + h, r);
  ctx2d.lineTo(x + r, y + h);
  ctx2d.arcTo(x, y + h, x, y + h - r, r);
  ctx2d.lineTo(x, y + r);
  ctx2d.arcTo(x, y, x + r, y, r);
  ctx2d.closePath();
}

function resizeCueStrip() {
  const canvas = el.cueStrip;
  if (!canvas) return;
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
}

function drawCueStrip() {
  const canvas = el.cueStrip;
  if (!canvas) return;
  if (canvas.width === 0 || canvas.height === 0) { resizeCueStrip(); if (canvas.width === 0) return; }

  const dpr = window.devicePixelRatio || 1;
  const Wl = canvas.width / dpr;  // logical width
  const Hl = canvas.height / dpr; // logical height

  const ctx2d = canvas.getContext('2d');
  ctx2d.save();
  ctx2d.scale(dpr, dpr);

  // Background
  ctx2d.fillStyle = '#f4f4f8';
  ctx2d.fillRect(0, 0, Wl, Hl);

  const nowX = Wl * 0.25; // "now" marker position

  const now = cueNow;
  const beatDur = 60 / bpm;
  const barDur = beatDur * 4;

  // Scale: right edge (x=Wl) = now + 8 beats
  const scale = (Wl - nowX) / (8 * beatDur);
  const timeToX = t => nowX + (t - now) * scale;
  const windowStart = now - nowX / scale;
  const windowEnd   = now + (Wl - nowX) / scale; // = now + 8*beatDur

  // Dim the past region
  ctx2d.fillStyle = 'rgba(0,0,0,0.04)';
  ctx2d.fillRect(0, 0, nowX, Hl);

  // Beat tick marks along the bottom
  const barT0 = barStart + Math.floor((windowStart - barStart) / barDur) * barDur;
  for (let bt = barT0; bt <= windowEnd + barDur; bt += barDur) {
    for (let b = 0; b < 4; b++) {
      for (let half = 0; half < 2; half++) {
        const t = bt + b * beatDur + half * (beatDur / 2);
        const x = timeToX(t);
        if (x < 0 || x > Wl) continue;
        const isBar = (b === 0 && half === 0);
        const isBeat = (half === 0);
        const tickH = isBar ? Hl * 0.35 : isBeat ? Hl * 0.2 : Hl * 0.12;
        ctx2d.strokeStyle = isBar ? 'rgba(131,137,255,0.3)' : isBeat ? 'rgba(0,0,0,0.14)' : 'rgba(0,0,0,0.07)';
        ctx2d.lineWidth = isBar ? 1.5 : 1;
        ctx2d.beginPath();
        ctx2d.moveTo(x, Hl - tickH);
        ctx2d.lineTo(x, Hl);
        ctx2d.stroke();
      }
    }
  }

  // Generate events
  const events = generateCueEvents(windowStart - 0.3, windowEnd + 0.3);

  const beatWidth = beatDur * scale; // 1 beat wide in logical pixels
  const chordFontSize = Math.round(Hl * 0.82);
  const strumFontSize = Math.round(Hl * 0.52);
  const chordCy = Hl * 0.5;  // vertically centered
  const strumCy  = Hl * 0.5;

  // Strum icon lookup: state -> { icon, fill, strokeW }
  // strokeW=1 adds a thin same-color stroke before fill, slightly fattening the glyph.
  const strumStyle = {
    down: { icon: '‚Üì', fill: '#0044aa', strokeW: 1 },
    up:   { icon: '‚Üë', fill: '#cc5500', strokeW: 1 },
    x:    { icon: '‚úï', fill: '#cc0000', strokeW: 1 },
    tie:  { icon: '‚åí', fill: '#888888', strokeW: 0 },
  };

  ctx2d.globalAlpha = 1.0;

  // Draw chord change labels as full-height rectangles, 1 beat wide
  ctx2d.textAlign = 'center';
  ctx2d.textBaseline = 'middle';
  for (const ev of events) {
    if (ev.kind !== 'chord') continue;
    const x = timeToX(ev.t);
    if (x + beatWidth < -10 || x > Wl + 10) continue;
    const alpha = x < nowX ? 0.45 : 1.0;
    const name = ev.name;
    // Scale font down if text would overflow the beat width
    ctx2d.font = `bold ${chordFontSize}px monospace`;
    const tw = ctx2d.measureText(name).width;
    const maxTw = beatWidth * 0.88;
    const useFontSize = tw > maxTw ? Math.floor(chordFontSize * maxTw / tw) : chordFontSize;
    ctx2d.font = `bold ${useFontSize}px monospace`;
    // Full-height rectangle, left edge on the beat
    ctx2d.globalAlpha = alpha;
    ctx2d.fillStyle = '#8389ff';
    ctx2d.fillRect(x, 0, beatWidth, Hl);
    // Label text, left-justified with small padding
    ctx2d.textAlign = 'left';
    ctx2d.fillStyle = '#fff';
    ctx2d.fillText(name, x + Math.round(Hl * 0.06), chordCy);
    ctx2d.globalAlpha = 1.0;
  }

  // Draw strum arrows first (chord rects will overlay them at chord-change moments)
  ctx2d.font = `bold ${strumFontSize}px sans-serif`;
  ctx2d.textAlign = 'center';
  ctx2d.textBaseline = 'middle';
  ctx2d.lineWidth = 1.5;
  for (const ev of events) {
    if (ev.kind !== 'strum') continue;
    const x = timeToX(ev.t);
    if (x < -30 || x > Wl + 30) continue;
    const st = strumStyle[ev.state];
    if (!st) continue;
    ctx2d.globalAlpha = x < nowX ? 0.35 : 1.0;
    ctx2d.fillStyle = st.fill;
    if (st.strokeW) {
      ctx2d.strokeStyle = st.fill;
      ctx2d.strokeText(st.icon, x, strumCy);
    }
    ctx2d.fillText(st.icon, x, strumCy);
  }

  // "Now" playhead line
  ctx2d.strokeStyle = 'rgba(131,137,255,0.75)';
  ctx2d.lineWidth = 2;
  ctx2d.beginPath();
  ctx2d.moveTo(nowX, 0);
  ctx2d.lineTo(nowX, Hl);
  ctx2d.stroke();

  // Playhead triangle at top
  const triW = Hl * 0.17;
  ctx2d.fillStyle = 'rgba(131,137,255,0.9)';
  ctx2d.beginPath();
  ctx2d.moveTo(nowX, Hl * 0.18);
  ctx2d.lineTo(nowX - triW, 0);
  ctx2d.lineTo(nowX + triW, 0);
  ctx2d.closePath();
  ctx2d.fill();

  ctx2d.restore();
}

// =========================
// Wiring (once)
// =========================
function init() {
  // Cache DOM
  el.btnPlay    = document.getElementById('btnPlay');
  el.btnStop    = document.getElementById('btnStop');
  el.btnMute    = document.getElementById('btnMute');
  el.btnTap     = document.getElementById('btnTap');
  el.btnDrums   = document.getElementById('btnDrums');
  el.btnChords  = document.getElementById('btnChords');
  el.btnRandom  = document.getElementById('btnRandom');
  el.strip      = document.getElementById('strip');
  el.transposeSelect = document.getElementById('transposeSelect');
  el.progressionSelect = document.getElementById('progressionSelect');
  el.literalInput = document.getElementById('literalInput');
  el.bpmDisplay = document.getElementById('bpmDisplay');
  el.strumContainer = document.getElementById('strumContainer');
  el.dynamicsContainer = document.getElementById('dynamicsContainer');
  el.patternSelect = document.getElementById('patternSelect');
  el.rhythmLabel = document.getElementById('rhythmLabel');
  el.simpleStrumContainer = document.getElementById('simpleStrumContainer');
  el.btnAgain = document.getElementById('btnAgain');
  el.sectionsList = document.getElementById('sectionsList');
  el.repeatIndicator = null; // set by renderStrip()
  el.cueStrip = document.getElementById('cueStrip');

  // Initialize sections from current input
  sections = [ makeSection('Section 1', el.literalInput.value.trim(), Infinity, el.patternSelect.value) ];
  sectionIdx = 0;
  editSectionIdx = 0;

  // Populate transpose dropdown
  // First option is empty (no transposition) - this is the default
  const noTranspose = document.createElement('option');
  noTranspose.value = '';
  noTranspose.textContent = '(none)';
  el.transposeSelect.appendChild(noTranspose);

  KEYS.forEach(k => {
    const o = document.createElement('option');
    o.value = k;
    o.textContent = k;
    el.transposeSelect.appendChild(o);
  });
  el.transposeSelect.value = '';

  // Populate progression dropdown
  const defaultProg = document.createElement('option');
  defaultProg.value = '';
  defaultProg.textContent = '(select progression)';
  el.progressionSelect.appendChild(defaultProg);

  PROGRESSIONS.forEach(prog => {
    const o = document.createElement('option');
    o.value = prog.value;
    o.textContent = prog.label;
    el.progressionSelect.appendChild(o);
  });
  el.progressionSelect.value = '';

  // One-time event wiring to top-level actions
  el.btnPlay.addEventListener('click', actionPlay);
  el.btnStop.addEventListener('click', actionStop);
  el.btnMute.addEventListener('click', actionMuteToggle);
  el.btnTap.addEventListener('click', actionTapSpace);
  el.btnDrums.addEventListener('click', actionToggleDrums);
  el.btnChords.addEventListener('click', actionToggleChords);
  el.btnRandom.addEventListener('click', actionRandom);

el.bpmDisplay.addEventListener('input', e => {
    // Filter to only allow digits
    e.target.value = e.target.value.replace(/[^0-9]/g, '').slice(0, 3);
  });
  el.bpmDisplay.addEventListener('change', e => {
    const val = parseInt(e.target.value, 10);
    if (val >= 30 && val <= 300) {
      actionSetBPM(val);
    } else {
      // Reset to current BPM if invalid
      e.target.value = Math.round(bpm).toString();
    }
  });
  el.transposeSelect.addEventListener('change', rebuildFromInputs);
  el.progressionSelect.addEventListener('change', e => actionProgressionChange(e.target.value));
  el.literalInput.addEventListener('focus', () => { if (!editMode) actionEnterEditMode(); });
  el.literalInput.addEventListener('blur', () => { if (editMode) actionExitEditMode(); });
  el.literalInput.addEventListener('change', rebuildFromInputs);
  el.patternSelect.addEventListener('change', e => actionPatternChange(e.target.value));
  document.querySelectorAll('input[name="bpc"]').forEach(r => {
    r.addEventListener('change', e => {
      beatsPerChord = parseInt(e.target.value);
      beatsIntoChord = 0; // reset phase on change
    });
  });
  el.rhythmLabel.addEventListener('click', actionToggleSimpleView);
  el.btnAgain.addEventListener('click', actionAddRepeat);

  document.body.addEventListener('keydown', actionKeyDown);

  // Re-render motion overlay and zoom connector on resize
  window.addEventListener('resize', () => {
    renderMotionOverlay();
    renderZoomConnector(chordIdx);
    resizeCueStrip();
    drawCueStrip();
  });

  // Initial build
  rebuildFromInputs();
  renderSimpleStrumPattern();
  renderSectionsList();
  renderZoomConnector(chordIdx);
  resizeCueStrip();
  drawCueStrip();
  el.btnPlay.focus();
}

// Boot
init();
</script>

<div style="height: 100vh;"></div>
<div id="helpSection" style="padding: 1vh 2vw;">
<h3>Key bindings:</h3>
<ul>
  <li>
    SPACE: play or stop
  </li>
  <li>
    D: toggle drums on/off
  </li>
  <li>
    C: toggle chords on/off
  </li>
  <li>
    R: pick random chord progression
  </li>
  <li>
    E: enter edit mode for chord progression
  </li>
  <li>
    A: repeat progression again
  </li>
  <li>
    T: tap to tempo
  </li>
  <li>
    M: mute
  </li>
  <li>
    -: decrease tempo
  </li>
  <li>
    +: increase tempo
  </li>
  </ul>

Tips:
<ul>
  <li>
    Turning off both drums and chords results in a metronome.
  </li>
  <li>
    Repeatedly click <b>Tap</b> or press the T key to set the tempo. The BPM is displayed next to the Tap button. You can also drag the tempo slider or use the plus (+) and (-) keys.
  </li>
  <li>
    Select a chord progression from the <b>Progression</b> dropdown, or click <b>Random</b> for a surprise.
  </li>
  <li>
    <b>Key and Transposition:</b>
    <ul>
      <li>Specify a key at the start of the progression: <code>C: C Am F G</code></li>
      <li>Roman numerals are shown when a key is specified</li>
      <li>Use the <b>Transpose</b> dropdown to transpose to a different key</li>
    </ul>
  </li>
  <li>
    <b>Strum Pattern Editing:</b>
    <ul>
      <li>Click the <b>direction arrow</b> (‚Üì/‚Üë) at the top of each beat to toggle down/up</li>
      <li>Click the <b>string arrows</b> to toggle individual strings on/off (turn all off for a rest)</li>
      <li>Click <b>M</b> in the corner to toggle muted (percussive) strumming</li>
      <li>Click the <b>dynamics bar</b> below to cycle soft/medium/loud</li>
    </ul>
  </li>
  </ul>


Errata:
<ul>
  </ul>
</div>

</body>
</html>
