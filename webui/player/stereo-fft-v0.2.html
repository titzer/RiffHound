<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Stereo Spectrogram (Async, Log-Freq)</title>
<style>
  /* Intentionally minimal / old-school */
  body { font-family: serif; margin: 10px; }
  canvas { width: 100%; border: 1px solid #999; display: block; }
  #overview { height: 25px; }
  #zoom { height: 66vh; }
  .row { margin: 6px 0; }
  button { margin-right: 4px; }
  small { color: #444; }
  label { margin-right: 10px; }
</style>
</head>
<body>
  <h2>Stereo Spectrogram</h2>

  <div class="row">
    <label>Load audio:
      <input id="file" type="file" accept="audio/*">
    </label>

    <button id="play" disabled>Play</button>
    <button id="pause" disabled>Pause</button>
    <button id="stop" disabled>Stop</button>
    <button id="back5" disabled>&lt;&lt; -5s</button>
    <button id="fwd5" disabled>+5s &gt;&gt;</button>

    <small>(Space toggles Play/Stop)</small>
  </div>

  <div class="row">
    <label>Left color:
      <input id="leftColor" type="color" value="#2a6bff">
    </label>
    <label>Right color:
      <input id="rightColor" type="color" value="#ff2a2a">
    </label>

    <label>Gain:
      <input id="gain" type="range" min="0.2" max="3.0" step="0.05" value="1.0">
      <span id="gainVal">1.00×</span>
    </label>

    <span id="status"><small>Load an audio file…</small></span>
  </div>

  <div class="row">
    <canvas id="overview"></canvas>
  </div>

  <div class="row">
    <button id="panLeft" disabled>&lt; -1s</button>
    <button id="follow" disabled>Follow</button>
    <button id="panRight" disabled>+1s &gt;</button>
    <small id="viewInfo"></small>
  </div>

  <div class="row">
    <canvas id="zoom"></canvas>
  </div>

  <audio id="audio" style="display:none;" crossorigin="anonymous"></audio>

<script>
(() => {
  // ------------------------------
  // Config (adjust if you want)
  // ------------------------------
  const FFT_SIZE = 2048;
  const HOP_SIZE = 256;

  // Raw magnitude -> dBFS clamp range, then mapped to 0..255.
  const DB_FLOOR = -110;
  const DB_CEIL  = -10;

  // Log-frequency axis
  const FREQ_MIN_HZ = 20; // lower bound for log mapping

  // Time column budget: how many time-columns we store for the whole file.
  // This prevents huge memory use for long files while still looking good.
  // Higher = sharper in time (zoom smoother). 4000–12000 is usually fine.
  const MAX_COLUMNS = 8000;

  // ------------------------------
  // DOM
  // ------------------------------
  const elFile = document.getElementById('file');
  const elAudio = document.getElementById('audio');

  const btnPlay = document.getElementById('play');
  const btnPause = document.getElementById('pause');
  const btnStop = document.getElementById('stop');
  const btnBack5 = document.getElementById('back5');
  const btnFwd5 = document.getElementById('fwd5');

  const btnPanL = document.getElementById('panLeft');
  const btnPanR = document.getElementById('panRight');
  const btnFollow = document.getElementById('follow');

  const elLeftColor = document.getElementById('leftColor');
  const elRightColor = document.getElementById('rightColor');
  const elGain = document.getElementById('gain');
  const elGainVal = document.getElementById('gainVal');

  const elStatus = document.getElementById('status');
  const elViewInfo = document.getElementById('viewInfo');

  const cvOverview = document.getElementById('overview');
  const cvZoom = document.getElementById('zoom');
  const ctxO = cvOverview.getContext('2d', { alpha: false });
  const ctxZ = cvZoom.getContext('2d', { alpha: false });

  // ------------------------------
  // Helpers
  // ------------------------------
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

  function parseHexColor(hex) {
    const m = /^#?([0-9a-f]{6})$/i.exec(hex);
    if (!m) return [42,107,255];
    const n = parseInt(m[1], 16);
    return [(n>>16)&255, (n>>8)&255, n&255];
  }

  function fmtTime(t) {
    if (!isFinite(t)) return "0:00";
    t = Math.max(0, t);
    const s = Math.floor(t);
    const mm = Math.floor(s / 60);
    const ss = String(s % 60).padStart(2, '0');
    return `${mm}:${ss}`;
  }

  function setEnabled(on) {
    for (const b of [btnPlay, btnPause, btnStop, btnBack5, btnFwd5, btnPanL, btnPanR, btnFollow]) {
      b.disabled = !on;
    }
  }

  function resizeCanvasToCSSPixels(canvas) {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const r = canvas.getBoundingClientRect();
    const w = Math.max(2, Math.floor(r.width * dpr));
    const h = Math.max(2, Math.floor(r.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      return true;
    }
    return false;
  }

  function zoomWindowSeconds() {
    // 2..5 seconds, based on CSS width
    const w = cvZoom.getBoundingClientRect().width;
    return clamp(w / 260, 2, 5);
  }

  // ------------------------------
  // State
  // ------------------------------
  let objectUrl = null;
  let duration = 0;

  let worker = null;

  // Spectrogram storage:
  // We store per-column, per-bin intensities for left and right: [L,R,L,R,...] as Uint8
  // columns * bins * 2 bytes.
  //
  // Also track which columns are computed.
  let spec = null; // { sampleRate, nyquist, nBins, nCols, colDt, dataLR, computedCols, observedMax }

  // Pan/follow for zoom view
  let panMode = false;
  let panOffsetSec = 0;

  // RAF loop
  let raf = 0;

  // ------------------------------
  // Worker (FFT + dB mapping, async)
  // ------------------------------
  function makeWorker() {
    const src = `
      let FFT_SIZE = 2048;
      let HOP_SIZE = 256;
      let DB_FLOOR = -110;
      let DB_CEIL  = -10;

      function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

      function hannWindow(n) {
        const w = new Float32Array(n);
        for (let i=0;i<n;i++) w[i] = 0.5 * (1 - Math.cos(2*Math.PI*i/(n-1)));
        return w;
      }

      // In-place radix-2 FFT on complex arrays
      function fft(re, im) {
        const n = re.length;
        for (let i=1, j=0; i<n; i++) {
          let bit = n >> 1;
          for (; j & bit; bit >>= 1) j ^= bit;
          j ^= bit;
          if (i < j) {
            [re[i], re[j]] = [re[j], re[i]];
            [im[i], im[j]] = [im[j], im[i]];
          }
        }
        for (let len=2; len<=n; len<<=1) {
          const ang = -2 * Math.PI / len;
          const wlenRe = Math.cos(ang);
          const wlenIm = Math.sin(ang);
          for (let i=0; i<n; i+=len) {
            let wRe = 1, wIm = 0;
            for (let j=0; j<len/2; j++) {
              const uRe = re[i+j], uIm = im[i+j];
              const vRe = re[i+j+len/2]*wRe - im[i+j+len/2]*wIm;
              const vIm = re[i+j+len/2]*wIm + im[i+j+len/2]*wRe;
              re[i+j] = uRe + vRe;
              im[i+j] = uIm + vIm;
              re[i+j+len/2] = uRe - vRe;
              im[i+j+len/2] = uIm - vIm;
              const nextRe = wRe*wlenRe - wIm*wlenIm;
              const nextIm = wRe*wlenIm + wIm*wlenRe;
              wRe = nextRe; wIm = nextIm;
            }
          }
        }
      }

      function fillFrame(chan, start, win, re, im) {
        const n = re.length;
        for (let i=0;i<n;i++) {
          re[i] = (chan[start+i] || 0) * win[i];
          im[i] = 0;
        }
      }

      function magToU8(mag) {
        // magnitude to dBFS-ish then map to [0..255]
        const db = 20*Math.log10(mag + 1e-12);
        let t = (db - DB_FLOOR) / (DB_CEIL - DB_FLOOR);
        t = clamp(t, 0, 1);
        return (t * 255 + 0.5) | 0;
      }

      onmessage = async (e) => {
        const msg = e.data;
        if (msg.type !== 'init') return;

        FFT_SIZE = msg.fftSize;
        HOP_SIZE = msg.hopSize;
        DB_FLOOR = msg.dbFloor;
        DB_CEIL  = msg.dbCeil;

        const left = msg.left;
        const right = msg.right;
        const sampleRate = msg.sampleRate;

        const nBins = (FFT_SIZE/2)|0;
        const nFrames = Math.max(0, Math.floor((left.length - FFT_SIZE) / HOP_SIZE) + 1);

        const nCols = msg.nCols;
        const framesPerCol = nFrames / nCols;

        postMessage({ type:'meta', nBins, nFrames, nCols, frameDt: HOP_SIZE / sampleRate });

        const win = hannWindow(FFT_SIZE);
        const reL = new Float32Array(FFT_SIZE), imL = new Float32Array(FFT_SIZE);
        const reR = new Float32Array(FFT_SIZE), imR = new Float32Array(FFT_SIZE);

        let observedMax = 1; // max intensity seen (1..255)
        let currentCol = 0;

        // Column accumulators store max intensity per bin (u8) for L and R
        let colMax = new Uint8Array(nBins * 2); // [L,R,L,R,...]

        function flushCol(colIndex, colData) {
          // Transfer a copy of colData (because we reuse colMax)
          const out = new Uint8Array(colData.length);
          out.set(colData);
          postMessage({ type:'col', col: colIndex, data: out, observedMax }, [out.buffer]);
        }

        for (let f=0; f<nFrames; f++) {
          const col = Math.min(nCols - 1, Math.floor(f / framesPerCol));

          if (col !== currentCol) {
            flushCol(currentCol, colMax);
            colMax.fill(0);
            currentCol = col;
          }

          const start = f * HOP_SIZE;

          fillFrame(left, start, win, reL, imL);
          fillFrame(right, start, win, reR, imR);

          fft(reL, imL);
          fft(reR, imR);

          // bins
          for (let b=0; b<nBins; b++) {
            const ml = Math.hypot(reL[b], imL[b]) / FFT_SIZE;
            const mr = Math.hypot(reR[b], imR[b]) / FFT_SIZE;

            const uL = magToU8(ml);
            const uR = magToU8(mr);

            const i = b*2;
            if (uL > colMax[i]) colMax[i] = uL;
            if (uR > colMax[i+1]) colMax[i+1] = uR;

            if (uL > observedMax) observedMax = uL;
            if (uR > observedMax) observedMax = uR;
          }

          // yield sometimes so UI remains responsive
          if ((f & 63) === 63) await new Promise(r => setTimeout(r, 0));
        }

        // flush last
        flushCol(currentCol, colMax);
        postMessage({ type:'done', observedMax });
      };
    `;
    const blob = new Blob([src], { type: 'application/javascript' });
    return new Worker(URL.createObjectURL(blob));
  }

  // ------------------------------
  // Load and compute
  // ------------------------------
  async function loadFile(file) {
    if (objectUrl) URL.revokeObjectURL(objectUrl);
    objectUrl = URL.createObjectURL(file);
    elAudio.src = objectUrl;

    setEnabled(true);
    panMode = false;
    panOffsetSec = 0;

    elStatus.innerHTML = "<small>Loading metadata…</small>";
    await new Promise((resolve) => {
      elAudio.onloadedmetadata = () => resolve();
      elAudio.onerror = () => resolve();
    });

    duration = elAudio.duration || 0;
    if (!isFinite(duration) || duration <= 0) {
      elStatus.innerHTML = "<small>Could not read duration (unsupported format?).</small>";
      return;
    }

    // Start draw loop
    if (!raf) tick();

    elStatus.innerHTML = "<small>Ready to play. Decoding for spectrogram…</small>";

    // Decode (async) for FFT
    const arrayBuf = await file.arrayBuffer();
    const ac = new (window.AudioContext || window.webkitAudioContext)();
    let audioBuf;
    try {
      audioBuf = await ac.decodeAudioData(arrayBuf.slice(0));
    } catch (e) {
      elStatus.innerHTML = "<small>Decode failed (browser can't decode this audio).</small>";
      try { await ac.close(); } catch {}
      return;
    }
    try { await ac.close(); } catch {}

    const sr = audioBuf.sampleRate;
    const ch0 = audioBuf.getChannelData(0);
    const ch1 = audioBuf.numberOfChannels > 1 ? audioBuf.getChannelData(1) : ch0;

    // Choose number of stored columns (cap memory)
    // Base this on duration: roughly ~ 200 columns per second up to MAX_COLUMNS.
    // (Also keep some minimum so very short clips still have detail.)
    const cols = clamp(Math.floor(duration * 200), 1200, MAX_COLUMNS);

    const nBins = (FFT_SIZE/2)|0;
    spec = {
      sampleRate: sr,
      nyquist: sr / 2,
      nBins,
      nCols: cols,
      colDt: duration / cols,
      dataLR: new Uint8Array(cols * nBins * 2),
      computedCols: new Uint8Array(cols),
      observedMax: 1
    };

    // Reset buffer to zero (meaning "black") but uncomputed is shown as gray separately
    spec.dataLR.fill(0);
    spec.computedCols.fill(0);

    if (worker) worker.terminate();
    worker = makeWorker();

    worker.onmessage = (e) => {
      const msg = e.data;
      if (!spec) return;

      if (msg.type === 'meta') {
        // If needed, reconcile counts (kept simple here)
      } else if (msg.type === 'col') {
        const col = msg.col;
        const colData = new Uint8Array(msg.data);
        spec.observedMax = Math.max(spec.observedMax, msg.observedMax || 1);

        // Copy into main buffer
        const stride = spec.nBins * 2;
        const off = col * stride;
        spec.dataLR.set(colData, off);
        spec.computedCols[col] = 1;

        // progress estimate
        if ((col % 25) === 0) {
          let done = 0;
          const step = Math.max(1, (spec.nCols / 200) | 0);
          for (let i=0;i<spec.nCols;i+=step) done += spec.computedCols[i];
          const pct = Math.floor((done / Math.ceil(spec.nCols/step)) * 100);
          elStatus.innerHTML = `<small>Ready to play. Computing spectrogram… (${pct}%)</small>`;
        }
      } else if (msg.type === 'done') {
        spec.observedMax = Math.max(spec.observedMax, msg.observedMax || 1);
        elStatus.innerHTML = "<small>Ready. Spectrogram computed.</small>";
      }
    };

    worker.postMessage({
      type: 'init',
      fftSize: FFT_SIZE,
      hopSize: HOP_SIZE,
      dbFloor: DB_FLOOR,
      dbCeil: DB_CEIL,
      sampleRate: sr,
      left: ch0,
      right: ch1,
      nCols: cols
    });

    btnFollow.disabled = false;

    // Ensure canvases are sized before drawing
    resizeAll();
    drawAll();
  }

  // ------------------------------
  // Rendering (log-frequency, recolor/rescale without recompute)
  // ------------------------------
  function colIndexForTime(t) {
    if (!spec) return 0;
    return clamp(Math.floor((t / duration) * spec.nCols), 0, spec.nCols - 1);
  }

  function timeForCol(c) {
    if (!spec) return 0;
    return (c / spec.nCols) * duration;
  }

  function binForY(y, h) {
    // log-frequency mapping: y=0 top is high freq, y=h bottom is low freq
    if (!spec) return 0;
    const nyq = spec.nyquist;
    const fMin = Math.min(FREQ_MIN_HZ, nyq);
    const fMax = nyq;

    // normalized in [0,1], with 0 at bottom (low), 1 at top (high)
    const u = 1 - (y / Math.max(1, h - 1));
    // exponential interpolation: f = fMin * (fMax/fMin)^u
    const ratio = fMax / Math.max(1e-6, fMin);
    const f = fMin * Math.pow(ratio, u);
    const b = Math.floor((f / nyq) * (spec.nBins - 1));
    return clamp(b, 0, spec.nBins - 1);
  }

  function drawPlaceholder(ctx, w, h, label) {
    ctx.fillStyle = "#e0e0e0";
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = "#333";
    ctx.font = Math.max(12, Math.floor(h*0.35)) + "px serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, w/2, h/2);
  }

  function drawSpectrogram(ctx, w, h, t0, t1, showPlayhead) {
    if (!spec || duration <= 0) {
      drawPlaceholder(ctx, w, h, "spectrogram");
      return;
    }

    // Colors + gain (rescale only, no recompute)
    const leftRGB = parseHexColor(elLeftColor.value);
    const rightRGB = parseHexColor(elRightColor.value);
    const gain = parseFloat(elGain.value);

    // Auto-normalize based on observedMax (updates as worker runs)
    const norm = 255 / Math.max(1, spec.observedMax);

    // Background for uncomputed areas
    ctx.fillStyle = "#bdbdbd";
    ctx.fillRect(0,0,w,h);

    // Pixel render
    const img = ctx.createImageData(w, h);
    const data = img.data;

    // Precompute bin-per-y for log mapping (fast)
    const yToBin = new Int32Array(h);
    for (let y=0;y<h;y++) yToBin[y] = binForY(y, h);

    // Time->col mapping
    const c0 = colIndexForTime(t0);
    const c1 = colIndexForTime(t1);

    for (let x=0; x<w; x++) {
      const u = x / Math.max(1, w - 1);
      const t = t0 + u * (t1 - t0);
      const c = colIndexForTime(t);
      const computed = spec.computedCols[c] === 1;

      const colBase = c * (spec.nBins * 2);

      for (let y=0; y<h; y++) {
        const idx = (y*w + x) * 4;

        if (!computed) {
          data[idx+0] = 160;
          data[idx+1] = 160;
          data[idx+2] = 160;
          data[idx+3] = 255;
          continue;
        }

        const b = yToBin[y];
        const i = colBase + b*2;
        const uL = spec.dataLR[i];     // 0..255
        const uR = spec.dataLR[i + 1]; // 0..255

        // Convert to alpha (0..1), normalize and apply gain
        // Mild curve improves visibility
        let aL = Math.pow((uL * norm) / 255, 0.8) * gain;
        let aR = Math.pow((uR * norm) / 255, 0.8) * gain;
        aL = clamp(aL, 0, 1);
        aR = clamp(aR, 0, 1);

        // Blend by alpha add (in RGB), exactly as you requested originally
        const r = clamp(leftRGB[0]*aL + rightRGB[0]*aR, 0, 255) | 0;
        const g = clamp(leftRGB[1]*aL + rightRGB[1]*aR, 0, 255) | 0;
        const bch = clamp(leftRGB[2]*aL + rightRGB[2]*aR, 0, 255) | 0;

        data[idx+0] = r;
        data[idx+1] = g;
        data[idx+2] = bch;
        data[idx+3] = 255;
      }
    }

    ctx.putImageData(img, 0, 0);

    // Playhead line
    if (showPlayhead) {
      const tNow = elAudio.currentTime || 0;
      if (tNow >= t0 && tNow <= t1) {
        const xNow = Math.floor(((tNow - t0) / (t1 - t0)) * w);
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(xNow, 0, Math.max(1, Math.floor(w/700)), h);
      }
    }
  }

  function drawOverview() {
    const w = cvOverview.width, h = cvOverview.height;
    drawSpectrogram(ctxO, w, h, 0, Math.max(0.0001, duration), true);
  }

  function drawZoom() {
    const w = cvZoom.width, h = cvZoom.height;
    if (!spec || duration <= 0) {
      drawPlaceholder(ctxZ, w, h, "zoom");
      return;
    }

    const winSec = zoomWindowSeconds();

    let center = elAudio.currentTime || 0;
    if (panMode) center = clamp(center + panOffsetSec, 0, duration);

    const t0 = clamp(center - winSec/2, 0, Math.max(0, duration - winSec));
    const t1 = clamp(t0 + winSec, 0, duration);

    drawSpectrogram(ctxZ, w, h, t0, t1, true);

    elViewInfo.textContent =
      `View ${fmtTime(t0)} – ${fmtTime(t1)}  |  Playhead ${fmtTime(elAudio.currentTime||0)} / ${fmtTime(duration)}`;
  }

  function drawAll() {
    drawOverview();
    drawZoom();
  }

  // ------------------------------
  // Controls
  // ------------------------------
  function seekTo(t) {
    if (!isFinite(duration) || duration <= 0) return;
    elAudio.currentTime = clamp(t, 0, Math.max(0, duration - 0.001));
    drawAll();
  }

  btnPlay.addEventListener('click', async () => {
    try { await elAudio.play(); } catch {}
  });
  btnPause.addEventListener('click', () => elAudio.pause());
  btnStop.addEventListener('click', () => { elAudio.pause(); seekTo(0); });

  btnBack5.addEventListener('click', () => seekTo((elAudio.currentTime||0) - 5));
  btnFwd5.addEventListener('click', () => seekTo((elAudio.currentTime||0) + 5));

  btnPanL.addEventListener('click', () => { panMode = true; panOffsetSec -= 1; drawAll(); });
  btnPanR.addEventListener('click', () => { panMode = true; panOffsetSec += 1; drawAll(); });
  btnFollow.addEventListener('click', () => { panMode = false; panOffsetSec = 0; drawAll(); });

  // Space toggles PLAY/STOP (as requested)
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      if (btnPlay.disabled) return;
      if (elAudio.paused) {
        // if at end, restart
        if (duration > 0 && (elAudio.currentTime || 0) >= duration - 0.05) elAudio.currentTime = 0;
        elAudio.play().catch(()=>{});
      } else {
        elAudio.pause();
        elAudio.currentTime = 0;
      }
    }
  });

  // Gain & color changes: NO recompute, just re-render
  elGain.addEventListener('input', () => {
    elGainVal.textContent = parseFloat(elGain.value).toFixed(2) + "×";
    drawAll();
  });
  elLeftColor.addEventListener('input', drawAll);
  elRightColor.addEventListener('input', drawAll);

  // ------------------------------
  // File input
  // ------------------------------
  elFile.addEventListener('change', async () => {
    const f = elFile.files && elFile.files[0];
    if (!f) return;
    await loadFile(f);
  });

  // ------------------------------
  // Resize + RAF
  // ------------------------------
  function resizeAll() {
    let changed = false;
    changed = resizeCanvasToCSSPixels(cvOverview) || changed;
    changed = resizeCanvasToCSSPixels(cvZoom) || changed;
    if (changed) drawAll();
  }
  window.addEventListener('resize', resizeAll);

  function tick() {
    drawAll();
    raf = requestAnimationFrame(tick);
  }

  // init
  setEnabled(false);
  elGainVal.textContent = parseFloat(elGain.value).toFixed(2) + "×";
  resizeAll();
})();
</script>
</body>
</html>
