<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Treble + Bass Note Quiz (A–G)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 18px; }
    .row { display: flex; gap: 18px; align-items: flex-start; flex-wrap: wrap; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px 14px; }
    .big { font-size: 18px; }
    button { padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; }
    button:hover { background: #f0f0f0; }
    .hint { color: #666; font-size: 13px; }
    .good { color: #0a7a2f; font-weight: 600; }
    .bad  { color: #b32020; font-weight: 600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    #boardWrap { width: min(980px, 98vw); }
    #board { width: 100%; height: auto; display: block; }
    #history { max-height: 360px; overflow: auto; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border-bottom: 1px solid #eee; padding: 6px 8px; text-align: left; font-size: 13px; }
    th { position: sticky; top: 0; background: #fff; }
    .kbd { border: 1px solid #ccc; border-bottom-width: 2px; border-radius: 6px; padding: 1px 6px; background: #fafafa; }
  </style>
</head>
<body>
  <h2 style="margin: 0 0 6px 0;">Treble + Bass Note Quiz</h2>

  <div class="row">
    <div class="card" id="boardWrap">
      <svg id="board" viewBox="0 0 1000 520" xmlns="http://www.w3.org/2000/svg" aria-label="Music staff quiz">
        <!-- drawn by JS -->
      </svg>
      <div class="row" style="margin-top: 10px; align-items: center;">
        <div class="big">Answer: <span id="typed" class="mono">_</span></div>
        <div id="feedback" class="big" aria-live="polite"></div>
        <div style="margin-left:auto" class="hint">
          Attempts on this note: <span id="tries" class="mono">0</span>
        </div>
      </div>
    </div>

    <div class="card" style="min-width: 280px; flex: 1;">
      <div class="row" style="align-items: center;">
        <div class="big">Stats</div>
        <button id="resetBtn" title="Reset history + stats">Reset</button>
      </div>
      <div style="margin-top: 8px;">
        <div>Total notes completed: <span id="done" class="mono">0</span></div>
        <div>Correct (first try): <span id="firstTry" class="mono">0</span></div>
        <div>Pass rate: <span id="rate" class="mono">0%</span></div>
        <div class="hint" style="margin-top: 8px;">
          “Pass rate” here = (correct on first try) / (notes completed).
        </div>
      </div>

      <div class="big" style="margin-top: 14px;">History</div>
      <div id="history" style="margin-top: 6px;">
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Note</th>
              <th>Clef</th>
              <th>Tries</th>
            </tr>
          </thead>
          <tbody id="histBody"></tbody>
        </table>
      </div>

    </div>
  </div>

<script>
(() => {
  // ---------- Music mapping (diatonic, no sharps/flats) ----------
  // Represent notes by letter + octave (scientific pitch notation).
  // diatonicIndex: C0=0, D0=1, ... B0=6, C1=7, ... C4=28, ...
  const LETTERS = ["C","D","E","F","G","A","B"];
  const letterToStep = new Map(LETTERS.map((L,i)=>[L,i]));

  function diatonicIndex(letter, octave) {
    return octave * 7 + letterToStep.get(letter);
  }
  function noteFromIndex(idx) {
    const octave = Math.floor(idx / 7);
    const letter = LETTERS[idx % 7];
    return { letter, octave };
  }
  function noteName(n) { return `${n.letter}${n.octave}`; }

  // Range: C2 .. E6 inclusive
  const MIN_IDX = diatonicIndex("C", 2);
  const MAX_IDX = diatonicIndex("E", 6);

  // Staff reference: Middle C = C4 (between staves)
  const MID_C_IDX = diatonicIndex("C", 4);

  // Treble lines: E4 G4 B4 D5 F5 (indices: 30,32,34,36,38)
  // Bass lines:   G2 B2 D3 F3 A3 (indices: 18,20,22,24,26)
  const trebleLineIdx = ["E4","G4","B4","D5","F5"].map(parseNoteName).map(n => diatonicIndex(n.letter,n.octave));
  const bassLineIdx   = ["G2","B2","D3","F3","A3"].map(parseNoteName).map(n => diatonicIndex(n.letter,n.octave));

  function parseNoteName(s) {
    return { letter: s[0], octave: Number(s.slice(1)) };
  }

  // ---------- UI state ----------
  let current = null; // { idx, note:{letter,octave}, clef:"treble"|"bass", tries, hintUsed, startedAt }
  let done = 0;
  let firstTry = 0;
  let history = []; // [{noteName, clef, tries}]
  let waitingForNext = false; // true while showing green note before advancing

  // ---------- Audio ----------
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  // Chromatic semitone offset from C for each letter (no sharps/flats)
  const SEMI = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };

  function midiForNote(letter, octave) {
    return 12 + octave * 12 + SEMI[letter]; // C4 = 60
  }

  function freqForMidi(midi) {
    return 440 * Math.pow(2, (midi - 69) / 12);
  }

  function playNote(letter, octave, duration = 0.5) {
    audioCtx.resume();
    const freq = freqForMidi(midiForNote(letter, octave));
    const osc = audioCtx.createOscillator();
    osc.type = "sine";
    osc.frequency.value = freq;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.35, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(g).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  }

  // Find the octave for `letter` closest to `current.idx`
  function closestOctave(letter) {
    const targetIdx = current.idx;
    let bestOct = 2, bestDist = Infinity;
    for (let oct = 1; oct <= 7; oct++) {
      const d = Math.abs(diatonicIndex(letter, oct) - targetIdx);
      if (d < bestDist) { bestDist = d; bestOct = oct; }
    }
    return bestOct;
  }

  // ---------- SVG drawing ----------
  const svg = document.getElementById("board");

  // Layout (big + simple)
  const W = 1000, H = 520;

  const marginL = 70;
  const marginR = 40;
  const staffX0 = 140;
  const staffX1 = W - marginR;

  const staffGap = 120;           // gap between staves (centered on middle C line)
  const lineSpacing = 26;         // distance between staff lines
  const step = lineSpacing / 2;   // distance between adjacent line/space positions

  // Place middle C line between staves
  const yMidC = 260;

  // Compute Y for a diatonic index: higher notes -> smaller y
  function yForIndex(idx) {
    return yMidC - (idx - MID_C_IDX) * step;
  }

  function clearSvg() {
    while (svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function el(name, attrs = {}) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, String(v));
    return n;
  }

  function drawStaffLines(lineIdxs) {
    for (const idx of lineIdxs) {
      const y = yForIndex(idx);
      svg.appendChild(el("line", { x1: staffX0, y1: y, x2: staffX1, y2: y, stroke: "#111", "stroke-width": 2 }));
    }
  }

  // Middle C line is no longer drawn as a full staff line.
  // It appears only as a ledger line when a note is on or near it (handled by drawLedgerLinesFor).

  // Clef drawings using proper SVG paths
  // Treble clef: G4 line is the reference (spiral wraps around it)
  // Bass clef: F3 line is the reference (dots straddle it)

  function drawTrebleClef(xPos) {
    // G4 is the second line of treble staff
    const yG4 = yForIndex(diatonicIndex("G", 4));

    // Treble clef SVG path (from UXWing, public domain)
    // Original viewBox: 0 0 43.52 122.88
    // Scale to fit staff height and position so G line is at correct spot
    const scale = 1.1;
    const clefHeight = 122.88 * scale;
    const clefWidth = 43.52 * scale;

    // The G line should be at approximately 37% from top of the clef
    const yOffset = yG4 - (clefHeight * 0.37);
    const xOffset = xPos - clefWidth / 2;

    const g = el("g", { transform: `translate(${xOffset}, ${yOffset}) scale(${scale})` });
    g.appendChild(el("path", {
      d: "M11.35,45.61q3.72-4.22,7.69-8a45.71,45.71,0,0,1-2.19-12c-.23-7.24.88-14.93,5-21C23,2.79,25-.25,27.17,0,29,.24,30,2.83,30.72,4.32c4.92,10,5.93,20.54.25,31.93a46,46,0,0,1-7.84,10.8l2.38,12.12a8.74,8.74,0,0,1,.87-.14,14.2,14.2,0,0,1,8.56,1.41c5.6,3,9.08,10.57,8.52,16.83-.5,5.5-3,9.3-7.15,12.63a23.92,23.92,0,0,1-4.24,2.78l2.87,14.62a28.07,28.07,0,0,1,.12,3.74c-.35,7.71-6.35,12.16-13.78,11.82-5.72-.36-11.67-4.9-11.7-10.64-.06-11.13,15-10.6,13.9-.42-.32,3-2.51,5.65-7.21,5.82,3.79,6.28,15.51,1.79,16.31-6.44a17.52,17.52,0,0,0-.69-6.24L29.72,93.65a17.7,17.7,0,0,1-3.07.67A23.71,23.71,0,0,1,8.5,88.66a26,26,0,0,1-8-24.34C2,56.69,6.39,51.26,11.35,45.61Zm9.81-9.53C19.09,28.55,19.4,19,24.73,12.76S35.94,15,28.18,27.42a48.8,48.8,0,0,1-7,8.66Zm0,13c-.67.67-1.36,1.34-2.06,2-4,3.85-8,7.52-11,13a20.65,20.65,0,0,0-1.5,17.23c2.4,7.49,14,12.21,22.65,9.94L24.72,67.63a9.82,9.82,0,0,0-7.09,8,8.7,8.7,0,0,0,3.08,7.81,16.74,16.74,0,0,0,1.81,1.36c1.24.82.63,1.41-.53,1.06-3.87-1.3-6.19-3.44-7.43-6.17-3.67-8.08.83-17.08,8.66-19.92L21.16,49.07ZM31.63,90.43,27.09,67.24a9,9,0,0,1,4.53,1,12,12,0,0,1,6.62,8.23c1.2,5.57-1.7,11.72-6.49,13.94l-.12.05Z",
      fill: "#111", "fill-rule": "evenodd"
    }));
    svg.appendChild(g);
  }

  function drawBassClef(xPos) {
    // F3 is the fourth line of bass staff (second from top) - dots straddle this
    const yF3 = yForIndex(diatonicIndex("F", 3));
    const g = el("g");

    // Bass clef - main curved body with two dots
    // Scale and position so F line aligns with the main dot
    const scale = 0.9;
    const x = xPos;

    // Main dot on F line
    g.appendChild(el("circle", { cx: x, cy: yF3, r: 8 * scale, fill: "#111" }));

    // Main curved body extending down and left from the dot
    g.appendChild(el("path", {
      d: `M ${x} ${yF3}
          C ${x + 25*scale} ${yF3 - 35*scale}, ${x + 30*scale} ${yF3 - 45*scale}, ${x + 15*scale} ${yF3 - 52*scale}
          C ${x - 5*scale} ${yF3 - 60*scale}, ${x - 30*scale} ${yF3 - 45*scale}, ${x - 30*scale} ${yF3 - 20*scale}
          C ${x - 30*scale} ${yF3 + 10*scale}, ${x - 15*scale} ${yF3 + 35*scale}, ${x + 5*scale} ${yF3 + 50*scale}`,
      fill: "none", stroke: "#111", "stroke-width": 5, "stroke-linecap": "round", "stroke-linejoin": "round"
    }));

    // Two dots to the right - one above F line, one below (in the spaces E3 and G3)
    const dotX = x + 22 * scale;
    const dotSpacing = step; // one space = half line spacing
    g.appendChild(el("circle", { cx: dotX, cy: yF3 - dotSpacing, r: 5 * scale, fill: "#111" }));
    g.appendChild(el("circle", { cx: dotX, cy: yF3 + dotSpacing, r: 5 * scale, fill: "#111" }));

    svg.appendChild(g);
  }

  function drawBrace() {
    // Simple vertical brace-ish marker at the left to indicate grand staff
    const x = staffX0 - 30;
    const yTop = yForIndex(trebleLineIdx[4]) - 40;
    const yBot = yForIndex(bassLineIdx[0]) + 40;
    svg.appendChild(el("path", {
      d: `M ${x} ${yTop} C ${x-20} ${yTop+30}, ${x-20} ${yTop+70}, ${x} ${yTop+100}
          C ${x+12} ${yTop+120}, ${x+12} ${(yTop+yBot)/2 - 20}, ${x} ${(yTop+yBot)/2}
          C ${x-12} ${(yTop+yBot)/2 + 20}, ${x-12} ${yBot-120}, ${x} ${yBot-100}
          C ${x+20} ${yBot-70}, ${x+20} ${yBot-30}, ${x} ${yBot}`,
      fill: "none", stroke: "#111", "stroke-width": 4, "stroke-linecap": "round"
    }));
  }

  function drawLedgerLinesFor(idx, xCenter) {
    // Draw ledger lines outside the staves as needed.
    // We draw short lines for every "line" position beyond staff bounds.
    const trebleTop = trebleLineIdx[4];
    const trebleBot = trebleLineIdx[0];
    const bassTop   = bassLineIdx[4];
    const bassBot   = bassLineIdx[0];

    const x0 = xCenter - 22, x1 = xCenter + 22;

    // Determine which staff region the note is in.
    // Use the closest staff: if idx >= MID_C_IDX then treble-ish, else bass-ish.
    const useTreble = idx >= MID_C_IDX;

    if (useTreble) {
      // Above treble top or below treble bottom => ledger lines at every even offset from staff lines.
      if (idx > trebleTop) {
        for (let k = trebleTop + 2; k <= idx; k += 2) {
          svg.appendChild(el("line", { x1: x0, y1: yForIndex(k), x2: x1, y2: yForIndex(k), stroke: "#111", "stroke-width": 2 }));
        }
      } else if (idx < trebleBot) {
        for (let k = trebleBot - 2; k >= idx; k -= 2) {
          svg.appendChild(el("line", { x1: x0, y1: yForIndex(k), x2: x1, y2: yForIndex(k), stroke: "#111", "stroke-width": 2 }));
        }
      }
    } else {
      if (idx > bassTop) {
        for (let k = bassTop + 2; k <= idx; k += 2) {
          svg.appendChild(el("line", { x1: x0, y1: yForIndex(k), x2: x1, y2: yForIndex(k), stroke: "#111", "stroke-width": 2 }));
        }
      } else if (idx < bassBot) {
        for (let k = bassBot - 2; k >= idx; k -= 2) {
          svg.appendChild(el("line", { x1: x0, y1: yForIndex(k), x2: x1, y2: yForIndex(k), stroke: "#111", "stroke-width": 2 }));
        }
      }
    }

    // Always ensure Middle C ledger line is visible when the note is C4.
    if (idx === MID_C_IDX) {
      svg.appendChild(el("line", { x1: x0, y1: yMidC, x2: x1, y2: yMidC, stroke: "#111", "stroke-width": 2 }));
    }
  }

  const NOTE_X = 720; // fixed note x for simplicity

  function drawNote(idx, color = "#111", label = null) {
    const x = NOTE_X;
    const y = yForIndex(idx);

    drawLedgerLinesFor(idx, x);

    // Notehead (quarter note: filled)
    svg.appendChild(el("ellipse", {
      cx: x, cy: y, rx: 16, ry: 12,
      fill: color,
      transform: `rotate(-18 ${x} ${y})`
    }));

    // Stem direction: up below middle line of the staff, down above.
    const midTreble = diatonicIndex("B", 4);
    const midBass   = diatonicIndex("D", 3);
    const inTreble = idx >= MID_C_IDX;
    const stemDown = inTreble ? (idx >= midTreble) : (idx >= midBass);

    const stemH = 74;
    if (stemDown) {
      svg.appendChild(el("line", { x1: x - 14, y1: y, x2: x - 14, y2: y + stemH, stroke: color, "stroke-width": 4, "stroke-linecap": "round" }));
    } else {
      svg.appendChild(el("line", { x1: x + 14, y1: y, x2: x + 14, y2: y - stemH, stroke: color, "stroke-width": 4, "stroke-linecap": "round" }));
    }

    // Optional text label next to the note
    if (label) {
      const labelX = x + 30;
      const t = el("text", { x: labelX, y: y + 6, fill: color, "font-size": 22, "font-weight": "bold" });
      t.textContent = label;
      svg.appendChild(t);
    }
  }

  function renderBoard() {
    clearSvg();

    // Title text
    const title = el("text", { x: marginL, y: 40, fill: "#111", "font-size": 22, "font-weight": "600" });
    title.textContent = "Type A–G";
    svg.appendChild(title);

    // Staff system
    drawBrace();
    drawStaffLines(trebleLineIdx);
    drawStaffLines(bassLineIdx);

    // Clefs - positioned relative to their reference lines (G4 for treble, F3 for bass)
    drawTrebleClef(staffX0 - 70);
    drawBassClef(staffX0 - 60);

    // Current note
    drawNote(current.idx);
  }

  // Redraw the note with a specific color and optional label (for correct/hint)
  function redrawNoteAs(color, label) {
    // Remove old note elements (last few SVG children: ellipse, stem line, possibly ledger lines)
    // Simpler: just re-render the whole board with the colored note
    clearSvg();
    // Redraw staff
    const title = el("text", { x: marginL, y: 40, fill: "#111", "font-size": 22, "font-weight": "600" });
    title.textContent = "Type A–G";
    svg.appendChild(title);
    drawBrace();
    drawStaffLines(trebleLineIdx);
    drawStaffLines(bassLineIdx);
    drawTrebleClef(staffX0 - 70);
    drawBassClef(staffX0 - 60);
    const lt = el("text", { x: staffX0 - 10, y: yForIndex(trebleLineIdx[4]) - 55, fill: "#666", "font-size": 14 });
    lt.textContent = "Treble";
    svg.appendChild(lt);
    const lb = el("text", { x: staffX0 - 10, y: yForIndex(bassLineIdx[4]) - 45, fill: "#666", "font-size": 14 });
    lb.textContent = "Bass";
    svg.appendChild(lb);
    drawNote(current.idx, color, label);
  }

  // ---------- Quiz flow ----------
  function randomInt(lo, hi) { return lo + Math.floor(Math.random() * (hi - lo + 1)); }

  function newQuestion() {
    const idx = randomInt(MIN_IDX, MAX_IDX);
    const note = noteFromIndex(idx);

    // “Clef” here is just what staff region it visually belongs to (for history display).
    // Notes at/above middle C lean treble; below lean bass.
    const clef = (idx >= MID_C_IDX) ? "treble" : "bass";

    current = { idx, note, clef, tries: 0, hintUsed: false, startedAt: Date.now() };
    waitingForNext = false;

    document.getElementById("typed").textContent = "_";
    document.getElementById("feedback").textContent = "";
    document.getElementById("feedback").className = "big";
    document.getElementById("tries").textContent = "0";

    renderBoard();

    // Play the correct pitch
    playNote(note.letter, note.octave, 0.6);
  }

  function updateStats() {
    document.getElementById("done").textContent = String(done);
    document.getElementById("firstTry").textContent = String(firstTry);
    const rate = done === 0 ? 0 : Math.round((firstTry / done) * 100);
    document.getElementById("rate").textContent = `${rate}%`;
  }

  function addHistoryRow(entry) {
    const tbody = document.getElementById("histBody");
    const tr = document.createElement("tr");

    const tdN = document.createElement("td");
    tdN.textContent = String(history.length);
    tr.appendChild(tdN);

    const tdNote = document.createElement("td");
    tdNote.textContent = entry.noteName;
    tr.appendChild(tdNote);

    const tdClef = document.createElement("td");
    tdClef.textContent = entry.clef;
    tr.appendChild(tdClef);

    const tdTries = document.createElement("td");
    tdTries.textContent = String(entry.tries);
    tr.appendChild(tdTries);

    tbody.prepend(tr);
  }

  function handleGuess(letter) {
    if (waitingForNext) return; // Ignore input while showing correct answer

    const typedEl = document.getElementById("typed");
    const fb = document.getElementById("feedback");

    typedEl.textContent = letter;

    // Play the pitch of the guessed letter (closest octave to correct answer)
    const guessOct = closestOctave(letter);
    playNote(letter, guessOct, 0.4);

    current.tries++;
    document.getElementById("tries").textContent = String(current.tries);

    if (letter === current.note.letter) {
      fb.textContent = "✓";
      fb.className = "big good";

      done++;
      if (current.tries === 1 && !current.hintUsed) firstTry++;

      const entry = {
        noteName: noteName(current.note),
        clef: current.clef,
        tries: current.tries
      };
      history.push(entry);
      addHistoryRow(entry);

      updateStats();

      // Show note in green with its name
      redrawNoteAs("#0a7a2f", noteName(current.note));
      waitingForNext = true;

      // Next question after a pause to see the green note
      setTimeout(newQuestion, 1200);
    } else {
      fb.textContent = "✗";
      fb.className = "big bad";
    }
  }

  // Keyboard: A–G to answer, H for hint
  window.addEventListener("keydown", (e) => {
    if (waitingForNext) return;
    const k = e.key.toUpperCase();
    if (k.length === 1 && k >= "A" && k <= "G") {
      e.preventDefault();
      handleGuess(k);
    } else if (k === "H" || e.key === "?") {
      e.preventDefault();
      if (current && !waitingForNext) {
        current.hintUsed = true;
        // Show note name next to the note
        redrawNoteAs("#cc8800", noteName(current.note));
      }
    } else if (k === "R" && !e.metaKey && !e.ctrlKey) {
      e.preventDefault();
      if (current && !waitingForNext) {
        playNote(current.note.letter, current.note.octave, 0.6);
      }
    }
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
    done = 0;
    firstTry = 0;
    history = [];
    document.getElementById("histBody").innerHTML = "";
    updateStats();
    newQuestion();
  });

  // Init
  updateStats();
  newQuestion();
})();
</script>

Key bindings:
<ul>
  <li><b>A</b>–<b>G</b>: answer with that note letter</li>
  <li><b>H</b>: show hint (note name next to the note)</li>
  <li><b>R</b>: replay the current note's pitch</li>
</ul>

Tips:
<ul>
  <li>Multiple tries are allowed per note. Only first-try correct answers (without hints) count toward the pass rate.</li>
  <li>Middle C is on the ledger line between the two staves.</li>
  <li>Range is limited to C2..E6.</li>
</ul>

</body>
</html>
