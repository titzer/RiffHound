<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RiffHound Template</title>
<style>
  /* Minimal, readable, big-click targets */
  body { font-family: sans-serif; background: #fff; color: #000; margin: 0; }
  #top { display: flex; flex-wrap: nowrap; gap: 1vh; padding: 1vh; background: #eee; align-items: stretch; }
  #top button { flex: 1 1 0; font-size: 3.2vh; padding: 1.2vh 1vw; }
  button { cursor: pointer; border: 1px solid #bbb; }
  /* Top row buttons: blue by default, green when playing */
  #top button { background: #8389ff; color: #fff; border: 1px solid #8389ff; }
  body.playing #top button { background: #007700; color: #fff; border: 1px solid #007700; }
  /* Play: green when not playing, neutral when playing */
  #top #btnPlay { background: #007700; color: #fff; border: 1px solid #007700; }
  body.playing #top #btnPlay { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  /* Stop: neutral when stopped, red when playing */
  #top #btnStop { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnStop { background: #770000; color: #fff; border: 1px solid #770000; }
  /* Pause: yellow when paused (overrides the green playing color) */
  #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }
  body.playing #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }
  /* Mute button active: yellow (persists even while playing) */
  #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  body.playing #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  /* Neutral buttons: no color state */
  #top #btnTap, #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnTap, body.playing #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  button.flash { background: #4CAF50; color: #fff; }

  /* BPM display in top row */
  #bpmDisplay {
    font-size: 5.5vh;
    font-weight: bold;
    padding: 0.5vh 0.3vw;
    background: #f4f4f4;
    border: 1px solid #bbb;
    border-radius: 4px;
    width: 3.2ch;
    text-align: center;
    box-sizing: border-box;
  }
</style>
</head>
<body>
  <div id="top">
    <button id="btnPlay"   class="primary">‚ñ∂Ô∏è Play</button>
    <button id="btnPause">‚è∏ Pause</button>
    <button id="btnStop"   class="danger stopped">‚èπ Stop</button>
    <button id="btnMute"   class="mute">üîä Sound</button>
    <button id="btnTap">üïí Tap Tempo</button>
    <input id="bpmDisplay" type="text" value="110" maxlength="3">
  </div>

<script>
// =========================
// Drum Practice v0.1.1 ‚Äî step editor (5 voices, 16/32 steps)
// =========================

// --- Global state ---
let bpm = 110;              // quarter-note BPM
let playing = false;
let paused = false;
let timeSig = '4/4';   // '4/4', '3/4', or '6/8'
let pausedElapsed = 0;   // ctx time elapsed at the moment of pause
let muted = false;
let steps = 16;             // 16 or 32 eighth-note steps
let currentStep = 0;        // which step is currently playing (0..steps-1)
let startTime = 0;          // audio time for transport start
const taps = [];

// pattern[voiceIndex][stepIndex] -> boolean (eighth-note grid)
let pattern = [];      // main pattern
let fillPattern = [];  // fill pattern (last 4 steps)

// --- DOM refs ---
const el = {};

// --- Audio setup ---
const ctx = new (window.AudioContext || window.webkitAudioContext)();
const master = ctx.createGain(); master.connect(ctx.destination);
const bus = { drums: ctx.createGain() };
Object.values(bus).forEach(g => g.connect(master));

// One-off buffers
const noiseBuf = (() => {
  const b = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
  const d = b.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  return b;
})();


// =========================
// Transport & scheduling (8th notes)
// =========================
function stepDuration() { return (60 / bpm) / 2; } // 8th-note grid

function scheduleStep(si, when, useFill) {
  if (muted) return; // Skip sound generation when muted
}

function tickRAF() { // visuals & near-future scheduling
  if (!playing || paused) return;
  const now = ctx.currentTime;
  const dur = stepDuration();
  const elapsed = now - startTime;
  const totalSteps = Math.floor(elapsed / dur);
                      
  requestAnimationFrame(tickRAF);
}

// =========================
// UI actions (top-level)
// =========================
function actionPlay() { // start transport
  if (playing) return;
  ctx.resume();
  playing = true;
  startTime = ctx.currentTime + 0.03;
  currentStep = 0;
  requestAnimationFrame(tickRAF);
  el.btnPlay.classList.add('playing');
  el.btnStop.classList.remove('stopped');
  document.body.classList.add('playing');
  updateMuteButton();
}

function actionPause() { // toggle pause
  if (!playing) return;
  if (!paused) {
    paused = true;
    pausedElapsed = ctx.currentTime - startTime;
    el.btnPause.classList.add('paused');
  } else {
    paused = false;
    startTime = ctx.currentTime - pausedElapsed;
    el.btnPause.classList.remove('paused');
    requestAnimationFrame(tickRAF);
  }
}

function actionStop() { // stop transport
  if (!playing) return;
  playing = false;
  paused = false;
  pausedElapsed = 0;
  el.btnPause.classList.remove('paused');
  el.btnPlay.classList.remove('playing');
  el.btnStop.classList.add('stopped');
  document.body.classList.remove('playing');
  el.grid.querySelectorAll('.cell.inactive').forEach(c => c.classList.remove('inactive'));
  updateMuteButton();
}

function actionMuteToggle() { // toggle mute
  muted = !muted;
  updateMuteButton();

  // Flash the mute button
  el.btnMute.classList.add('flash');
  setTimeout(() => el.btnMute.classList.remove('flash'), 150);
}

function updateMuteButton() {
  if (muted && playing) {
    el.btnMute.classList.add('active');
  } else {
    el.btnMute.classList.remove('active');
  }

  // Update icon based on muted state
  el.btnMute.textContent = muted ? 'üîá Muted' : 'üîä Sound';
}

function actionTapSpace() { // accumulate taps ‚Üí BPM
  const now = performance.now();
  taps.push(now);
  while (taps.length > 6) taps.shift();
  if (taps.length >= 2) {
    const diffs = taps.slice(1).map((t,i) => t - taps[i]);
    const avg = diffs.reduce((a,b) => a + b, 0) / diffs.length;
    bpm = Math.max(30, Math.min(300, Math.round(60000 / avg)));
    el.bpmDisplay.value = bpm;
    updatePatternText();
    if (playing) { startTime = ctx.currentTime; }

    // Flash the tap button
    el.btnTap.classList.add('flash');
    setTimeout(() => el.btnTap.classList.remove('flash'), 150);
  }
}

function actionSetBPM(val) { // slider or text input changed
  const oldBpm = bpm;
  bpm = Math.max(30, Math.min(300, parseInt(val, 10) || bpm));
  el.bpmDisplay.value = bpm;

  if (playing && bpm !== oldBpm) {
    // Preserve current position when changing tempo
    const now = ctx.currentTime;
    const oldDur = (60 / oldBpm) / 2;
    const elapsed = now - startTime;
    const totalSteps = Math.floor(elapsed / oldDur);
    const newDur = stepDuration();
    startTime = now - (totalSteps * newDur);
  }

  if (bpm !== oldBpm) {
    updatePatternText();
  }
}


function actionKeyDown(e) { // global keyboard shortcuts
  if (e.code === 'Space') { e.preventDefault(); if (playing) actionStop(); else actionPlay(); return; }
if (e.code === 'KeyT' && document.activeElement !== el.patternText) { e.preventDefault(); actionTapSpace(); return; } // T triggers tap tempo
  if (e.code === 'KeyP' && document.activeElement !== el.patternText) { e.preventDefault(); actionPause(); return; } // P toggles pause
  if (e.code === 'KeyM') { e.preventDefault(); actionMuteToggle(); return; } // M toggles mute
  if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
    // Round up to nearest 5, then subtract 5
    const rounded = Math.ceil(bpm / 5) * 5;
    const newBpm = rounded - 5;
    actionSetBPM(newBpm >= 30 ? newBpm : 30);
    return;
  }
  if (e.code === 'Equal' || e.code === 'NumpadAdd') {
    // Round down to nearest 5, then add 5
    const rounded = Math.floor(bpm / 5) * 5;
    const newBpm = rounded + 5;
    actionSetBPM(newBpm <= 300 ? newBpm : 300);
  }
}

function getButtonAndAddAction(name, action) {
  var btn = document.getElementById(name);
  btn.addEventListener('click', action);
  return btn;
}
                           
// =========================
// Wiring (once)
// =========================
function init() {
  // Cache DOM
  el.btnPlay   = getButtonAndAddAction('btnPlay', actionPlay);
  el.btnPause  = getButtonAndAddAction('btnPause', actionPause);
  el.btnStop   = getButtonAndAddAction('btnStop', actionStop);
  el.btnMute   = getButtonAndAddAction('btnMute', actionMuteToggle);
  el.btnTap    = getButtonAndAddAction('btnTap', actionTapSpace);

  el.bpmDisplay = document.getElementById('bpmDisplay')
  el.bpmDisplay.addEventListener('input', e => {
    e.target.value = e.target.value.replace(/[^0-9]/g, '').slice(0, 3);
  });
  el.bpmDisplay.addEventListener('change', e => {
    const val = parseInt(e.target.value, 10);
    if (val >= 30 && val <= 300) {
      actionSetBPM(val);
    } else {
      e.target.value = Math.round(bpm).toString();
    }
  });
  document.body.addEventListener('keydown', actionKeyDown);
}

// Boot
init();
</script>

<div style="padding: 1vh 1vw;">
    <button id="btnHelp" onclick="document.getElementById('helpSection').scrollIntoView({behavior:'smooth'})">Help ‚Üì</button>
</div>

<div style="height: 120vh;"></div>

<div id="helpSection" style="padding: 1vh 1vw; font-size: 2vh;">
Key bindings:
<ul>
  <li>SPACE: play or stop</li>
  <li>P: pause</li>
  <li>T: tap to tempo</li>
  <li>M: mute</li>
  <li>-: decrease tempo</li>
  <li>+: increase tempo</li>
</ul>

TODO:
<ul>
    <li>The application.</li>
</ul>
</div>
</body>
</html>
