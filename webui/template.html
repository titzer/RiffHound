<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RiffHound Rhythm Buddy v0.1</title>
<style>
  /* Minimal, readable, big-click targets */
  body { font-family: sans-serif; background: #fff; color: #000; margin: 0; }
  #top { display: flex; flex-wrap: nowrap; gap: 1vh; padding: 1vh; background: #eee; align-items: stretch; }
  #top button, #top select { flex: 1 1 0; font-size: 3.2vh; padding: 1.2vh 1vw; }
  button { cursor: pointer; border: 1px solid #bbb; }
  /* Top row buttons: blue by default, green when playing */
  #top button { background: #8389ff; color: #fff; border: 1px solid #8389ff; }
  body.playing #top button { background: #007700; color: #fff; border: 1px solid #007700; }
  /* Play: green when not playing, neutral when playing */
  #top #btnPlay { background: #007700; color: #fff; border: 1px solid #007700; }
  body.playing #top #btnPlay { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  /* Stop: neutral when stopped, red when playing */
  #top #btnStop { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnStop { background: #770000; color: #fff; border: 1px solid #770000; }
  /* Pause: yellow when paused (overrides the green playing color) */
  #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }
  body.playing #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }
  /* Mute button active: yellow (persists even while playing) */
  #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  body.playing #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  /* Neutral buttons: no color state */
  #top #btnTap, #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnTap, body.playing #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  button.flash { background: #4CAF50; color: #fff; }

  #repeatViz { padding: 1vh 1vw; display: flex; gap: 1rem; align-items: center; }
  #repeatViz .label { font-weight: bold; }
  #repeatBoxes { display: flex; gap: 0.4rem; }
  .repeatBox { width: 48px; height: 48px; border: 2px solid #999; background: #f0f0f0; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px; border-radius: 4px; }
  .repeatBox.typeA { background: #d0d4ff; border-color: #8389ff; color: #8389ff; }
  body.playing .repeatBox.typeA { background: #d0ffd0; border-color: #007700; color: #007700; }
  .repeatBox.typeB { background: linear-gradient(to top left, #bb5500 35%, #d0d4ff 35%); border-color: #8389ff; color: #8389ff; }
  body.playing .repeatBox.typeB { background: linear-gradient(to top left, #bb5500 35%, #d0ffd0 35%); border-color: #007700; color: #007700; }
  .repeatBox.active { box-shadow: 0 0 0 4px #8389ff; outline: 3px solid #8389ff; }

  #grid { padding: 1vh 1vw; display: grid; grid-template-columns: auto auto 1fr; column-gap: .4rem; row-gap: .2rem; }
  .row { display: grid; grid-column: 1 / -1; grid-template-columns: subgrid; align-items: center; }
  .row .name { min-width: 6ch; text-align: right; }
  button.voiceMute { min-width: 6ch; text-align: center; font-size: 1.8vh; padding: 0.4vh 0.4vw; border-radius: 3px; background: #8389ff; color: #fff; border: 1px solid #8389ff; }
  body.playing button.voiceMute { background: #007700; color: #fff; border-color: #007700; }
  button.voiceMute.active { background: #ffcc00; color: #000; border-color: #ffcc00; }
  body.playing button.voiceMute.active { background: #ffcc00; color: #000; border-color: #ffcc00; }
  .steps { display: grid; gap: 2px; grid-auto-flow: column; width: 100%; }
  .cell { height: 8vh; border: 1px solid #bbb; background: #fafafa; display: inline-flex; align-items: center; justify-content: center; font-size: 12px; user-select: none; box-sizing: border-box; position: relative; }

  /* on cells: blue when stopped or future (not yet played) */
  .cell.on { background: #8389ff; color: #fff; border-color: #8389ff; }
  /* beat borders ‚Äî always black */
  .cell.beat { border: 2px solid #000; }
  body.playing .cell.beat { border-color: #000; }
  .cell.on.beat { border-color: #000; }
  body.playing .cell.on.beat { border-color: #000; }
  /* bar start: darker blue tint when stopped/future */
  .cell.on.barStart { background-color: #6066cc; }
  /* bar start circle: gray when off, black when on */
  .cell.barStart::before { content: ''; position: absolute; width: 70%; aspect-ratio: 1; border-radius: 50%; background: #aaa; pointer-events: none; }
  .cell.barStart.on::before { background: #000; }
  /* current column: thick green border + green fill on active cells */
  body.playing .cell.columnActive { border: 8px solid #007700 !important; }
  body.playing .cell.on.columnActive { background: #007700; border-color: #007700; }
  body.playing .cell.on.barStart.columnActive { background-color: #2f8f2f; }
  body.playing .cell.on.fill.columnActive { background: #007700; border-color: #007700; }
  /* past cells (already played): light green */
  body.playing .cell.on.past { background: #99cc99; color: #333; border-color: #99cc99; }
  body.playing .cell.on.past.beat { border-color: #000; }
  body.playing .cell.on.barStart.past { background-color: #77aa77; }
  /* fill pattern: orange when stopped; blue when playing+future; light green when playing+past */
  .cell.fill { background-color: #ffe0e0; }
  .cell.on.fill { background-color: #bb5500; border-color: #bb5500; }
  body.playing .cell.on.fill { background: #8389ff; border-color: #8389ff; }
  body.playing .cell.on.fill.past { background-color: #99cc99; border-color: #99cc99; }
  body.playing .cell.on.fill.past.beat { border-color: #000; }
  /* muted voice: enabled cells yellow regardless of state */
  .voiceMuted .cell.on { background: #ffcc00 !important; border-color: #ccaa00 !important; }
  .voiceMuted .cell.on.beat { border-color: #000 !important; }
  .voiceMuted .cell.on.barStart { border-left-color: #000 !important; }
  /* per-voice randomize button */
  button.voiceRandom { background: none; border: none; padding: 1px 3px; font-size: 24px; cursor: pointer; line-height: 1; }
  button.voiceRandom:hover { background: #f0f0f0; }
  /* inactive cells: almost invisible ‚Äî white wash, light gray borders, faded pseudo-elements */
  .cell.inactive { box-shadow: inset 0 0 0 1000px rgba(255, 255, 255, 0.95); border-color: #ddd !important; }
  .cell.inactive::before { background: #ddd !important; }
  .cell.inactive::after  { background: #ddd !important; }
  /* gap column between main pattern and fill */
  .fillGap { pointer-events: none; }
  /* right-facing triangle on end-column and fill-start cells */
  .cell.endCol::after, .cell.fillStart::after {
    content: '';
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 40%; aspect-ratio: 1;
    clip-path: polygon(0% 0%, 100% 50%, 0% 100%);
    background: #bbb;
    pointer-events: none;
  }
  .cell.endCol.on::after, .cell.fillStart.on::after { background: #000; }
  /* ruler row */
  .rulerCell { height: 4vh; display: inline-flex; align-items: center; justify-content: center; box-sizing: border-box; overflow: hidden; border: 1px solid transparent; }
  .rulerCell.beatNum { font-size: 1.4vh; color: #888; }
  .rulerCell.barNum { font-size: 1.8vh; font-weight: bold; color: #333; }
  .rulerCell.fillLabel { font-size: 1.8vh; font-weight: bold; color: #bb5500; }
  .rulerCell.endLabel  { font-size: 1.8vh; font-weight: bold; color: #bb5500; }
  body.playing .rulerCell.columnActive { border: 8px solid #007700 !important; }

  /* BPM display in top row */
  #bpmDisplay {
    font-size: 5.5vh;
    font-weight: bold;
    padding: 0.5vh 0.3vw;
    background: #f4f4f4;
    border: 1px solid #bbb;
    border-radius: 4px;
    width: 3.2ch;
    text-align: center;
    box-sizing: border-box;
  }
  #bottom { padding: 1vh 1vw; font-size: 2.2vh; display: flex; flex-wrap: wrap; gap: .6em; align-items: center; }
  input, select { font-size: 2.2vh; }
</style>
</head>
<body>
  <div id="top">
    <button id="btnPlay"   class="primary">‚ñ∂Ô∏è Play</button>
    <button id="btnPause">‚è∏ Pause</button>
    <button id="btnStop"   class="danger stopped">‚èπ Stop</button>
    <button id="btnMute"   class="mute">üîä Sound</button>
    <button id="btnTap">üïí Tap Tempo</button>
    <input id="bpmDisplay" type="text" value="110" maxlength="3">
  </div>

<script>
// =========================
// Drum Practice v0.1.1 ‚Äî step editor (5 voices, 16/32 steps)
// =========================

// --- Global state ---
let bpm = 110;              // quarter-note BPM
let playing = false;
let paused = false;
let timeSig = '4/4';   // '4/4', '3/4', or '6/8'
let pausedElapsed = 0;   // ctx time elapsed at the moment of pause
let muted = false;
let steps = 16;             // 16 or 32 eighth-note steps
let currentStep = 0;        // which step is currently playing (0..steps-1)
let startTime = 0;          // audio time for transport start
const taps = [];

// pattern[voiceIndex][stepIndex] -> boolean (eighth-note grid)
let pattern = [];      // main pattern
let fillPattern = [];  // fill pattern (last 4 steps)

// --- DOM refs ---
const el = {};

// --- Audio setup ---
const ctx = new (window.AudioContext || window.webkitAudioContext)();
const master = ctx.createGain(); master.connect(ctx.destination);
const bus = { drums: ctx.createGain() };
Object.values(bus).forEach(g => g.connect(master));

// One-off buffers
const noiseBuf = (() => {
  const b = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
  const d = b.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  return b;
})();


// =========================
// Transport & scheduling (8th notes)
// =========================
function stepDuration() { return (60 / bpm) / 2; } // 8th-note grid

function scheduleStep(si, when, useFill) {
  if (muted) return; // Skip sound generation when muted
}

function tickRAF() { // visuals & near-future scheduling
  if (!playing || paused) return;
  const now = ctx.currentTime;
  const dur = stepDuration();
  const elapsed = now - startTime;
  const totalSteps = Math.floor(elapsed / dur);
                      
  requestAnimationFrame(tickRAF);
}

// =========================
// UI actions (top-level)
// =========================
function actionPlay() { // start transport
  if (playing) return;
  ctx.resume();
  playing = true;
  startTime = ctx.currentTime + 0.03;
  currentStep = 0;
  requestAnimationFrame(tickRAF);
  el.btnPlay.classList.add('playing');
  el.btnStop.classList.remove('stopped');
  document.body.classList.add('playing');
  updateMuteButton();
}

function actionPause() { // toggle pause
  if (!playing) return;
  if (!paused) {
    paused = true;
    pausedElapsed = ctx.currentTime - startTime;
    el.btnPause.classList.add('paused');
  } else {
    paused = false;
    startTime = ctx.currentTime - pausedElapsed;
    el.btnPause.classList.remove('paused');
    requestAnimationFrame(tickRAF);
  }
}

function actionStop() { // stop transport
  if (!playing) return;
  playing = false;
  paused = false;
  pausedElapsed = 0;
  el.btnPause.classList.remove('paused');
  el.btnPlay.classList.remove('playing');
  el.btnStop.classList.add('stopped');
  document.body.classList.remove('playing');
  el.grid.querySelectorAll('.cell.inactive').forEach(c => c.classList.remove('inactive'));
  updateMuteButton();
}

function actionMuteToggle() { // toggle mute
  muted = !muted;
  updateMuteButton();

  // Flash the mute button
  el.btnMute.classList.add('flash');
  setTimeout(() => el.btnMute.classList.remove('flash'), 150);
}

function updateMuteButton() {
  if (muted && playing) {
    el.btnMute.classList.add('active');
  } else {
    el.btnMute.classList.remove('active');
  }

  // Update icon based on muted state
  el.btnMute.textContent = muted ? 'üîá Muted' : 'üîä Sound';
}

function actionTapSpace() { // accumulate taps ‚Üí BPM
  const now = performance.now();
  taps.push(now);
  while (taps.length > 6) taps.shift();
  if (taps.length >= 2) {
    const diffs = taps.slice(1).map((t,i) => t - taps[i]);
    const avg = diffs.reduce((a,b) => a + b, 0) / diffs.length;
    bpm = Math.max(30, Math.min(300, Math.round(60000 / avg)));
    el.bpmDisplay.value = bpm;
    updatePatternText();
    if (playing) { startTime = ctx.currentTime; }

    // Flash the tap button
    el.btnTap.classList.add('flash');
    setTimeout(() => el.btnTap.classList.remove('flash'), 150);
  }
}

function actionSetBPM(val) { // slider or text input changed
  const oldBpm = bpm;
  bpm = Math.max(30, Math.min(300, parseInt(val, 10) || bpm));
  el.bpmDisplay.value = bpm;

  if (playing && bpm !== oldBpm) {
    // Preserve current position when changing tempo
    const now = ctx.currentTime;
    const oldDur = (60 / oldBpm) / 2;
    const elapsed = now - startTime;
    const totalSteps = Math.floor(elapsed / oldDur);
    const newDur = stepDuration();
    startTime = now - (totalSteps * newDur);
  }

  if (bpm !== oldBpm) {
    updatePatternText();
  }
}


function actionKeyDown(e) { // global keyboard shortcuts
  if (e.code === 'Space') { e.preventDefault(); if (playing) actionStop(); else actionPlay(); return; }
if (e.code === 'KeyT' && document.activeElement !== el.patternText) { e.preventDefault(); actionTapSpace(); return; } // T triggers tap tempo
  if (e.code === 'KeyP' && document.activeElement !== el.patternText) { e.preventDefault(); actionPause(); return; } // P toggles pause
  if (e.code === 'KeyM') { e.preventDefault(); actionMuteToggle(); return; } // M toggles mute
  if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
    // Round up to nearest 5, then subtract 5
    const rounded = Math.ceil(bpm / 5) * 5;
    const newBpm = rounded - 5;
    actionSetBPM(newBpm >= 30 ? newBpm : 30);
    return;
  }
  if (e.code === 'Equal' || e.code === 'NumpadAdd') {
    // Round down to nearest 5, then add 5
    const rounded = Math.floor(bpm / 5) * 5;
    const newBpm = rounded + 5;
    actionSetBPM(newBpm <= 300 ? newBpm : 300);
  }
}

function getButtonAndAddAction(name, action) {
  var btn = document.getElementById(name);
  btn.addEventListener('click', action);
  return btn;
}
                           
// =========================
// Wiring (once)
// =========================
function init() {
  // Cache DOM
  el.btnPlay   = getButtonAndAddAction('btnPlay', actionPlay);
  el.btnPause  = getButtonAndAddAction('btnPause', actionPause);
  el.btnStop   = getButtonAndAddAction('btnStop', actionStop);
  el.btnMute   = getButtonAndAddAction('btnMute', actionMuteToggle);
  el.btnTap    = getButtonAndAddAction('btnTap', actionTapSpace);

  el.bpmDisplay = document.getElementById('bpmDisplay')
  el.bpmDisplay.addEventListener('input', e => {
    e.target.value = e.target.value.replace(/[^0-9]/g, '').slice(0, 3);
  });
  el.bpmDisplay.addEventListener('change', e => {
    const val = parseInt(e.target.value, 10);
    if (val >= 30 && val <= 300) {
      actionSetBPM(val);
    } else {
      e.target.value = Math.round(bpm).toString();
    }
  });
  document.body.addEventListener('keydown', actionKeyDown);
}

// Boot
init();
</script>

<div style="padding: 1vh 1vw;">
    <button id="btnHelp" onclick="document.getElementById('helpSection').scrollIntoView({behavior:'smooth'})">Help ‚Üì</button>
</div>

<div style="height: 120vh;"></div>

<div id="helpSection" style="padding: 1vh 1vw; font-size: 2vh;">
Key bindings:
<ul>
  <li>SPACE: play or stop</li>
  <li>P: pause</li>
  <li>T: tap to tempo</li>
  <li>M: mute</li>
  <li>-: decrease tempo</li>
  <li>+: increase tempo</li>
</ul>

TODO:
<ul>
    <li>The application.</li>
</ul>
</div>
</body>
</html>
