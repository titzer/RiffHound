<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RiffHound Rhythm Buddy v0.2</title>
<style>
  body { font-family: sans-serif; background: #fff; color: #000; margin: 0; }
  #top { display: flex; flex-wrap: nowrap; gap: 1vh; padding: 1vh; background: #eee; align-items: stretch; }
  #top button { flex: 1 1 0; font-size: 3.2vh; padding: 1.2vh 1vw; }
  button { cursor: pointer; border: 1px solid #bbb; }

  /* Top row buttons: blue by default, green when playing */
  #top button { background: #8389ff; color: #fff; border: 1px solid #8389ff; }
  body.playing #top button { background: #007700; color: #fff; border: 1px solid #007700; }

  /* Play: green when not playing, neutral when playing */
  #top #btnPlay { background: #007700; color: #fff; border: 1px solid #007700; }
  body.playing #top #btnPlay { background: #f4f4f4; color: #000; border: 1px solid #bbb; }

  /* Stop: neutral when stopped, red when playing */
  #top #btnStop { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnStop { background: #770000; color: #fff; border: 1px solid #770000; }

  /* Pause: yellow when paused */
  #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }
  body.playing #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }

  /* Mute button active: yellow */
  #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  body.playing #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }

  /* Neutral buttons */
  #top #btnTap, #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnTap, body.playing #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }

  button.flash { background: #4CAF50; color: #fff; }

  /* BPM display: 5 chars with decimal */
  #bpmDisplay {
    font-size: 5.5vh;
    font-weight: bold;
    padding: 0.5vh 0.3vw;
    background: #f4f4f4;
    border: 1px solid #bbb;
    border-radius: 4px;
    width: 5.2ch;
    text-align: center;
    box-sizing: border-box;
  }

  /* Status area */
  #statusBar{
    padding: 0.8vh 1vw;
    background:#f8f8f8;
    border-top:1px solid #ddd;
    font-size: 2.2vh;
    display:flex;
    gap: 2vw;
    flex-wrap: wrap;
    align-items: baseline;
  }
  #lockLamp{
    display:inline-block;
    padding: 0.3vh 0.9vw;
    border:1px solid #bbb;
    border-radius: 999px;
    background:#eee;
    font-weight:700;
  }
  body.listening #lockLamp{
    background:#ffcc00;
    color:#000;
    border-color:#ccaa00;
  }
  body.tracking #lockLamp{
    background:#ff3333;
    color:#fff;
    border-color:#ff3333;
  }
  body.locked #lockLamp{
    background:#0a0;
    color:#fff;
    border-color:#0a0;
  }

  #mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    white-space: nowrap;
  }

  #visCanvas {
    display: block;
    width: 100%;
    height: 75vh;
    border-top: 1px solid #ddd;
  }

  /* Little adjustment buttons in the status bar */
  #adjBox { display:flex; gap: 0.7vw; align-items:center; }
  #adjBox button { font-size: 2.0vh; padding: 0.3vh 0.7vw; background:#f4f4f4; color:#000; border:1px solid #bbb; }
  #adjBox button:active { transform: translateY(1px); }
</style>
</head>
<body>
  <div id="top">
    <button id="btnPlay"   class="primary">‚ñ∂Ô∏è Play</button>
    <button id="btnPause">‚è∏ Pause</button>
    <button id="btnStop"   class="danger stopped">‚èπ Stop</button>
    <button id="btnAcquire">‚ö°Acquire</button>
    <button id="btnTrack">üéØ Track</button>
    <button id="btnMute"   class="mute">üîä Sound</button>
    <button id="btnTap">üïí Tap Tempo</button>
    <input id="bpmDisplay" type="text" value="110.0" maxlength="5">
  </div>

  <div id="statusBar">
    <div style="padding: 1vh 1vw;">
      <button id="btnHelp" onclick="document.getElementById('helpSection').scrollIntoView({behavior:'smooth'})">Help ‚Üì</button>
    </div>

    <span id="lockLamp">IDLE</span>
    <span id="statusText"></span>

    <span id="adjBox">
      <span style="opacity:0.7">nudge:</span>
      <button id="btnNudgeMinus" title="Shift ticks earlier by 10ms ([)">[ -10ms</button>
      <button id="btnNudgePlus"  title="Shift ticks later by 10ms (])">+10ms ]</button>
      <span style="opacity:0.7">offset:</span>
      <span id="offsetMs">0</span><span style="opacity:0.7">ms</span>
    </span>

    <span id="mono">err: <span id="errMs">‚Äî</span> ms | floor: <span id="floorV">‚Äî</span> | e: <span id="eV">‚Äî</span></span>
  </div>

  <canvas id="visCanvas"></canvas>

<script>
// =========================
// Rhythm Buddy v0.2
// State machine: IDLE | ACQUIRE | TRACK | LOCKED
//
// IDLE      --A--> ACQUIRE   (start mic, collect beats)
// IDLE      --R--> TRACK     (use current BPM, start mic, play)
// IDLE   --SPACE-> LOCKED    (use current BPM, no mic, play)
// ACQUIRE   --auto-> TRACK   (4 good beats collected)
// ACQUIRE   --auto-> IDLE    (20s timeout, error)
// ACQUIRE   --R--> LOCKED    (commit estimate early)
// TRACK     --auto-> LOCKED  (phase stable OR 8 beats seen)
// TRACK     --R--> LOCKED    (force lock now)
// LOCKED    --R--> TRACK     (re-open mic, phase-adjust)
// LOCKED    --A--> ACQUIRE   (re-open mic, re-collect)
// any playing --SPACE-> IDLE (stop everything)
// =========================

let bpm = 110.0;
let playing = false;
let paused = false;
let pausedElapsed = 0;
let muted = false;
let startTime = 0;
const taps = [];

const el = {};

const ctx = new (window.AudioContext || window.webkitAudioContext)();
const master = ctx.createGain();
master.connect(ctx.destination);

// =========================
// UI helpers
// =========================
function fmtBpm(x) {
  x = Math.max(30, Math.min(300, x));
  return x.toFixed(1);
}
function setBpmDisplay(x) {
  bpm = Math.max(30, Math.min(300, x));
  el.bpmDisplay.value = fmtBpm(bpm);
  // Propagate immediately when free-running (no mic adjusting the period)
  if (BF.state === 'LOCKED') BF.period = 60 / bpm;
}
function setLamp(text) { el.lockLamp.textContent = text; }
function setStatus(msg) { el.statusText.textContent = msg; }

function setBodyFlags() {
  document.body.classList.toggle('playing',  playing);
  document.body.classList.toggle('listening', BF.active && BF.state === 'ACQUIRE');
  document.body.classList.toggle('tracking',  BF.active && BF.state === 'TRACK');
  document.body.classList.toggle('locked',    BF.state === 'LOCKED');  // mic may be off
}

// =========================
// Transport
// =========================
function tickRAF() {
  if (!playing || paused) return;
  // When mic is off (LOCKED), tickRAF owns tick scheduling
  if (!BF.active) scheduleTicks(ctx.currentTime);
  requestAnimationFrame(tickRAF);
}

function ensurePlayingUI() {
  if (playing) return;
  playing = true;
  startTime = ctx.currentTime + 0.03;
  el.btnPlay.classList.add('playing');
  el.btnStop.classList.remove('stopped');
  setBodyFlags();
  updateMuteButton();
  requestAnimationFrame(tickRAF);
}

function ensureStoppedUI() {
  playing = false;
  paused = false;
  pausedElapsed = 0;
  el.btnPause.classList.remove('paused');
  el.btnPlay.classList.remove('playing');
  el.btnStop.classList.add('stopped');
  setBodyFlags();
  updateMuteButton();
}

// =========================
// Tick sound
// =========================
function playTick(atTime, accent=false) {
  if (muted) return;
  const osc = ctx.createOscillator();
  const g   = ctx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(accent ? 1320 : 990, atTime);
  g.gain.setValueAtTime(0.0001, atTime);
  g.gain.exponentialRampToValueAtTime(accent ? 0.25 : 0.18, atTime + 0.0015);
  g.gain.exponentialRampToValueAtTime(0.0001, atTime + 0.030);
  osc.connect(g); g.connect(master);
  osc.start(atTime);
  osc.stop(atTime + 0.040);
}

// =========================
// Beat follower state
// =========================
const BF = {
  active: false,
  state: 'IDLE',

  stream: null, src: null, hp: null, analyser: null, buf: null,

  // detector (energy-based transient detector)
  floor: 0.0, e: 0.0, eFast: 0.0,
  threshMul: 6.0, refractoryBase: 0.12, lastTrig: -1e9,

  // acquisition
  acquireStart: 0.0, events: [], estPeriod: null, estBpm: null,

  // clock  (nextTick = -1 means "not yet set")
  period: 60/110, t0: 0.0, nextTick: -1.0, lookahead: 0.20,

  // tracking
  alpha: 0.14, errAbsHist: [], lockWindow: 12, lockMedMs: 22.0,
  trackBeatCount: 0,

  // manual nudge (display-only; ticks are shifted by adjusting t0/nextTick)
  manualOffsetSec: 0.0,

  lastBeatSeen: -1e9, maxAcquireSec: 20.0,
};

function resetFollowerUI() {
  el.errMs.textContent  = '‚Äî';
  el.floorV.textContent = '‚Äî';
  el.eV.textContent     = '‚Äî';
  el.offsetMs.textContent = '0';
  setLamp('IDLE');
  setStatus('');
  setBodyFlags();
}

function hardResetFollowerState() {
  BF.state = 'IDLE';
  BF.events = []; BF.estPeriod = null; BF.estBpm = null;
  BF.floor = 0.0; BF.e = 0.0; BF.eFast = 0.0; BF.lastTrig = -1e9;
  BF.errAbsHist = []; BF.lastBeatSeen = -1e9;
  BF.trackBeatCount = 0;
  BF.nextTick = -1.0;
  BF.t0 = 0.0;
  BF.manualOffsetSec = 0.0;
  VIS.onStateChange('IDLE', ctx.currentTime);
  resetFollowerUI();
}

function median(arr) {
  const a = arr.slice().sort((x,y)=>x-y);
  const n = a.length;
  if (!n) return NaN;
  return (n % 2) ? a[n>>1] : 0.5*(a[(n>>1)-1] + a[n>>1]);
}
function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

// =========================
// Mic management
// =========================
function stopMicHardware() {
  if (BF.src)      { try { BF.src.disconnect();     } catch(_) {} }
  if (BF.hp)       { try { BF.hp.disconnect();      } catch(_) {} }
  if (BF.analyser) { try { BF.analyser.disconnect();} catch(_) {} }
  BF.src = null; BF.hp = null; BF.analyser = null; BF.buf = null;
  if (BF.stream) { for (const t of BF.stream.getTracks()) t.stop(); }
  BF.stream = null;
  BF.active = false;
}

async function openMic() {
  const constraints = {
    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
  };
  BF.stream = await navigator.mediaDevices.getUserMedia(constraints);
  BF.src = ctx.createMediaStreamSource(BF.stream);

  BF.hp = ctx.createBiquadFilter();
  BF.hp.type = 'highpass';
  BF.hp.frequency.value = 600;
  BF.hp.Q.value = 0.707;

  BF.analyser = ctx.createAnalyser();
  BF.analyser.fftSize = 2048;
  BF.buf = new Float32Array(BF.analyser.fftSize);

  BF.src.connect(BF.hp);
  BF.hp.connect(BF.analyser);
  BF.active = true;
}

// Full stop: mic off, state IDLE, stop playing
function stopEverything() {
  VIS.frozenNow = ctx.currentTime;
  stopMicHardware();
  hardResetFollowerState();
  ensureStoppedUI();
}

// =========================
// Transition to LOCKED
// =========================
function transitionToLocked() {
  BF.state = 'LOCKED';
  VIS.onStateChange('LOCKED', ctx.currentTime);
  setLamp('LOCKED');
  setStatus(`Locked. ${fmtBpm(60/BF.period)} BPM.`);
  setBodyFlags();
  ensurePlayingUI();
}

// =========================
// Beat detector (reworked energy)
// =========================
function currentRefractory() {
  if (BF.state === 'TRACK' || BF.state === 'LOCKED')
    return clamp(0.40 * BF.period, 0.08, 0.25);
  return BF.refractoryBase;
}

// Robust-ish transient energy: RMS of first difference
function computeDiffRms(buf) {
  let sumSq = 0.0;
  let prev = buf[0];
  for (let i = 1; i < buf.length; i++) {
    const x = buf[i];
    const d = x - prev;
    sumSq += d * d;
    prev = x;
  }
  return Math.sqrt(sumSq / (buf.length - 1));
}

// Asymmetric floor tracker: rise slowly, fall faster (avoids "stuck high" floor)
function updateFloor(floor, e) {
  if (floor <= 0) return e;
  if (e < floor) return floor * 0.97 + e * 0.03;    // drop faster
  // rise slowly, and cap growth to avoid "runaway" after a loud event
  const capped = Math.min(e, floor * 1.8);
  return floor * 0.995 + capped * 0.005;
}

function detectBeat(now) {
  if (!BF.analyser) return null;

  BF.analyser.getFloatTimeDomainData(BF.buf);

  const e = computeDiffRms(BF.buf);
  BF.e = e;
  BF.eFast = (BF.eFast > 0) ? (BF.eFast * 0.85 + e * 0.15) : e;

  BF.floor = updateFloor(BF.floor, e);

  el.floorV.textContent = BF.floor.toFixed(4);
  el.eV.textContent     = BF.e.toFixed(4);

  VIS.energySamples.push({time: now, e, floor: BF.floor, eFast: BF.eFast});

  const enoughTime = (now - BF.lastTrig) > currentRefractory();
  const above      = (BF.floor > 0) && (e > (BF.floor * BF.threshMul));

  if (enoughTime && above) {
    BF.lastTrig = now; BF.lastBeatSeen = now;
    return now;
  }
  return null;
}

// =========================
// ACQUIRE: collect beats ‚Üí auto-promote to TRACK
// =========================
function updateAcquireEstimate() {
  if (BF.events.length < 2) return;
  const t = BF.events, n = t.length;
  const dts = [];
  for (let i = Math.max(1, n-6); i < n; i++) dts.push(t[i] - t[i-1]);
  const minT = 60/240, maxT = 60/40;
  const ok = dts.filter(dt => dt >= minT && dt <= maxT);
  if (!ok.length) return;
  const T = median(ok);
  BF.estPeriod = T; BF.estBpm = 60/T;

  // TODO(ACQUIRE BPM): show crude estimate immediately (already does)
  setBpmDisplay(BF.estBpm);

  setLamp('ACQUIRE');
  setStatus(`Estimating‚Ä¶ ~${fmtBpm(BF.estBpm)} BPM (${BF.events.length} beats).`);
}

function tryPromoteToTrackFromAcquire() {
  if (BF.events.length < 4) return false;
  const t = BF.events, n = t.length;
  const dts = [t[n-1]-t[n-2], t[n-2]-t[n-3], t[n-3]-t[n-4]];
  const minT = 60/240, maxT = 60/40;
  if (dts.some(dt => dt < minT || dt > maxT)) return false;
  const T = median(dts);
  if (Math.max(...dts.map(dt => Math.abs(dt-T))) > 0.060) return false;

  BF.period = T;
  BF.t0 = t[n-1];
  BF.nextTick = BF.t0 + BF.period;
  BF.trackBeatCount = 0;
  setBpmDisplay(60 / BF.period);

  BF.state = 'TRACK';
  VIS.onStateChange('TRACK', ctx.currentTime);
  BF.errAbsHist = [];
  setLamp('TRACK');
  setStatus(`Tracking‚Ä¶ ${fmtBpm(60/BF.period)} BPM.`);
  setBodyFlags();
  ensurePlayingUI();
  return true;
}

// =========================
// TRACK: phase correction ‚Üí auto-lock after 8 beats or stable phase
// =========================
function phaseError(tBeat) {
  const T = BF.period;
  let ph = (tBeat - BF.t0) % T;
  if (ph < 0) ph += T;
  if (ph > T/2) ph -= T;
  return ph;
}

function onBeatDetected(tBeat) {
  if (BF.state === 'ACQUIRE') {
    BF.events.push(tBeat);
    if (BF.events.length > 16) BF.events.shift();
    updateAcquireEstimate();
    VIS.detectedBeats.push({time: tBeat, bpm: BF.estBpm, errMs: null});
    if (BF.estBpm != null) VIS.bpmSamples.push({time: tBeat, bpm: BF.estBpm, errMs: null});
    tryPromoteToTrackFromAcquire();
    return;
  }

  if (BF.state === 'TRACK') {
    const err = phaseError(tBeat);
    el.errMs.textContent = (err * 1000).toFixed(1);
    VIS.detectedBeats.push({time: tBeat, bpm: 60 / BF.period, errMs: err * 1000});
    VIS.bpmSamples.push({time: tBeat, bpm: 60 / BF.period, errMs: err * 1000});

    BF.t0 += BF.alpha * err;

    const now = ctx.currentTime;
    while (BF.nextTick < now + 0.01) BF.nextTick += BF.period;

    BF.trackBeatCount++;

    const errMs = Math.abs(err) * 1000.0;
    BF.errAbsHist.push(errMs);
    while (BF.errAbsHist.length > BF.lockWindow) BF.errAbsHist.shift();

    const phaseStable = BF.errAbsHist.length >= BF.lockWindow &&
                        median(BF.errAbsHist) <= BF.lockMedMs;
    const eightBeats  = BF.trackBeatCount >= 8;

    if (phaseStable || eightBeats) {
      transitionToLocked();
    }
  }
}

// =========================
// Commit: R during ACQUIRE ‚Üí LOCKED immediately
// =========================
function commitFromAcquire() {
  if (!BF.estPeriod || BF.events.length < 3) {
    setStatus('Need 3 beats.');
    return;
  }
  BF.period = BF.estPeriod;
  const last = BF.events[BF.events.length-1];
  BF.t0 = last;
  BF.nextTick = last + BF.period;
  setBpmDisplay(60 / BF.period);
  transitionToLocked();
}

// =========================
// Manual phase nudging (ticks earlier/later by 10ms)
// =========================
function nudgeTicks(deltaMs) {
  const ds = deltaMs / 1000.0;
  // Only meaningful when we have a clock
  if (!(BF.state === 'TRACK' || BF.state === 'LOCKED')) return;

  // Shift the phase reference and tick cursor together.
  BF.t0 += ds;
  BF.nextTick += ds;

  // Track accumulated offset (display only; you may choose to cap later)
  BF.manualOffsetSec += ds;
  el.offsetMs.textContent = Math.round(BF.manualOffsetSec * 1000);

  // Visual: mark a sample so you can see when you nudged
  VIS.markers.push({time: ctx.currentTime, label: (deltaMs > 0 ? '+10' : '-10')});
}

// =========================
// Tick scheduler
// =========================
let beatCount = 0;

function scheduleTicks(now) {
  if (paused) return;
  if (BF.state !== 'TRACK' && BF.state !== 'LOCKED') return;
  if (BF.nextTick < 0) return;  // not yet initialized

  // skip stale cursor (e.g. long pause) without burst
  if (BF.nextTick < now - BF.period) BF.nextTick = now;

  const horizon = now + BF.lookahead;
  while (BF.nextTick < horizon) {
    playTick(BF.nextTick, (beatCount % 4) === 0);
    beatCount++;
    BF.nextTick += BF.period;
  }
}

function beatFollowerRAF() {
  if (!BF.active) return;
  const now = ctx.currentTime;

  // ACQUIRE timeout ‚Üí IDLE
  if (BF.state === 'ACQUIRE' && (now - BF.acquireStart) > BF.maxAcquireSec) {
    setStatus('Gave up (20s).');
    VIS.frozenNow = now;
    stopMicHardware();
    hardResetFollowerState();
    ensureStoppedUI();
    return;
  }

  const trig = detectBeat(now);
  if (trig !== null) onBeatDetected(trig);

  scheduleTicks(now);
  requestAnimationFrame(beatFollowerRAF);
}

// =========================
// Actions
// =========================
async function actionAcquire() {
  await ctx.resume();
  if (BF.state === 'ACQUIRE' || BF.state === 'TRACK') return; // already listening

  // Stop mic if somehow on (shouldn't happen in normal flow)
  if (BF.active) stopMicHardware();

  // Fresh start from IDLE: clear visualization and stale phase
  if (BF.state === 'IDLE') {
    VIS.detectedBeats = []; VIS.energySamples = []; VIS.bpmSamples = [];
    VIS.markers = [];
    BF.t0 = 0;
    VIS.stateSamples = [];
    VIS.onStateChange('IDLE', ctx.currentTime);
  }

  // Preserve period/nextTick so ticks continue if coming from LOCKED
  BF.state        = 'ACQUIRE';
  VIS.onStateChange('ACQUIRE', ctx.currentTime);
  BF.acquireStart = ctx.currentTime;
  BF.events       = []; BF.estPeriod = null; BF.estBpm = null;
  BF.floor        = 0.0; BF.e = 0.0; BF.eFast = 0.0; BF.lastTrig = -1e9;
  BF.errAbsHist   = []; BF.lastBeatSeen = -1e9; BF.trackBeatCount = 0;

  try {
    await openMic();
  } catch (err) {
    console.error(err);
    BF.state = 'IDLE'; BF.active = false;
    setLamp('ERROR');
    setStatus('Mic failed (permission?).');
    setBodyFlags();
    return;
  }

  setLamp('ACQUIRE');
  setStatus('Listening‚Ä¶');
  setBodyFlags();
  requestAnimationFrame(beatFollowerRAF);
}

async function actionTrack() {
  await ctx.resume();

  if (BF.state === 'IDLE') {
    // IDLE ‚Üí TRACK: use current BPM, open mic
    VIS.detectedBeats = []; VIS.energySamples = []; VIS.bpmSamples = [];
    VIS.markers = [];
    VIS.stateSamples = [];
    VIS.onStateChange('IDLE', ctx.currentTime);

    BF.period = 60 / bpm;
    BF.t0 = ctx.currentTime;
    BF.nextTick = BF.t0;
    BF.errAbsHist = []; BF.trackBeatCount = 0;
    BF.lastBeatSeen = -1e9; beatCount = 0;

    try { await openMic(); } catch (err) {
      console.error(err);
      setLamp('ERROR');
      setStatus('Mic failed (permission?).');
      setBodyFlags();
      return;
    }

    BF.state = 'TRACK';
    VIS.onStateChange('TRACK', ctx.currentTime);
    setLamp('TRACK');
    setStatus(`Tracking‚Ä¶ ${fmtBpm(bpm)} BPM.`);
    setBodyFlags();
    ensurePlayingUI();
    requestAnimationFrame(beatFollowerRAF);
    return;
  }

  if (BF.state === 'ACQUIRE') { commitFromAcquire(); return; }

  if (BF.state === 'TRACK') { transitionToLocked(); return; }

  if (BF.state === 'LOCKED') {
    BF.errAbsHist = []; BF.trackBeatCount = 0; BF.lastBeatSeen = -1e9;
    const wasActive = BF.active;

    if (!wasActive) {
      try { await openMic(); } catch (err) {
        console.error(err);
        setLamp('ERROR');
        setStatus('Mic failed (permission?).');
        setBodyFlags();
        return;
      }
    }

    BF.state = 'TRACK';
    VIS.onStateChange('TRACK', ctx.currentTime);
    setLamp('TRACK');
    setStatus(`Tracking‚Ä¶ ${fmtBpm(60/BF.period)} BPM.`);
    setBodyFlags();
    if (!wasActive) requestAnimationFrame(beatFollowerRAF);
  }
}

async function actionPlay() {
  // Direct LOCKED play at current BPM (SPACE from IDLE)
  if (playing) return;
  await ctx.resume();
  BF.period  = 60 / bpm;
  BF.t0      = ctx.currentTime;
  BF.nextTick = BF.t0;
  beatCount  = 0;
  BF.state   = 'LOCKED';
  VIS.stateSamples = [];
  VIS.onStateChange('LOCKED', ctx.currentTime);

  setLamp('LOCKED');
  setStatus(`Playing. ${fmtBpm(bpm)} BPM.`);
  setBodyFlags();
  ensurePlayingUI();
  scheduleTicks(ctx.currentTime);
}

function actionStop() { stopEverything(); }

function actionPause() {
  if (!playing && !BF.active) return;
  if (!paused) {
    paused = true;
    pausedElapsed = ctx.currentTime - startTime;
    el.btnPause.classList.add('paused');
    setStatus('Paused.');
  } else {
    paused = false;
    startTime = ctx.currentTime - pausedElapsed;
    el.btnPause.classList.remove('paused');
    requestAnimationFrame(tickRAF);
    setStatus('Resumed.');
  }
}

function actionMuteToggle() {
  muted = !muted;
  updateMuteButton();
  el.btnMute.classList.add('flash');
  setTimeout(() => el.btnMute.classList.remove('flash'), 150);
}

function updateMuteButton() {
  const active = muted && (playing || BF.state === 'TRACK' || BF.state === 'LOCKED');
  el.btnMute.classList.toggle('active', active);
  el.btnMute.textContent = muted ? 'üîá Muted' : 'üîä Sound';
}

function actionTapTempo() {
  const now = performance.now();
  taps.push(now);
  while (taps.length > 6) taps.shift();
  if (taps.length >= 2) {
    const diffs = taps.slice(1).map((t,i) => t - taps[i]);
    const avg   = diffs.reduce((a,b) => a+b, 0) / diffs.length;
    setBpmDisplay(clamp(60000 / avg, 30, 300));
    el.btnTap.classList.add('flash');
    setTimeout(() => el.btnTap.classList.remove('flash'), 150);
  }
}

function actionSetBPM(val) {
  const x = parseFloat(val);
  if (!Number.isFinite(x)) { el.bpmDisplay.value = fmtBpm(bpm); return; }
  setBpmDisplay(clamp(x, 30, 300));
}

function actionKeyDown(e) {
  if (e.code === 'Space') {
    e.preventDefault();
    if (BF.active || playing) actionStop();
    else actionPlay();
    return;
  }
  if (e.code === 'KeyA') { e.preventDefault(); actionAcquire();   return; }
  if (e.code === 'KeyR') { e.preventDefault(); actionTrack();     return; }
  if (e.code === 'KeyT') { e.preventDefault(); actionTapTempo();  return; }
  if (e.code === 'KeyP') { e.preventDefault(); actionPause();     return; }
  if (e.code === 'KeyM') { e.preventDefault(); actionMuteToggle();return; }

  // Manual tick nudges: [ and ]
  if (e.code === 'BracketLeft')  { e.preventDefault(); nudgeTicks(-10); return; }
  if (e.code === 'BracketRight') { e.preventDefault(); nudgeTicks(+10); return; }

  if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
    setBpmDisplay(clamp(Math.ceil(bpm/5)*5 - 5, 30, 300)); return;
  }
  if (e.code === 'Equal' || e.code === 'NumpadAdd') {
    setBpmDisplay(clamp(Math.floor(bpm/5)*5 + 5, 30, 300)); return;
  }
}

function getButtonAndAddAction(name, action) {
  var btn = document.getElementById(name);
  btn.addEventListener('click', action);
  return btn;
}

// =========================
// Visualization
// =========================
const VIS = {
  detectedBeats: [],
  energySamples: [],   // {time, e, floor, eFast}
  bpmSamples:    [],   // {time, bpm, errMs}
  markers:       [],   // {time, label}
  stateSamples:  [],   // [{t0, state}, ...] (segments)
  windowSec: 6.0,
  nowFrac:   2/3,
  frozenNow: null,

  onStateChange(state, t) {
    const last = this.stateSamples.length ? this.stateSamples[this.stateSamples.length - 1] : null;
    if (last && last.state === state) return;
    this.stateSamples.push({t0: t, state});
  }
};

function drawDiamond(cx, x, y, r, filled) {
  cx.beginPath();
  cx.moveTo(x,     y - r);
  cx.lineTo(x + r, y    );
  cx.lineTo(x,     y + r);
  cx.lineTo(x - r, y    );
  cx.closePath();
  if (filled) cx.fill();
  cx.stroke();
}

function stateColor(state) {
  if (state === 'ACQUIRE') return '#ffcc00';
  if (state === 'TRACK')   return '#ff3333';
  if (state === 'LOCKED')  return '#00aa00';
  return '#888888'; // IDLE / unknown
}

function drawVis() {
  requestAnimationFrame(drawVis);

  const canvas = document.getElementById('visCanvas');
  if (!canvas) return;

  // Resize canvas buffer to match CSS size (DPR-aware)
  const dpr = window.devicePixelRatio || 1;
  const W   = canvas.offsetWidth;
  const H   = canvas.offsetHeight;
  if (W === 0 || H === 0) return;
  if (canvas.width !== W * dpr || canvas.height !== H * dpr) {
    canvas.width  = W * dpr;
    canvas.height = H * dpr;
  }

  const cx  = canvas.getContext('2d');
  cx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // In IDLE, freeze at the captured snapshot time so the canvas doesn't animate
  const now      = (BF.state === 'IDLE' && VIS.frozenNow !== null)
                   ? VIS.frozenNow : ctx.currentTime;
  const pxPerSec = W / VIS.windowSec;
  const nowX     = W * VIS.nowFrac;
  function timeToX(t) { return nowX + (t - now) * pxPerSec; }

  // Layout rows
  const detectedY   = H * 0.11;
  const predictedY  = H * 0.23;

  // State band (just below predicted line)
  const stateBandY  = H * 0.285;
  const stateBandH  = 14;

  const bpmTopY     = H * 0.34;
  const bpmBotY     = H * 0.62;
  const bpmCenterY  = (bpmTopY + bpmBotY) / 2;
  const bpmH        = bpmBotY - bpmTopY;

  const energyTopY  = H * 0.68;
  const energyH     = H - energyTopY;

  // Time window edges
  const leftT  = now - VIS.windowSec * VIS.nowFrac;
  const rightT = now + VIS.windowSec * (1 - VIS.nowFrac);

  // Background
  cx.fillStyle = '#f8f8f8';
  cx.fillRect(0, 0, W, H);
  cx.fillStyle = '#f2f0f8';
  cx.fillRect(0, bpmTopY, W, bpmH);
  cx.fillStyle = '#efefef';
  cx.fillRect(0, energyTopY, W, energyH);

  // --- 250ms vertical grid lines ---
  {
    const gridInterval = 0.250;
    let gridT = Math.ceil(leftT / gridInterval) * gridInterval;
    cx.strokeStyle = '#e4e4e4';
    cx.lineWidth   = 1;
    cx.setLineDash([]);
    cx.beginPath();
    while (gridT <= rightT) {
      const gx = timeToX(gridT);
      cx.moveTo(gx, 0);
      cx.lineTo(gx, H);
      gridT += gridInterval;
    }
    cx.stroke();
  }

  // Track guide lines
  cx.strokeStyle = '#d0d0d0';
  cx.lineWidth   = 1;
  cx.setLineDash([]);
  cx.beginPath();
  cx.moveTo(0, detectedY);   cx.lineTo(W, detectedY);
  cx.moveTo(0, predictedY);  cx.lineTo(W, predictedY);
  cx.moveTo(0, bpmTopY);     cx.lineTo(W, bpmTopY);
  cx.moveTo(0, energyTopY);  cx.lineTo(W, energyTopY);
  cx.stroke();

  // Track labels
  cx.fillStyle    = '#bbb';
  cx.font         = '10px sans-serif';
  cx.textAlign    = 'left';
  cx.textBaseline = 'bottom';
  cx.fillText('beats',     4, detectedY  - 3);
  cx.fillText('predicted', 4, predictedY - 3);
  cx.textBaseline = 'top';
  cx.fillText('state',     4, stateBandY - stateBandH/2 + 2);
  cx.fillText('bpm',       4, bpmTopY    + 2);
  cx.fillText('energy',    4, energyTopY + 2);

  // "Now" line
  cx.strokeStyle = '#bbb';
  cx.lineWidth   = 1;
  cx.setLineDash([4, 4]);
  cx.beginPath();
  cx.moveTo(nowX, 0);
  cx.lineTo(nowX, H);
  cx.stroke();
  cx.setLineDash([]);
  cx.fillStyle    = '#bbb';
  cx.textAlign    = 'center';
  cx.textBaseline = 'top';
  cx.fillText('now', nowX, 2);

  // --- State band over time (segment line) ---
  {
    // fill a subtle band background so it reads as "a lane"
    cx.fillStyle = '#f6f6f6';
    cx.fillRect(0, stateBandY - stateBandH/2, W, stateBandH);

    // draw segments
    if (!VIS.stateSamples.length) VIS.onStateChange(BF.state, now);

    // Determine segment endpoints within visible window
    const segs = VIS.stateSamples.slice();
    // Ensure there's a "current" segment continuing to 'now'
    const last = segs[segs.length - 1];
    if (!last || last.state !== BF.state) segs.push({t0: now, state: BF.state});

    cx.lineWidth = stateBandH - 6;
    cx.lineCap   = 'butt';

    for (let i = 0; i < segs.length; i++) {
      const s0 = segs[i];
      const s1 = (i + 1 < segs.length) ? segs[i+1] : {t0: now, state: s0.state};

      const a = Math.max(s0.t0, leftT);
      const b = Math.min(s1.t0, rightT);
      if (b <= a) continue;

      const x0 = timeToX(a);
      const x1 = timeToX(b);

      cx.strokeStyle = stateColor(s0.state);
      cx.beginPath();
      cx.moveTo(x0, stateBandY);
      cx.lineTo(x1, stateBandY);
      cx.stroke();
    }

    // State label to the right of the now line
    cx.font = 'bold 12px monospace';
    cx.textAlign = 'left';
    cx.textBaseline = 'middle';
    cx.fillStyle = stateColor(BF.state);
    cx.fillText(BF.state, nowX + 10, stateBandY);
  }

  // --- Detected beats ---
  cx.textAlign = 'center';
  for (const b of VIS.detectedBeats) {
    const x = timeToX(b.time);
    if (x < -30 || x > W + 30) continue;

    cx.fillStyle   = '#2266ee';
    cx.strokeStyle = '#2266ee';
    cx.lineWidth   = 1.5;
    drawDiamond(cx, x, detectedY, 10, true);

    if (b.bpm != null) {
      cx.fillStyle    = '#2266ee';
      cx.font         = 'bold 12px monospace';
      cx.textBaseline = 'bottom';
      cx.fillText(b.bpm.toFixed(1), x, detectedY - 11);
    }

    if (b.errMs != null) {
      const sign = b.errMs >= 0 ? '+' : '';
      cx.fillStyle    = '#888';
      cx.font         = '11px monospace';
      cx.textBaseline = 'top';
      cx.fillText(`${sign}${b.errMs.toFixed(0)}ms`, x, detectedY + 11);
    }
  }

  // --- Predicted beats ---
  if ((BF.state === 'TRACK' || BF.state === 'LOCKED') && BF.t0 > 0 && BF.period > 0) {
    let beatT = BF.t0 + Math.ceil((leftT - BF.t0) / BF.period) * BF.period;
    while (beatT <= rightT) {
      const x = timeToX(beatT);
      if (x >= -10 && x <= W + 10) {
        cx.strokeStyle = beatT > now ? '#ee8800' : '#ccc';
        cx.lineWidth   = 1.5;
        drawDiamond(cx, x, predictedY, 10, false);
      }
      beatT += BF.period;
    }
  }

  // --- Markers (nudges) ---
  {
    cx.font = '11px monospace';
    cx.textAlign = 'center';
    cx.textBaseline = 'bottom';
    for (const m of VIS.markers) {
      const x = timeToX(m.time);
      if (x < -10 || x > W + 10) continue;
      cx.strokeStyle = '#666';
      cx.lineWidth = 1;
      cx.beginPath();
      cx.moveTo(x, 0);
      cx.lineTo(x, H * 0.08);
      cx.stroke();
      cx.fillStyle = '#666';
      cx.fillText(m.label, x, H * 0.08 - 2);
    }
  }

  // --- BPM zone ---
  {
    // Center reference: current displayed BPM
    const nomBpm = bpm;
    const halfRange = 15;
    const bpmToY = b => bpmCenterY - Math.max(-1, Math.min(1, (b - nomBpm) / halfRange)) * (bpmH / 2);

    // Dashed center line at nominal BPM
    cx.strokeStyle = '#ccc8dd';
    cx.lineWidth   = 1;
    cx.setLineDash([4, 4]);
    cx.beginPath();
    cx.moveTo(0, bpmCenterY); cx.lineTo(W, bpmCenterY);
    cx.stroke();
    cx.setLineDash([]);

    // Nominal BPM label on right edge of center line
    cx.fillStyle    = '#aaa';
    cx.font         = '10px monospace';
    cx.textAlign    = 'right';
    cx.textBaseline = 'middle';
    cx.fillText(nomBpm.toFixed(1), W - 4, bpmCenterY);

    // During ACQUIRE, show current estimate (even if no points yet)
    if (BF.state === 'ACQUIRE' && BF.estBpm != null) {
      cx.strokeStyle = '#ffcc00';
      cx.lineWidth = 2;
      cx.setLineDash([6, 4]);
      cx.beginPath();
      cx.moveTo(0, bpmToY(BF.estBpm));
      cx.lineTo(W, bpmToY(BF.estBpm));
      cx.stroke();
      cx.setLineDash([]);
      cx.fillStyle = '#aa8800';
      cx.textAlign = 'right';
      cx.textBaseline = 'bottom';
      cx.font = '11px monospace';
      cx.fillText(`~${BF.estBpm.toFixed(1)}`, W - 4, bpmToY(BF.estBpm) - 2);
    }

    const visBpm = VIS.bpmSamples.filter(s => s.bpm != null);
    if (visBpm.length > 0) {
      cx.strokeStyle = '#7755bb';
      cx.lineWidth   = 1.5;
      cx.setLineDash([]);
      cx.beginPath();
      let first = true;
      for (const s of visBpm) {
        const x = timeToX(s.time);
        const y = bpmToY(s.bpm);
        if (first) { cx.moveTo(x, y); first = false; } else { cx.lineTo(x, y); }
      }
      if (BF.state === 'LOCKED') {
        cx.lineTo(nowX, bpmToY(60 / BF.period));
      }
      cx.stroke();

      for (const s of visBpm) {
        const x = timeToX(s.time);
        const y = bpmToY(s.bpm);

        cx.fillStyle = '#7755bb';
        cx.beginPath();
        cx.arc(x, y, 3, 0, Math.PI * 2);
        cx.fill();

        if (s.errMs != null) {
          const tickH = Math.max(-bpmH * 0.45, Math.min(bpmH * 0.45,
                        s.errMs * (bpmH * 0.45) / 50));
          cx.strokeStyle = Math.abs(s.errMs) > 30 ? '#cc5544' : '#9988cc';
          cx.lineWidth   = 1.5;
          cx.beginPath();
          cx.moveTo(x, bpmCenterY);
          cx.lineTo(x, bpmCenterY - tickH);
          cx.stroke();
        }
      }
    }
  }

  // --- Energy bar graph (cleaner normalization) ---
  for (const s of VIS.energySamples) {
    const x = timeToX(s.time);
    if (x < 0 || x > W) continue;

    const base = (s.floor > 0) ? s.floor : 1e-9;
    const ratio = s.e / base; // 1.0 ~ at floor, threshMul ~ trigger
    // map ratio in [1..threshMul*2] ‚Üí [0..1] using log
    const r = Math.max(1, Math.min(BF.threshMul * 2, ratio));
    const normalized = Math.log(r) / Math.log(BF.threshMul * 2);
    const barH = normalized * energyH;

    const threshold = s.floor * BF.threshMul;
    cx.fillStyle = s.e > threshold ? '#dd4444' : '#44aa66';
    cx.fillRect(x - 1.5, H - barH, 3, barH);
  }

  // Cull data older than the visible window
  const cullBefore = now - VIS.windowSec - 0.5;
  if (VIS.detectedBeats.length && VIS.detectedBeats[0].time < cullBefore)
    VIS.detectedBeats = VIS.detectedBeats.filter(b => b.time >= cullBefore);
  if (VIS.energySamples.length && VIS.energySamples[0].time < cullBefore)
    VIS.energySamples = VIS.energySamples.filter(s => s.time >= cullBefore);
  if (VIS.bpmSamples.length && VIS.bpmSamples[0].time < cullBefore)
    VIS.bpmSamples = VIS.bpmSamples.filter(s => s.time >= cullBefore);
  if (VIS.markers.length && VIS.markers[0].time < cullBefore)
    VIS.markers = VIS.markers.filter(m => m.time >= cullBefore);
  if (VIS.stateSamples.length && VIS.stateSamples[0].t0 < cullBefore - 2)
    VIS.stateSamples = VIS.stateSamples.filter(s => s.t0 >= cullBefore - 2);
}

// =========================
// Wiring
// =========================
function init() {
  el.btnPlay    = getButtonAndAddAction('btnPlay',    actionPlay);
  el.btnPause   = getButtonAndAddAction('btnPause',   actionPause);
  el.btnStop    = getButtonAndAddAction('btnStop',    actionStop);
  el.btnAcquire = getButtonAndAddAction('btnAcquire', actionAcquire);
  el.btnTrack   = getButtonAndAddAction('btnTrack',   actionTrack);
  el.btnMute    = getButtonAndAddAction('btnMute',    actionMuteToggle);
  el.btnTap     = getButtonAndAddAction('btnTap',     actionTapTempo);

  el.btnNudgeMinus = getButtonAndAddAction('btnNudgeMinus', () => nudgeTicks(-10));
  el.btnNudgePlus  = getButtonAndAddAction('btnNudgePlus',  () => nudgeTicks(+10));

  el.bpmDisplay = document.getElementById('bpmDisplay');
  el.bpmDisplay.addEventListener('input', e => {
    let s = e.target.value.replace(/[^0-9.]/g, '');
    const d = s.indexOf('.');
    if (d >= 0) s = s.slice(0, d+1) + s.slice(d+1).replace(/\./g, '');
    e.target.value = s.slice(0, 5);
  });
  el.bpmDisplay.addEventListener('change', e => {
    actionSetBPM(e.target.value);
    e.target.value = fmtBpm(bpm);
  });

  el.lockLamp   = document.getElementById('lockLamp');
  el.statusText = document.getElementById('statusText');
  el.errMs      = document.getElementById('errMs');
  el.floorV     = document.getElementById('floorV');
  el.eV         = document.getElementById('eV');
  el.offsetMs   = document.getElementById('offsetMs');

  document.body.addEventListener('keydown', actionKeyDown);

  setBpmDisplay(bpm);
  hardResetFollowerState();
  ensureStoppedUI();
  requestAnimationFrame(drawVis);
}

// Boot
init();
</script>

<div style="height: 120vh;"></div>

<div id="helpSection" style="padding: 1vh 1vw; font-size: 2vh;">
Buttons &amp; keys:
<table style="border-collapse:collapse; font-size:inherit;">
<tr><th style="text-align:left;padding:0.3em 1em 0.3em 0">Button</th><th style="text-align:left;padding:0.3em 1em 0.3em 0">Key</th><th style="text-align:left;padding:0.3em 0">Action</th></tr>
<tr><td>‚ñ∂Ô∏è Play</td><td><b>SPACE</b></td><td>From IDLE: start playing ticks at current BPM (no mic)</td></tr>
<tr><td>‚è∏ Pause</td><td><b>P</b></td><td>Pause / resume</td></tr>
<tr><td>‚èπ Stop</td><td><b>SPACE</b></td><td>Stop everything and return to IDLE</td></tr>
<tr><td>‚ö° Acquire</td><td><b>A</b></td><td>Open mic, listen for beats to estimate BPM; from LOCKED, re-acquires while ticks continue</td></tr>
<tr><td>üéØ Track</td><td><b>R</b></td><td>Open mic and phase-track at current BPM (from IDLE); commit estimate (from ACQUIRE); force lock (from TRACK); re-open mic (from LOCKED)</td></tr>
<tr><td>üîä Sound</td><td><b>M</b></td><td>Mute / unmute tick output</td></tr>
<tr><td>üïí Tap Tempo</td><td><b>T</b></td><td>Tap to set BPM; takes effect immediately if playing</td></tr>
<tr><td>nudge ¬±10ms</td><td><b>[ / ]</b></td><td>Shift tick schedule earlier/later by 10ms (TRACK/LOCKED)</td></tr>
<tr><td>BPM display</td><td><b>- / +</b></td><td>Edit BPM directly or step by 5; takes effect immediately if playing</td></tr>
</table>

State machine:
<ul>
  <li><b>IDLE ‚ÜíA‚Üí ACQUIRE</b>: mic opens, collects beats to estimate BPM</li>
  <li><b>IDLE ‚ÜíR‚Üí TRACK</b>: mic opens, plays at current BPM, phase-adjusts to mic</li>
  <li><b>IDLE ‚ÜíSPACE‚Üí LOCKED</b>: plays at current BPM immediately (no mic)</li>
  <li><b>ACQUIRE ‚Üíauto‚Üí TRACK</b>: after 4 consistent beats detected</li>
  <li><b>ACQUIRE ‚ÜíR‚Üí LOCKED</b>: commit current estimate early</li>
  <li><b>ACQUIRE ‚Üíauto‚Üí IDLE</b>: timeout after 20 s</li>
  <li><b>TRACK ‚Üíauto‚Üí LOCKED</b>: after phase stabilises or 8 beats seen</li>
  <li><b>TRACK ‚ÜíR‚Üí LOCKED</b>: force lock now</li>
  <li><b>LOCKED ‚ÜíR‚Üí TRACK</b>: re-open mic, resume phase-adjustment</li>
  <li><b>LOCKED ‚ÜíA‚Üí ACQUIRE</b>: re-open mic, re-collect (ticks keep playing)</li>
  <li><b>any ‚ÜíSPACE‚Üí IDLE</b>: stop everything</li>
</ul>

Canvas:
<ul>
  <li>Filled blue diamonds = detected beats; BPM estimate above, phase error below (when tracking).</li>
  <li>Empty orange diamonds = predicted future beats; grey = predicted past.</li>
  <li>State band: gray IDLE, yellow ACQUIRE, red TRACK, green LOCKED; state name is shown to the right of the ‚Äúnow‚Äù line.</li>
  <li>Bar graph = energy ratio (relative to floor); red bars = triggered beat.</li>
</ul>

TODO (next):
<ul>
  <li>Fix tone detection for tracking (single tone first; listen for the end).</li>
  <li>Then add multiple carrier frequencies / staggered schedule.</li>
</ul>
</div>
</body>
</html>
