<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RiffHound Rhythm Buddy v0.2</title>
<style>
  body { font-family: sans-serif; background: #fff; color: #000; margin: 0; }
  #top { display: flex; flex-wrap: nowrap; gap: 1vh; padding: 1vh; background: #eee; align-items: stretch; }
  #top button { flex: 1 1 0; font-size: 3.2vh; padding: 1.2vh 1vw; }
  button { cursor: pointer; border: 1px solid #bbb; }

  /* Top row buttons: blue by default, green when playing */
  #top button { background: #8389ff; color: #fff; border: 1px solid #8389ff; }
  body.playing #top button { background: #007700; color: #fff; border: 1px solid #007700; }

  /* Play: green when not playing, neutral when playing */
  #top #btnPlay { background: #007700; color: #fff; border: 1px solid #007700; }
  body.playing #top #btnPlay { background: #f4f4f4; color: #000; border: 1px solid #bbb; }

  /* Stop: neutral when stopped, red when playing */
  #top #btnStop { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnStop { background: #770000; color: #fff; border: 1px solid #770000; }

  /* Pause: yellow when paused */
  #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }
  body.playing #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }

  /* Mute button active: yellow */
  #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  body.playing #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }

  /* Neutral buttons */
  #top #btnTap, #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnTap, body.playing #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }

  button.flash { background: #4CAF50; color: #fff; }

  /* BPM display: 5 chars with decimal */
  #bpmDisplay {
    font-size: 5.5vh;
    font-weight: bold;
    padding: 0.5vh 0.3vw;
    background: #f4f4f4;
    border: 1px solid #bbb;
    border-radius: 4px;
    width: 5.2ch;
    text-align: center;
    box-sizing: border-box;
  }

  /* Status area */
  #statusBar{
    padding: 0.8vh 1vw;
    background:#f8f8f8;
    border-top:1px solid #ddd;
    font-size: 2.2vh;
    display:flex;
    gap: 2vw;
    flex-wrap: wrap;
    align-items: baseline;
  }
  #lockLamp{
    display:inline-block;
    padding: 0.3vh 0.9vw;
    border:1px solid #bbb;
    border-radius: 999px;
    background:#eee;
    font-weight:700;
  }
  body.listening #lockLamp{
    background:#ffcc00;
    color:#000;
    border-color:#ccaa00;
  }
  body.tracking #lockLamp{
    background:#ff3333;
    color:#fff;
    border-color:#ff3333;
  }
  body.locked #lockLamp{
    background:#0a0;
    color:#fff;
    border-color:#0a0;
  }

  #mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    white-space: nowrap;
  }

  #visCanvas {
    display: block;
    width: 100%;
    height: 75vh;
    border-top: 1px solid #ddd;
  }

  /* Little adjustment buttons in the status bar */
  #adjBox { display:flex; gap: 0.7vw; align-items:center; }
  #adjBox button { font-size: 2.0vh; padding: 0.3vh 0.7vw; background:#f4f4f4; color:#000; border:1px solid #bbb; }
  #adjBox button:active { transform: translateY(1px); }

  /* Detector tuning panel */
  #detectorPanel {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5vh 2vw;
    padding: 0.5vh 1vw;
    background: #e4e4e4;
    border-top: 1px solid #ccc;
    font-size: 1.6vh;
    align-items: center;
  }
  #detectorPanel .dpLabel { color:#444; white-space:nowrap; }
  #detectorPanel input[type=range] { width: 11vw; vertical-align: middle; }
  #detectorPanel .dpVal {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    min-width: 6ch;
    display: inline-block;
    font-size: 1.5vh;
    color: #000;
  }
</style>
</head>
<body>
  <div id="top">
    <button id="btnPlay"   class="primary">‚ñ∂Ô∏è Play</button>
    <button id="btnPause">‚è∏ Pause</button>
    <button id="btnStop"   class="danger stopped">‚èπ Stop</button>
    <button id="btnAcquire">‚ö°Acquire</button>
    <button id="btnTrack">üéØ Track</button>
    <button id="btnMute"   class="mute">üîä Sound</button>
    <button id="btnTap">üïí Tap Tempo</button>
    <input id="bpmDisplay" type="text" value="110.0" maxlength="5">
  </div>

  <div id="statusBar">
    <div style="padding: 1vh 1vw;">
      <button id="btnHelp" onclick="document.getElementById('helpSection').scrollIntoView({behavior:'smooth'})">Help ‚Üì</button>
    </div>

    <span id="lockLamp">IDLE</span>
    <span id="statusText"></span>

    <span id="adjBox">
      <span style="opacity:0.7">nudge:</span>
      <button id="btnNudgeMinus" title="Shift ticks earlier by 10ms ([)">[ -10ms</button>
      <button id="btnNudgePlus"  title="Shift ticks later by 10ms (])">+10ms ]</button>
      <span style="opacity:0.7">offset:</span>
      <span id="offsetMs">0</span><span style="opacity:0.7">ms</span>
    </span>
  </div>

  <div id="detectorPanel">
    <span class="dpLabel">Threshold</span>
    <input type="range" id="slThresh" min="1.5" max="20" step="0.5" value="3">
    <span class="dpVal" id="lblThresh">3.0√ó</span>

    <span class="dpLabel">Refractory</span>
    <input type="range" id="slRefractory" min="50" max="600" step="10" value="120">
    <span class="dpVal" id="lblRefractory">120ms</span>

    <span class="dpLabel">HP cutoff</span>
    <input type="range" id="slHPFreq" min="40" max="800" step="10" value="700">
    <span class="dpVal" id="lblHPFreq">700Hz</span>

    <span class="dpLabel">Floor fall</span>
    <input type="range" id="slFloorFall" min="1" max="10" step="1" value="5">
    <span class="dpVal" id="lblFloorFall">0.015</span>

    <span class="dpLabel">Floor rise</span>
    <input type="range" id="slFloorRise" min="1" max="10" step="1" value="3">
    <span class="dpVal" id="lblFloorRise">0.002</span>
  </div>

  <canvas id="visCanvas"></canvas>

<script>
// =========================
// Rhythm Buddy v0.2
// State machine: IDLE | ACQUIRE | TRACK | LOCKED
//
// IDLE      --A--> ACQUIRE   (start mic, collect beats)
// IDLE      --R--> TRACK     (use current BPM, start mic, play)
// IDLE   --SPACE-> LOCKED    (use current BPM, no mic, play)
// ACQUIRE   --auto-> TRACK   (4 good beats collected)
// ACQUIRE   --auto-> IDLE    (20s timeout, error)
// ACQUIRE   --R--> LOCKED    (commit estimate early)
// TRACK     --auto-> LOCKED  (phase stable OR 8 beats seen)
// TRACK     --R--> LOCKED    (force lock now)
// LOCKED    --R--> TRACK     (re-open mic, phase-adjust)
// LOCKED    --A--> ACQUIRE   (re-open mic, re-collect)
// any playing --SPACE-> IDLE (stop everything)
// =========================

let bpm = 110.0;
let playing = false;
let paused = false;
let pausedElapsed = 0;
let muted = false;
let startTime = 0;
const taps = [];

const el = {};

const ctx = new (window.AudioContext || window.webkitAudioContext)();
const master = ctx.createGain();
master.connect(ctx.destination);

// =========================
// UI helpers
// =========================
function fmtBpm(x) {
  x = Math.max(30, Math.min(300, x));
  return x.toFixed(1);
}
function setBpmDisplay(x) {
  bpm = Math.max(30, Math.min(300, x));
  el.bpmDisplay.value = fmtBpm(bpm);
  // Propagate immediately when free-running (no mic adjusting the period)
  if (BF.state === 'LOCKED') BF.period = 60 / bpm;
}
function setLamp(text) { el.lockLamp.textContent = text; }
function setStatus(msg) { el.statusText.textContent = msg; }

function setBodyFlags() {
  document.body.classList.toggle('playing',  playing);
  document.body.classList.toggle('listening', BF.active && BF.state === 'ACQUIRE');
  document.body.classList.toggle('tracking',  BF.active && BF.state === 'TRACK');
  document.body.classList.toggle('locked',    BF.state === 'LOCKED');  // mic may be off
}

// =========================
// Transport
// =========================
function tickRAF() {
  if (!playing || paused) return;
  // When mic is off (LOCKED), tickRAF owns tick scheduling
  if (!BF.active) scheduleTicks(ctx.currentTime);
  requestAnimationFrame(tickRAF);
}

function ensurePlayingUI() {
  if (playing) return;
  playing = true;
  startTime = ctx.currentTime + 0.03;
  el.btnPlay.classList.add('playing');
  el.btnStop.classList.remove('stopped');
  setBodyFlags();
  updateMuteButton();
  requestAnimationFrame(tickRAF);
}

function ensureStoppedUI() {
  playing = false;
  paused = false;
  pausedElapsed = 0;
  el.btnPause.classList.remove('paused');
  el.btnPlay.classList.remove('playing');
  el.btnStop.classList.add('stopped');
  setBodyFlags();
  updateMuteButton();
}

// =========================
// Tick sound
// =========================
function playTick(atTime, accent=false) {
  if (muted) return;
  const osc = ctx.createOscillator();
  const g   = ctx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(accent ? 1320 : 990, atTime);
  g.gain.setValueAtTime(0.0001, atTime);
  g.gain.exponentialRampToValueAtTime(accent ? 0.25 : 0.18, atTime + 0.0015);
  g.gain.exponentialRampToValueAtTime(0.0001, atTime + 0.030);
  osc.connect(g); g.connect(master);
  osc.start(atTime);
  osc.stop(atTime + 0.040);
}

// =========================
// Beat follower state
// =========================
const BF = {
  active: false,
  state: 'IDLE',

  stream: null, src: null, hp: null, analyser: null, buf: null, freqBuf: null,

  // detector (short/long energy ratio, Option B)
  eShort: 0, eLong: 0, ePeak: 0, ePrev: 0,
  threshMul: 3.0, refractoryBase: 0.12, lastTrig: -1e9,

  // tunable detector params (wired to UI sliders)
  hpFreq: 700,            // highpass cutoff Hz
  floorFallAlpha: 0.015, // eLong fall rate (e < eLong)
  floorRiseAlpha: 0.002, // eLong rise rate (e > eLong, capped)

  // acquisition
  acquireStart: 0.0, events: [], estPeriod: null, estBpm: null,

  // clock  (nextTick = -1 means "not yet set")
  period: 60/110, t0: 0.0, nextTick: -1.0, lookahead: 0.20,

  // tracking
  alpha: 0.14, errAbsHist: [], lockWindow: 12, lockMedMs: 22.0,
  trackBeatCount: 0,

  // manual nudge (display-only; ticks are shifted by adjusting t0/nextTick)
  manualOffsetSec: 0.0,

  lastBeatSeen: -1e9, maxAcquireSec: 20.0,
};

function resetFollowerUI() {
  el.offsetMs.textContent = '0';
  setLamp('IDLE');
  setStatus('');
  setBodyFlags();
}

function hardResetFollowerState() {
  BF.state = 'IDLE';
  BF.events = []; BF.estPeriod = null; BF.estBpm = null;
  BF.eShort = 0; BF.eLong = 0; BF.ePeak = 0; BF.ePrev = 0; BF.lastTrig = -1e9;
  BF.errAbsHist = []; BF.lastBeatSeen = -1e9;
  BF.trackBeatCount = 0;
  BF.nextTick = -1.0;
  BF.t0 = 0.0;
  BF.manualOffsetSec = 0.0;
  VIS.onStateChange('IDLE', ctx.currentTime);
  resetFollowerUI();
}

function median(arr) {
  const a = arr.slice().sort((x,y)=>x-y);
  const n = a.length;
  if (!n) return NaN;
  return (n % 2) ? a[n>>1] : 0.5*(a[(n>>1)-1] + a[n>>1]);
}
function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

// =========================
// Mic management
// =========================
function stopMicHardware() {
  if (BF.src)      { try { BF.src.disconnect();     } catch(_) {} }
  if (BF.hp)       { try { BF.hp.disconnect();      } catch(_) {} }
  if (BF.analyser) { try { BF.analyser.disconnect();} catch(_) {} }
  BF.src = null; BF.hp = null; BF.analyser = null; BF.buf = null;
  if (BF.stream) { for (const t of BF.stream.getTracks()) t.stop(); }
  BF.stream = null;
  BF.active = false;
}

async function openMic() {
  const constraints = {
    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
  };
  BF.stream = await navigator.mediaDevices.getUserMedia(constraints);
  BF.src = ctx.createMediaStreamSource(BF.stream);

  BF.hp = ctx.createBiquadFilter();
  BF.hp.type = 'highpass';
  BF.hp.frequency.value = BF.hpFreq;
  BF.hp.Q.value = 0.707;

  BF.analyser = ctx.createAnalyser();
  BF.analyser.fftSize = 2048;
  BF.buf     = new Float32Array(BF.analyser.fftSize);
  BF.freqBuf = new Uint8Array(BF.analyser.frequencyBinCount);

  BF.src.connect(BF.hp);
  BF.hp.connect(BF.analyser);
  BF.active = true;
}

// Full stop: mic off, state IDLE, stop playing
function stopEverything() {
  VIS.frozenNow = ctx.currentTime;
  stopMicHardware();
  hardResetFollowerState();
  ensureStoppedUI();
}

// =========================
// Transition to LOCKED
// =========================
function transitionToLocked() {
  BF.state = 'LOCKED';
  VIS.onStateChange('LOCKED', ctx.currentTime);
  setLamp('LOCKED');
  setStatus(`Locked. ${fmtBpm(60/BF.period)} BPM.`);
  setBodyFlags();
  ensurePlayingUI();
}

// =========================
// Beat detector ‚Äî Option B: short/long energy ratio + onset gate
// =========================
function currentRefractory() {
  if (BF.state === 'TRACK' || BF.state === 'LOCKED')
    return clamp(0.40 * BF.period, 0.08, 0.25);
  return BF.refractoryBase;
}

// Mean absolute value: frequency-flat amplitude measure.
// Captures all content proportionally (unlike diff-RMS which over-emphasises HF).
function computeMAV(buf) {
  let sum = 0.0;
  for (let i = 0; i < buf.length; i++) sum += Math.abs(buf[i]);
  return sum / buf.length;
}

function detectBeat(now) {
  if (!BF.analyser) return null;

  BF.analyser.getFloatTimeDomainData(BF.buf);

  const e    = computeMAV(BF.buf);
  const ePrev = BF.eShort;   // previous frame ‚Äî used for onset gate
  BF.eShort  = e;

  // Long-term EMA = noise floor (eLong).
  // Rise slowly (capped at 1.5√ó to resist beat-induced drift).
  // Fall faster so silence after a loud section restores sensitivity quickly.
  if (BF.eLong <= 0) {
    BF.eLong = e;
    BF.ePeak = e;
  } else {
    if (e < BF.eLong) {
      const fa = BF.floorFallAlpha;
      BF.eLong = BF.eLong * (1 - fa) + e * fa;
    } else {
      const ra  = BF.floorRiseAlpha;
      const cap = Math.min(e, BF.eLong * 1.5);
      BF.eLong  = BF.eLong * (1 - ra) + cap * ra;
    }
    BF.ePeak = Math.max(BF.ePeak * 0.993, e);        // slow-decaying peak follower
  }

  VIS.energySamples.push({time: now, eShort: e, eLong: BF.eLong, ePeak: BF.ePeak});

  // Spectrum snapshot ‚Äî sample SPEC_BINS evenly across the full frequency range
  if (BF.freqBuf) {
    BF.analyser.getByteFrequencyData(BF.freqBuf);
    const bins = new Uint8Array(SPEC_BINS);
    const step = BF.analyser.frequencyBinCount / SPEC_BINS;
    for (let i = 0; i < SPEC_BINS; i++)
      bins[i] = BF.freqBuf[Math.floor(i * step)];
    VIS.specSamples.push({time: now, bins});
  }

  const enoughTime = (now - BF.lastTrig) > currentRefractory();
  // Ratio trigger: energy well above the long-term background
  const ratio  = BF.eLong > 0 ? e / BF.eLong : 0;
  const above  = ratio > BF.threshMul;
  // Onset gate: energy must be rising ‚Äî prevents re-triggering on sustained high energy
  const rising = e > ePrev;

  if (enoughTime && above && rising) {
    BF.lastTrig = now; BF.lastBeatSeen = now;
    return now;
  }
  return null;
}

// =========================
// ACQUIRE: collect beats ‚Üí auto-promote to TRACK
// =========================
function updateAcquireEstimate() {
  if (BF.events.length < 2) return;
  const t = BF.events, n = t.length;
  const dts = [];
  for (let i = Math.max(1, n-6); i < n; i++) dts.push(t[i] - t[i-1]);
  const minT = 60/240, maxT = 60/40;
  const ok = dts.filter(dt => dt >= minT && dt <= maxT);
  if (!ok.length) return;
  const T = median(ok);
  BF.estPeriod = T;
  BF.estBpm = 60/T;

  setBpmDisplay(BF.estBpm);

  setLamp('ACQUIRE');
  setStatus(`Estimating‚Ä¶ ~${fmtBpm(BF.estBpm)} BPM (${BF.events.length} beats).`);
}

function tryPromoteToTrackFromAcquire() {
  if (BF.events.length < 4) return false;
  const t = BF.events, n = t.length;
  const dts = [t[n-1]-t[n-2], t[n-2]-t[n-3], t[n-3]-t[n-4]];
  const minT = 60/240, maxT = 60/40;
  if (dts.some(dt => dt < minT || dt > maxT)) return false;
  const T = median(dts);
  if (Math.max(...dts.map(dt => Math.abs(dt-T))) > 0.060) return false;

  BF.period = T;
  BF.t0 = t[n-1];
  BF.nextTick = BF.t0 + BF.period;
  BF.trackBeatCount = 0;
  setBpmDisplay(60 / BF.period);

  BF.state = 'TRACK';
  VIS.onStateChange('TRACK', ctx.currentTime);
  BF.errAbsHist = [];
  setLamp('TRACK');
  setStatus(`Tracking‚Ä¶ ${fmtBpm(60/BF.period)} BPM.`);
  setBodyFlags();
  ensurePlayingUI();
  return true;
}

// =========================
// TRACK: phase correction ‚Üí auto-lock after 8 beats or stable phase
// =========================
function phaseError(tBeat) {
  const T = BF.period;
  let ph = (tBeat - BF.t0) % T;
  if (ph < 0) ph += T;
  if (ph > T/2) ph -= T;
  return ph;
}

function onBeatDetected(tBeat) {
  if (BF.state === 'ACQUIRE') {
    BF.events.push(tBeat);
    if (BF.events.length > 16) BF.events.shift();
    updateAcquireEstimate();
    VIS.detectedBeats.push({time: tBeat, bpm: BF.estBpm, errMs: null});
    if (BF.estBpm != null) VIS.bpmSamples.push({time: tBeat, bpm: BF.estBpm, errMs: null});
    tryPromoteToTrackFromAcquire();
    return;
  }

  if (BF.state === 'TRACK') {
    const err = phaseError(tBeat);
    VIS.detectedBeats.push({time: tBeat, bpm: 60 / BF.period, errMs: err * 1000});
    VIS.bpmSamples.push({time: tBeat, bpm: 60 / BF.period, errMs: err * 1000});

    BF.t0 += BF.alpha * err;

    const now = ctx.currentTime;
    while (BF.nextTick < now + 0.01) BF.nextTick += BF.period;

    BF.trackBeatCount++;

    const errMs = Math.abs(err) * 1000.0;
    BF.errAbsHist.push(errMs);
    while (BF.errAbsHist.length > BF.lockWindow) BF.errAbsHist.shift();

    const phaseStable = BF.errAbsHist.length >= BF.lockWindow &&
                        median(BF.errAbsHist) <= BF.lockMedMs;
    const eightBeats  = BF.trackBeatCount >= 8;

    if (phaseStable || eightBeats) {
      transitionToLocked();
    }
  }
}

// =========================
// Commit: R during ACQUIRE ‚Üí LOCKED immediately
// =========================
function commitFromAcquire() {
  if (!BF.estPeriod || BF.events.length < 3) {
    setStatus('Need 3 beats.');
    return;
  }
  BF.period = BF.estPeriod;
  const last = BF.events[BF.events.length-1];
  BF.t0 = last;
  BF.nextTick = last + BF.period;
  setBpmDisplay(60 / BF.period);
  transitionToLocked();
}

// =========================
// Manual phase nudging (ticks earlier/later by 10ms)
// =========================
function nudgeTicks(deltaMs) {
  const ds = deltaMs / 1000.0;
  // Only meaningful when we have a clock
  if (!(BF.state === 'TRACK' || BF.state === 'LOCKED')) return;

  // Shift the phase reference and tick cursor together.
  BF.t0 += ds;
  BF.nextTick += ds;

  // Track accumulated offset (display only; you may choose to cap later)
  BF.manualOffsetSec += ds;
  el.offsetMs.textContent = Math.round(BF.manualOffsetSec * 1000);

  // Visual: mark a sample so you can see when you nudged
  VIS.markers.push({time: ctx.currentTime, label: (deltaMs > 0 ? '+10' : '-10')});
}

// =========================
// Tick scheduler
// =========================
let beatCount = 0;

function scheduleTicks(now) {
  if (paused) return;
  if (BF.state !== 'TRACK' && BF.state !== 'LOCKED') return;
  if (BF.nextTick < 0) return;  // not yet initialized

  // skip stale cursor (e.g. long pause) without burst
  if (BF.nextTick < now - BF.period) BF.nextTick = now;

  const horizon = now + BF.lookahead;
  while (BF.nextTick < horizon) {
    playTick(BF.nextTick, (beatCount % 4) === 0);
    beatCount++;
    BF.nextTick += BF.period;
  }
}

function beatFollowerRAF() {
  if (!BF.active) return;
  const now = ctx.currentTime;

  // ACQUIRE timeout ‚Üí IDLE
  if (BF.state === 'ACQUIRE' && (now - BF.acquireStart) > BF.maxAcquireSec) {
    setStatus('Gave up (20s).');
    VIS.frozenNow = now;
    stopMicHardware();
    hardResetFollowerState();
    ensureStoppedUI();
    return;
  }

  const trig = detectBeat(now);
  if (trig !== null) onBeatDetected(trig);

  scheduleTicks(now);
  requestAnimationFrame(beatFollowerRAF);
}

// =========================
// Actions
// =========================
async function actionAcquire() {
  await ctx.resume();
  if (BF.state === 'ACQUIRE') return; // already listening

  // Stop mic if somehow on (shouldn't happen in normal flow)
  if (BF.active) stopMicHardware();

  // Fresh start from IDLE: clear visualization and stale phase
  if (BF.state === 'IDLE') {
    VIS.detectedBeats = []; VIS.energySamples = []; VIS.bpmSamples = [];
    VIS.markers = [];
    BF.t0 = 0;
    VIS.stateSamples = [];
    VIS.onStateChange('IDLE', ctx.currentTime);
  }

  // Preserve period/nextTick so ticks continue if coming from LOCKED
  BF.state        = 'ACQUIRE';
  VIS.onStateChange('ACQUIRE', ctx.currentTime);
  BF.acquireStart = ctx.currentTime;
  BF.events       = []; BF.estPeriod = null; BF.estBpm = null;
  BF.eShort = 0; BF.eLong = 0; BF.ePeak = 0; BF.ePrev = 0; BF.lastTrig = -1e9;
  BF.errAbsHist   = []; BF.lastBeatSeen = -1e9; BF.trackBeatCount = 0;

  try {
    await openMic();
  } catch (err) {
    console.error(err);
    BF.state = 'IDLE'; BF.active = false;
    setLamp('ERROR');
    setStatus('Mic failed (permission?).');
    setBodyFlags();
    return;
  }

  setLamp('ACQUIRE');
  setStatus('Listening‚Ä¶');
  setBodyFlags();
  requestAnimationFrame(beatFollowerRAF);
}

async function actionTrack() {
  await ctx.resume();

  if (BF.state === 'IDLE') {
    // IDLE ‚Üí TRACK: use current BPM, open mic
    VIS.detectedBeats = []; VIS.energySamples = []; VIS.bpmSamples = [];
    VIS.markers = [];
    VIS.stateSamples = [];
    VIS.onStateChange('IDLE', ctx.currentTime);

    BF.period = 60 / bpm;
    BF.t0 = ctx.currentTime;
    BF.nextTick = BF.t0;
    BF.errAbsHist = []; BF.trackBeatCount = 0;
    BF.lastBeatSeen = -1e9; beatCount = 0;

    try { await openMic(); } catch (err) {
      console.error(err);
      setLamp('ERROR');
      setStatus('Mic failed (permission?).');
      setBodyFlags();
      return;
    }

    BF.state = 'TRACK';
    VIS.onStateChange('TRACK', ctx.currentTime);
    setLamp('TRACK');
    setStatus(`Tracking‚Ä¶ ${fmtBpm(bpm)} BPM.`);
    setBodyFlags();
    ensurePlayingUI();
    requestAnimationFrame(beatFollowerRAF);
    return;
  }

  if (BF.state === 'ACQUIRE') { commitFromAcquire(); return; }

  if (BF.state === 'TRACK') { transitionToLocked(); return; }

  if (BF.state === 'LOCKED') {
    BF.errAbsHist = []; BF.trackBeatCount = 0; BF.lastBeatSeen = -1e9;
    const wasActive = BF.active;

    if (!wasActive) {
      try { await openMic(); } catch (err) {
        console.error(err);
        setLamp('ERROR');
        setStatus('Mic failed (permission?).');
        setBodyFlags();
        return;
      }
    }

    BF.state = 'TRACK';
    VIS.onStateChange('TRACK', ctx.currentTime);
    setLamp('TRACK');
    setStatus(`Tracking‚Ä¶ ${fmtBpm(60/BF.period)} BPM.`);
    setBodyFlags();
    if (!wasActive) requestAnimationFrame(beatFollowerRAF);
  }
}

async function actionPlay() {
  // Direct LOCKED play at current BPM (SPACE from IDLE)
  if (playing) return;
  await ctx.resume();
  BF.period  = 60 / bpm;
  BF.t0      = ctx.currentTime;
  BF.nextTick = BF.t0;
  BF.estBpm = bpm;
  beatCount  = 0;
  BF.state   = 'LOCKED';
  VIS.stateSamples = [];
  VIS.onStateChange('LOCKED', ctx.currentTime);

  setLamp('LOCKED');
  setStatus(`Playing. ${fmtBpm(bpm)} BPM.`);
  setBodyFlags();
  ensurePlayingUI();
  scheduleTicks(ctx.currentTime);
}

function actionStop() { stopEverything(); }

function actionPause() {
  if (!playing && !BF.active) return;
  if (!paused) {
    paused = true;
    pausedElapsed = ctx.currentTime - startTime;
    el.btnPause.classList.add('paused');
    setStatus('Paused.');
  } else {
    paused = false;
    startTime = ctx.currentTime - pausedElapsed;
    el.btnPause.classList.remove('paused');
    requestAnimationFrame(tickRAF);
    setStatus('Resumed.');
  }
}

function actionMuteToggle() {
  muted = !muted;
  updateMuteButton();
  el.btnMute.classList.add('flash');
  setTimeout(() => el.btnMute.classList.remove('flash'), 150);
}

function updateMuteButton() {
  const active = muted && (playing || BF.state === 'TRACK' || BF.state === 'LOCKED');
  el.btnMute.classList.toggle('active', active);
  el.btnMute.textContent = muted ? 'üîá Muted' : 'üîä Sound';
}

function actionTapTempo() {
  const now = performance.now();
  taps.push(now);
  while (taps.length > 6) taps.shift();
  if (taps.length >= 2) {
    const diffs = taps.slice(1).map((t,i) => t - taps[i]);
    const avg   = diffs.reduce((a,b) => a+b, 0) / diffs.length;
    setBpmDisplay(clamp(60000 / avg, 30, 300));
    el.btnTap.classList.add('flash');
    setTimeout(() => el.btnTap.classList.remove('flash'), 150);
  }
}

function actionSetBPM(val) {
  const x = parseFloat(val);
  if (!Number.isFinite(x)) { el.bpmDisplay.value = fmtBpm(bpm); return; }
  setBpmDisplay(clamp(x, 30, 300));
  BF.estBpm = bpm;
}

function actionKeyDown(e) {
  if (e.code === 'Space') {
    e.preventDefault();
    if (BF.active || playing) actionStop();
    else actionPlay();
    return;
  }
  if (e.code === 'KeyA') { e.preventDefault(); actionAcquire();   return; }
  if (e.code === 'KeyR') { e.preventDefault(); actionTrack();     return; }
  if (e.code === 'KeyT') { e.preventDefault(); actionTapTempo();  return; }
  if (e.code === 'KeyP') { e.preventDefault(); actionPause();     return; }
  if (e.code === 'KeyM') { e.preventDefault(); actionMuteToggle();return; }

  // Manual tick nudges: [ and ]
  if (e.code === 'BracketLeft')  { e.preventDefault(); nudgeTicks(-10); return; }
  if (e.code === 'BracketRight') { e.preventDefault(); nudgeTicks(+10); return; }

  if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
    setBpmDisplay(clamp(Math.ceil(bpm/5)*5 - 5, 30, 300)); return;
  }
  if (e.code === 'Equal' || e.code === 'NumpadAdd') {
    setBpmDisplay(clamp(Math.floor(bpm/5)*5 + 5, 30, 300)); return;
  }
}

function getButtonAndAddAction(name, action) {
  var btn = document.getElementById(name);
  btn.addEventListener('click', action);
  return btn;
}

// =========================
// Visualization
// =========================
const VIS = {
  detectedBeats: [],
  energySamples: [],   // {time, eShort, eLong, ePeak}
  bpmSamples:    [],   // {time, bpm, errMs}
  markers:       [],   // {time, label}
  stateSamples:  [],   // [{t0, state}, ...] (segments)
  specSamples:   [],   // {time, bins: Uint8Array(SPEC_BINS)} ‚Äî spectrum snapshot
  frameSamples:  [],   // {time, dtMs} ‚Äî RAF inter-frame interval per draw call
  lastFrameRafT: null, // previous RAF timestamp (ms) for delta computation
  windowSec: 6.0,
  nowFrac:   2/3,
  frozenNow: null,

  onStateChange(state, t) {
    const last = this.stateSamples.length ? this.stateSamples[this.stateSamples.length - 1] : null;
    if (last && last.state === state) return;
    this.stateSamples.push({t0: t, state});
  }
};

// =========================
// Spectrum color LUT: 0=transparent, 50=blue, 150=red, 255=yellow
// =========================
const SPEC_BINS = 100;
const BLUE_THRESH = 50;
const RED_THRESH = 150;
const SPEC_COLORS = (() => {
  const lut = new Array(256);
  for (let v = 0; v < 256; v++) {
    if (v === 0) { lut[v] = null; continue; }
    let r, g, b, a;
    if (v < BLUE_THRESH) {
      const t = v / BLUE_THRESH;
      r = 0; g = 0; b = Math.round(255 * t); a = t;
      lut[v] = `rgba(0,0,${b},${a.toFixed(2)})`;
    } else if (v < RED_THRESH) {
      const t = (v - BLUE_THRESH) / (RED_THRESH - BLUE_THRESH);
      r = Math.round(255 * t); b = Math.round(255 * (1 - t));
      lut[v] = `rgb(${r},0,${b})`;
    } else {
      const t = (v - RED_THRESH) / (255 - RED_THRESH);
      g = Math.round(255 * t);
      lut[v] = `rgb(255,${g},0)`;
    }
  }
  return lut;
})();

function drawDiamond(cx, x, y, r, filled) {
  cx.beginPath();
  cx.moveTo(x,     y - r);
  cx.lineTo(x + r, y    );
  cx.lineTo(x,     y + r);
  cx.lineTo(x - r, y    );
  cx.closePath();
  if (filled) cx.fill();
  cx.stroke();
}

function stateColor(state) {
  if (state === 'ACQUIRE') return '#ffcc00';
  if (state === 'TRACK')   return '#ff3333';
  if (state === 'LOCKED')  return '#00aa00';
  return '#888888'; // IDLE / unknown
}

function drawVis(rafT) {
  requestAnimationFrame(drawVis);

  // Record inter-frame interval using the RAF high-res timestamp
  if (VIS.lastFrameRafT !== null && BF.state !== 'IDLE') {
    VIS.frameSamples.push({time: ctx.currentTime, dtMs: rafT - VIS.lastFrameRafT});
  }
  VIS.lastFrameRafT = rafT;

  const canvas = document.getElementById('visCanvas');
  if (!canvas) return;

  // Resize canvas buffer to match CSS size (DPR-aware)
  const dpr = window.devicePixelRatio || 1;
  const W   = canvas.offsetWidth;
  const H   = canvas.offsetHeight;
  if (W === 0 || H === 0) return;
  if (canvas.width !== W * dpr || canvas.height !== H * dpr) {
    canvas.width  = W * dpr;
    canvas.height = H * dpr;
  }

  const cx  = canvas.getContext('2d');
  cx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // In IDLE, freeze at the captured snapshot time so the canvas doesn't animate
  const now      = (BF.state === 'IDLE' && VIS.frozenNow !== null)
                   ? VIS.frozenNow : ctx.currentTime;
  const pxPerSec = W / VIS.windowSec;
  const nowX     = W * VIS.nowFrac;
  function timeToX(t) { return nowX + (t - now) * pxPerSec; }

  // Layout rows ‚Äî compressed to leave the bottom 35% for spectrum
  const detectedY   = H * 0.07;
  const predictedY  = H * 0.14;

  // State band
  const stateBandY  = H * 0.19;
  const stateBandH  = 12;

  const bpmTopY     = H * 0.23;
  const bpmBotY     = H * 0.41;
  const bpmCenterY  = (bpmTopY + bpmBotY) / 2;
  const bpmH        = bpmBotY - bpmTopY;

  const energyTopY  = H * 0.45;
  const specTopY    = H * 0.65;
  const energyH     = specTopY - energyTopY;
  const specH       = H - specTopY;

  // Time window edges
  const leftT  = now - VIS.windowSec * VIS.nowFrac;
  const rightT = now + VIS.windowSec * (1 - VIS.nowFrac);

  // Background
  cx.fillStyle = '#f8f8f8';
  cx.fillRect(0, 0, W, H);
  cx.fillStyle = '#f2f0f8';
  cx.fillRect(0, bpmTopY, W, bpmH);
  cx.fillStyle = '#efefef';
  cx.fillRect(0, energyTopY, W, energyH);
  cx.fillStyle = '#111';
  cx.fillRect(0, specTopY, W, specH);

  // --- 250ms vertical grid lines ---
  {
    const gridInterval = 0.250;
    let gridT = Math.ceil(leftT / gridInterval) * gridInterval;
    cx.strokeStyle = '#e4e4e4';
    cx.lineWidth   = 1;
    cx.setLineDash([]);
    cx.beginPath();
    while (gridT <= rightT) {
      const gx = timeToX(gridT);
      cx.moveTo(gx, 0);
      cx.lineTo(gx, H);
      gridT += gridInterval;
    }
    cx.stroke();
  }

  // Track guide lines
  cx.strokeStyle = '#d0d0d0';
  cx.lineWidth   = 1;
  cx.setLineDash([]);
  cx.beginPath();
  cx.moveTo(0, detectedY);   cx.lineTo(W, detectedY);
  cx.moveTo(0, predictedY);  cx.lineTo(W, predictedY);
  cx.moveTo(0, bpmTopY);     cx.lineTo(W, bpmTopY);
  cx.moveTo(0, energyTopY);  cx.lineTo(W, energyTopY);
  cx.stroke();

  // Track labels
  cx.fillStyle    = '#bbb';
  cx.font         = '10px sans-serif';
  cx.textAlign    = 'left';
  cx.textBaseline = 'bottom';
  cx.fillText('beats',     4, detectedY  - 3);
  cx.fillText('predicted', 4, predictedY - 3);
  cx.textBaseline = 'top';
  cx.fillText('state',     4, stateBandY - stateBandH/2 + 2);
  cx.fillText('bpm',       4, bpmTopY    + 2);
  cx.fillText('energy',    4, energyTopY + 2);

  // "Now" line
  cx.strokeStyle = '#bbb';
  cx.lineWidth   = 1;
  cx.setLineDash([4, 4]);
  cx.beginPath();
  cx.moveTo(nowX, 0);
  cx.lineTo(nowX, H);
  cx.stroke();
  cx.setLineDash([]);
  cx.fillStyle    = '#bbb';
  cx.textAlign    = 'center';
  cx.textBaseline = 'top';
  cx.fillText('now', nowX, 2);

  // --- State band over time (segment line) ---
  {
    // fill a subtle band background so it reads as "a lane"
    cx.fillStyle = '#f6f6f6';
    cx.fillRect(0, stateBandY - stateBandH/2, W, stateBandH);

    // draw segments
    if (!VIS.stateSamples.length) VIS.onStateChange(BF.state, now);

    // Determine segment endpoints within visible window
    const segs = VIS.stateSamples.slice();
    // Ensure there's a "current" segment continuing to 'now'
    const last = segs[segs.length - 1];
    if (!last || last.state !== BF.state) segs.push({t0: now, state: BF.state});

    cx.lineWidth = stateBandH - 6;
    cx.lineCap   = 'butt';

    for (let i = 0; i < segs.length; i++) {
      const s0 = segs[i];
      const s1 = (i + 1 < segs.length) ? segs[i+1] : {t0: now, state: s0.state};

      const a = Math.max(s0.t0, leftT);
      const b = Math.min(s1.t0, rightT);
      if (b <= a) continue;

      const x0 = timeToX(a);
      const x1 = timeToX(b);

      cx.strokeStyle = stateColor(s0.state);
      cx.beginPath();
      cx.moveTo(x0, stateBandY);
      cx.lineTo(x1, stateBandY);
      cx.stroke();
    }

    // State label to the right of the now line
    cx.font = 'bold 12px monospace';
    cx.textAlign = 'left';
    cx.textBaseline = 'middle';
    cx.fillStyle = stateColor(BF.state);
    cx.fillText(BF.state, nowX + 10, stateBandY);

    // Frame-time dots: one dot per drawVis call, Y = inter-frame interval.
    // Band maps 0 ms (bottom) ‚Üí 50 ms (top). 60fps target ‚âà 16.7ms ‚âà 33% up.
    const bandTop    = stateBandY - stateBandH / 2;
    const bandBot    = stateBandY + stateBandH / 2;
    const msRange    = 50;   // full band height = 50ms
    cx.fillStyle = '#000';
    for (const f of VIS.frameSamples) {
      const x = timeToX(f.time);
      if (x < 0 || x > W) continue;
      const frac = Math.min(f.dtMs / msRange, 1.0);
      const fy   = bandBot - frac * stateBandH;
      cx.beginPath();
      cx.arc(x, fy, 1.5, 0, Math.PI * 2);
      cx.fill();
    }
  }

  // --- Detected beats ---
  cx.textAlign = 'center';
  for (const b of VIS.detectedBeats) {
    const x = timeToX(b.time);
    if (x < -30 || x > W + 30) continue;

    cx.fillStyle   = '#2266ee';
    cx.strokeStyle = '#2266ee';
    cx.lineWidth   = 1.5;
    drawDiamond(cx, x, detectedY, 10, true);

    if (b.bpm != null) {
      cx.fillStyle    = '#2266ee';
      cx.font         = 'bold 12px monospace';
      cx.textBaseline = 'bottom';
      cx.fillText(b.bpm.toFixed(1), x, detectedY - 11);
    }

    if (b.errMs != null) {
      const sign = b.errMs >= 0 ? '+' : '';
      cx.fillStyle    = '#888';
      cx.font         = '11px monospace';
      cx.textBaseline = 'top';
      cx.fillText(`${sign}${b.errMs.toFixed(0)}ms`, x, detectedY + 11);
    }
  }

  // --- Predicted beats ---
  if ((BF.state === 'TRACK' || BF.state === 'LOCKED') && BF.t0 > 0 && BF.period > 0) {
    let beatT = BF.t0 + Math.ceil((leftT - BF.t0) / BF.period) * BF.period;
    while (beatT <= rightT) {
      const x = timeToX(beatT);
      if (x >= -10 && x <= W + 10) {
        cx.strokeStyle = beatT > now ? '#ee8800' : '#ccc';
        cx.lineWidth   = 1.5;
        drawDiamond(cx, x, predictedY, 10, false);
      }
      beatT += BF.period;
    }
  }

  // --- Markers (nudges) ---
  {
    cx.font = '11px monospace';
    cx.textAlign = 'center';
    cx.textBaseline = 'bottom';
    for (const m of VIS.markers) {
      const x = timeToX(m.time);
      if (x < -10 || x > W + 10) continue;
      cx.strokeStyle = '#666';
      cx.lineWidth = 1;
      cx.beginPath();
      cx.moveTo(x, 0);
      cx.lineTo(x, H * 0.08);
      cx.stroke();
      cx.fillStyle = '#666';
      cx.fillText(m.label, x, H * 0.08 - 2);
    }
  }

  // --- BPM zone ---
  {
    // Fixed 60‚Äì240 BPM range so historical points never jump
    const bpmMin = 60, bpmMax = 240;
    const bpmToY = b => bpmBotY - Math.max(0, Math.min(1, (b - bpmMin) / (bpmMax - bpmMin))) * bpmH;
    const ref100Y = bpmToY(100);

    // Edge labels: 60 at bottom, 240 at top
    cx.fillStyle    = '#bbb';
    cx.font         = '9px monospace';
    cx.textAlign    = 'right';
    cx.textBaseline = 'bottom';
    cx.fillText('240', W - 4, bpmTopY + 10);
    cx.textBaseline = 'top';
    cx.fillText('60',  W - 4, bpmBotY - 10);

    // Dashed reference line at 100 BPM
    cx.strokeStyle = '#ccc8dd';
    cx.lineWidth   = 1;
    cx.setLineDash([4, 4]);
    cx.beginPath();
    cx.moveTo(0, ref100Y); cx.lineTo(W, ref100Y);
    cx.stroke();
    cx.setLineDash([]);

    // 100 BPM label
    cx.fillStyle    = '#aaa';
    cx.font         = '10px monospace';
    cx.textAlign    = 'right';
    cx.textBaseline = 'middle';
    cx.fillText('100', W - 4, ref100Y);

    // Show current estimate (even if no points yet)
    if (BF.estBpm != null) {
      cx.strokeStyle = '#ffcc00';
      cx.lineWidth = 2;
      cx.setLineDash([6, 4]);
      cx.beginPath();
      cx.moveTo(0, bpmToY(BF.estBpm));
      cx.lineTo(W, bpmToY(BF.estBpm));
      cx.stroke();
      cx.setLineDash([]);
      cx.fillStyle = '#aa8800';
      cx.textAlign = 'right';
      cx.textBaseline = 'bottom';
      cx.font = '11px monospace';
      cx.fillText(`~${BF.estBpm.toFixed(1)}`, W - 4, bpmToY(BF.estBpm) - 2);
    }

    const visBpm = VIS.bpmSamples.filter(s => s.bpm != null);
    if (visBpm.length > 0) {
      cx.strokeStyle = '#7755bb';
      cx.lineWidth   = 1.5;
      cx.setLineDash([]);
      cx.beginPath();
      let first = true;
      for (const s of visBpm) {
        const x = timeToX(s.time);
        const y = bpmToY(s.bpm);
        if (first) { cx.moveTo(x, y); first = false; } else { cx.lineTo(x, y); }
      }
      if (BF.state === 'LOCKED') {
        cx.lineTo(nowX, bpmToY(60 / BF.period));
      }
      cx.stroke();

      for (const s of visBpm) {
        const x = timeToX(s.time);
        const y = bpmToY(s.bpm);

        cx.fillStyle = '#7755bb';
        cx.beginPath();
        cx.arc(x, y, 3, 0, Math.PI * 2);
        cx.fill();

        if (s.errMs != null) {
          const tickH = Math.max(-bpmH * 0.45, Math.min(bpmH * 0.45,
                        s.errMs * (bpmH * 0.45) / 50));
          cx.strokeStyle = Math.abs(s.errMs) > 30 ? '#cc5544' : '#9988cc';
          cx.lineWidth   = 1.5;
          cx.beginPath();
          cx.moveTo(x, ref100Y);
          cx.lineTo(x, ref100Y - tickH);
          cx.stroke();
        }
      }
    }
  }

  // --- Energy zone: absolute log scale, 5 decades (1e-5 ‚Üí 1.0) ---
  {
    const logMin = 1e-5, logMax = 1.0;
    const logSpan = Math.log10(logMax / logMin);  // = 5
    function eToY(val) {
      if (val <= 0) return specTopY;
      const frac = Math.max(0, Math.min(1,
        (Math.log10(val) - Math.log10(logMin)) / logSpan));
      return specTopY - frac * energyH;
    }

    // Decade grid lines + labels
    cx.lineWidth = 1;
    cx.setLineDash([]);
    for (let exp = -5; exp <= 0; exp++) {
      const y = eToY(Math.pow(10, exp));
      cx.strokeStyle = 'rgba(0,0,0,0.12)';
      cx.beginPath(); cx.moveTo(0, y); cx.lineTo(W, y); cx.stroke();
      cx.fillStyle = 'rgba(0,0,0,0.35)';
      cx.font = '9px monospace';
      cx.textAlign = 'left';
      cx.textBaseline = 'bottom';
      cx.fillText(`1e${exp}`, 2, y - 1);
    }

    // eShort bars (green = below threshold, red = above)
    for (const s of VIS.energySamples) {
      const x = timeToX(s.time);
      if (x < 0 || x > W) continue;
      const y = eToY(s.eShort);
      cx.fillStyle = s.eShort > s.eLong * BF.threshMul ? '#dd4444' : '#44aa66';
      cx.fillRect(x - 1.5, y, 3, specTopY - y);
    }

    // eLong line (noise floor, blue)
    {
      cx.strokeStyle = '#2288ff';
      cx.lineWidth = 1.5;
      cx.setLineDash([]);
      cx.beginPath();
      let first = true;
      for (const s of VIS.energySamples) {
        const x = timeToX(s.time);
        if (x < 0 || x > W) continue;
        const y = eToY(s.eLong);
        if (first) { cx.moveTo(x, y); first = false; } else cx.lineTo(x, y);
      }
      cx.stroke();
    }

    // Threshold line = eLong √ó threshMul (dashed red polyline)
    {
      cx.strokeStyle = 'rgba(200,60,60,0.8)';
      cx.lineWidth = 1;
      cx.setLineDash([5, 4]);
      cx.beginPath();
      let first = true;
      for (const s of VIS.energySamples) {
        const x = timeToX(s.time);
        if (x < 0 || x > W) continue;
        const y = eToY(s.eLong * BF.threshMul);
        if (first) { cx.moveTo(x, y); first = false; } else cx.lineTo(x, y);
      }
      cx.stroke();
      cx.setLineDash([]);
      // right-edge label
      if (BF.eLong > 0) {
        const ty = eToY(BF.eLong * BF.threshMul);
        cx.fillStyle = 'rgba(200,60,60,0.9)';
        cx.font = '9px monospace';
        cx.textAlign = 'right';
        cx.textBaseline = 'bottom';
        cx.fillText(`thresh √ó${BF.threshMul.toFixed(1)}`, W - 4, ty - 1);
      }
    }

    // ePeak line (dashed grey, horizontal at current peak)
    if (BF.ePeak > 0) {
      const py = eToY(BF.ePeak);
      cx.strokeStyle = 'rgba(100,100,100,0.45)';
      cx.lineWidth = 1;
      cx.setLineDash([2, 6]);
      cx.beginPath(); cx.moveTo(0, py); cx.lineTo(W, py); cx.stroke();
      cx.setLineDash([]);
      cx.fillStyle = 'rgba(100,100,100,0.7)';
      cx.font = '9px monospace';
      cx.textAlign = 'right';
      cx.textBaseline = 'top';
      cx.fillText('peak', W - 4, py + 1);
    }

    // Numeric readout bottom-right
    cx.fillStyle = '#888';
    cx.font = '9px monospace';
    cx.textAlign = 'right';
    cx.textBaseline = 'bottom';
    cx.fillText(
      `e=${BF.eShort.toExponential(2)}  fl=${BF.eLong.toExponential(2)}  thr=${(BF.eLong*BF.threshMul).toExponential(2)}`,
      W - 4, specTopY - 2);
  }

  // --- Spectrum (spectrogram, dark background, heat-map color) ---
  // Bin 0 = lowest freq at bottom (specTopY + specH), bin 99 = highest at top (specTopY).
  {
    const binH = specH / SPEC_BINS;
    for (const s of VIS.specSamples) {
      const x = timeToX(s.time);
      if (x < 0 || x > W) continue;
      for (let i = 0; i < SPEC_BINS; i++) {
        const v = s.bins[i];
        if (v === 0) continue;
        const color = SPEC_COLORS[v];
        if (!color) continue;
        cx.fillStyle = color;
        const y = specTopY + (SPEC_BINS - 1 - i) * binH;
        cx.fillRect(x - 1.5, y, 3, binH + 0.5); // +0.5 to avoid gaps
      }
    }

    // Y-axis frequency labels (approximate Hz, log-ish at Nyquist/SPEC_BINS scale)
    cx.fillStyle = 'rgba(255,255,255,0.45)';
    cx.font = '9px monospace';
    cx.textAlign = 'left';
    const sampleRate = ctx.sampleRate || 44100;
    const hzPerBin  = (sampleRate / 2) / BF.analyser.frequencyBinCount;
    const labelBins = [0, 10, 25, 50, 75, 99];
    for (const bi of labelBins) {
      const freqHz = Math.round(Math.floor(bi * BF.analyser.frequencyBinCount / SPEC_BINS) * hzPerBin);
      const y = specTopY + (SPEC_BINS - 1 - bi) * binH;
      cx.textBaseline = bi === 0 ? 'top' : 'bottom';
      cx.fillText(freqHz >= 1000 ? `${(freqHz/1000).toFixed(1)}k` : `${freqHz}`, 2, y + (bi === 0 ? 1 : -1));
    }
  }

  // Cull data older than the visible window
  const cullBefore = now - VIS.windowSec - 0.5;
  if (VIS.detectedBeats.length && VIS.detectedBeats[0].time < cullBefore)
    VIS.detectedBeats = VIS.detectedBeats.filter(b => b.time >= cullBefore);
  if (VIS.energySamples.length && VIS.energySamples[0].time < cullBefore)
    VIS.energySamples = VIS.energySamples.filter(s => s.time >= cullBefore);
  if (VIS.bpmSamples.length && VIS.bpmSamples[0].time < cullBefore)
    VIS.bpmSamples = VIS.bpmSamples.filter(s => s.time >= cullBefore);
  if (VIS.markers.length && VIS.markers[0].time < cullBefore)
    VIS.markers = VIS.markers.filter(m => m.time >= cullBefore);
  // Cull state segments by END time (= next segment's t0), not start time.
  // A segment whose end time is before the visible window can be dropped,
  // but keep the segment that started before cullBefore if it's still active.
  if (VIS.stateSamples.length > 1)
    VIS.stateSamples = VIS.stateSamples.filter((s, i, arr) =>
      i === arr.length - 1 || arr[i + 1].t0 >= cullBefore);
  if (VIS.frameSamples.length && VIS.frameSamples[0].time < cullBefore)
    VIS.frameSamples = VIS.frameSamples.filter(f => f.time >= cullBefore);
  if (VIS.specSamples.length && VIS.specSamples[0].time < cullBefore)
    VIS.specSamples = VIS.specSamples.filter(s => s.time >= cullBefore);
}

// =========================
// Wiring
// =========================
function init() {
  el.btnPlay    = getButtonAndAddAction('btnPlay',    actionPlay);
  el.btnPause   = getButtonAndAddAction('btnPause',   actionPause);
  el.btnStop    = getButtonAndAddAction('btnStop',    actionStop);
  el.btnAcquire = getButtonAndAddAction('btnAcquire', actionAcquire);
  el.btnTrack   = getButtonAndAddAction('btnTrack',   actionTrack);
  el.btnMute    = getButtonAndAddAction('btnMute',    actionMuteToggle);
  el.btnTap     = getButtonAndAddAction('btnTap',     actionTapTempo);

  el.btnNudgeMinus = getButtonAndAddAction('btnNudgeMinus', () => nudgeTicks(-10));
  el.btnNudgePlus  = getButtonAndAddAction('btnNudgePlus',  () => nudgeTicks(+10));

  el.bpmDisplay = document.getElementById('bpmDisplay');
  el.bpmDisplay.addEventListener('input', e => {
    let s = e.target.value.replace(/[^0-9.]/g, '');
    const d = s.indexOf('.');
    if (d >= 0) s = s.slice(0, d+1) + s.slice(d+1).replace(/\./g, '');
    e.target.value = s.slice(0, 5);
  });
  el.bpmDisplay.addEventListener('change', e => {
    actionSetBPM(e.target.value);
    e.target.value = fmtBpm(bpm);
  });

  el.lockLamp   = document.getElementById('lockLamp');
  el.statusText = document.getElementById('statusText');
  el.offsetMs   = document.getElementById('offsetMs');

  // Detector panel sliders
  // Alpha lookup tables (slider value 1‚Äì10 ‚Üí alpha)
  const fallAlphas = [0.003, 0.005, 0.008, 0.012, 0.015, 0.022, 0.032, 0.045, 0.060, 0.080];
  const riseAlphas = [0.0005, 0.001, 0.002, 0.003, 0.005, 0.007, 0.010, 0.015, 0.022, 0.030];

  el.slThresh = document.getElementById('slThresh');
  el.lblThresh = document.getElementById('lblThresh');
  el.slThresh.addEventListener('input', () => {
    BF.threshMul = parseFloat(el.slThresh.value);
    el.lblThresh.textContent = BF.threshMul.toFixed(1) + '√ó';
  });

  el.slRefractory = document.getElementById('slRefractory');
  el.lblRefractory = document.getElementById('lblRefractory');
  el.slRefractory.addEventListener('input', () => {
    BF.refractoryBase = parseInt(el.slRefractory.value) / 1000;
    el.lblRefractory.textContent = el.slRefractory.value + 'ms';
  });

  el.slHPFreq = document.getElementById('slHPFreq');
  el.lblHPFreq = document.getElementById('lblHPFreq');
  el.slHPFreq.addEventListener('input', () => {
    BF.hpFreq = parseInt(el.slHPFreq.value);
    el.lblHPFreq.textContent = BF.hpFreq + 'Hz';
    if (BF.hp) BF.hp.frequency.value = BF.hpFreq;
  });

  el.slFloorFall = document.getElementById('slFloorFall');
  el.lblFloorFall = document.getElementById('lblFloorFall');
  el.slFloorFall.addEventListener('input', () => {
    const idx = parseInt(el.slFloorFall.value) - 1;
    BF.floorFallAlpha = fallAlphas[idx];
    el.lblFloorFall.textContent = BF.floorFallAlpha.toFixed(3);
  });

  el.slFloorRise = document.getElementById('slFloorRise');
  el.lblFloorRise = document.getElementById('lblFloorRise');
  el.slFloorRise.addEventListener('input', () => {
    const idx = parseInt(el.slFloorRise.value) - 1;
    BF.floorRiseAlpha = riseAlphas[idx];
    el.lblFloorRise.textContent = BF.floorRiseAlpha.toFixed(4);
  });

  document.body.addEventListener('keydown', actionKeyDown);

  setBpmDisplay(bpm);
  hardResetFollowerState();
  ensureStoppedUI();
  requestAnimationFrame(drawVis);
}

// Boot
init();
</script>

<div style="height: 120vh;"></div>

<div id="helpSection" style="padding: 1vh 1vw; font-size: 2vh;">
Buttons &amp; keys:
<table style="border-collapse:collapse; font-size:inherit;">
<tr><th style="text-align:left;padding:0.3em 1em 0.3em 0">Button</th><th style="text-align:left;padding:0.3em 1em 0.3em 0">Key</th><th style="text-align:left;padding:0.3em 0">Action</th></tr>
<tr><td>‚ñ∂Ô∏è Play</td><td><b>SPACE</b></td><td>From IDLE: start playing ticks at current BPM (no mic)</td></tr>
<tr><td>‚è∏ Pause</td><td><b>P</b></td><td>Pause / resume</td></tr>
<tr><td>‚èπ Stop</td><td><b>SPACE</b></td><td>Stop everything and return to IDLE</td></tr>
<tr><td>‚ö° Acquire</td><td><b>A</b></td><td>Open mic, listen for beats to estimate BPM; from LOCKED, re-acquires while ticks continue</td></tr>
<tr><td>üéØ Track</td><td><b>R</b></td><td>Open mic and phase-track at current BPM (from IDLE); commit estimate (from ACQUIRE); force lock (from TRACK); re-open mic (from LOCKED)</td></tr>
<tr><td>üîä Sound</td><td><b>M</b></td><td>Mute / unmute tick output</td></tr>
<tr><td>üïí Tap Tempo</td><td><b>T</b></td><td>Tap to set BPM; takes effect immediately if playing</td></tr>
<tr><td>nudge ¬±10ms</td><td><b>[ / ]</b></td><td>Shift tick schedule earlier/later by 10ms (TRACK/LOCKED)</td></tr>
<tr><td>BPM display</td><td><b>- / +</b></td><td>Edit BPM directly or step by 5; takes effect immediately if playing</td></tr>
</table>

State machine:
<ul>
  <li><b>IDLE ‚ÜíA‚Üí ACQUIRE</b>: mic opens, collects beats to estimate BPM</li>
  <li><b>IDLE ‚ÜíR‚Üí TRACK</b>: mic opens, plays at current BPM, phase-adjusts to mic</li>
  <li><b>IDLE ‚ÜíSPACE‚Üí LOCKED</b>: plays at current BPM immediately (no mic)</li>
  <li><b>ACQUIRE ‚Üíauto‚Üí TRACK</b>: after 4 consistent beats detected</li>
  <li><b>ACQUIRE ‚ÜíR‚Üí LOCKED</b>: commit current estimate early</li>
  <li><b>ACQUIRE ‚Üíauto‚Üí IDLE</b>: timeout after 20 s</li>
  <li><b>TRACK ‚Üíauto‚Üí LOCKED</b>: after phase stabilises or 8 beats seen</li>
  <li><b>TRACK ‚ÜíR‚Üí LOCKED</b>: force lock now</li>
  <li><b>LOCKED ‚ÜíR‚Üí TRACK</b>: re-open mic, resume phase-adjustment</li>
  <li><b>LOCKED ‚ÜíA‚Üí ACQUIRE</b>: re-open mic, re-collect (ticks keep playing)</li>
  <li><b>any ‚ÜíSPACE‚Üí IDLE</b>: stop everything</li>
</ul>

Canvas:
<ul>
  <li>Filled blue diamonds = detected beats; BPM estimate above, phase error below (when tracking).</li>
  <li>Empty orange diamonds = predicted future beats; grey = predicted past.</li>
  <li>State band: gray IDLE, yellow ACQUIRE, red TRACK, green LOCKED; state name is shown to the right of the ‚Äúnow‚Äù line.</li>
  <li>Bar graph = energy ratio (relative to floor); red bars = triggered beat.</li>
</ul>

TODO (next):
<ul>
  <li>Refactor to store a global BPM estimate. Always graph the estimate. If there is no estimate, it should come from the current BPM setting. ACQUIRE computes the estimate and overwrites the "current" when it succeeds and goes to tracking. Playing overwrites the global BPM estimate with current.</li>
  <li>Fix tone detection for tracking (single tone first; listen for the end).</li>
  <li>Then add multiple carrier frequencies / staggered schedule.</li>
</ul>
</div>
</body>
</html>
