<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RiffHound Beat Follower</title>
<style>
  body { font-family: sans-serif; background: #fff; color: #000; margin: 0; }
  #top { display: flex; flex-wrap: nowrap; gap: 1vh; padding: 1vh; background: #eee; align-items: stretch; }
  #top button { flex: 1 1 0; font-size: 3.2vh; padding: 1.2vh 1vw; }
  button { cursor: pointer; border: 1px solid #bbb; }

  /* Top row buttons: blue by default, green when playing */
  #top button { background: #8389ff; color: #fff; border: 1px solid #8389ff; }
  body.playing #top button { background: #007700; color: #fff; border: 1px solid #007700; }

  /* Play: green when not playing, neutral when playing */
  #top #btnPlay { background: #007700; color: #fff; border: 1px solid #007700; }
  body.playing #top #btnPlay { background: #f4f4f4; color: #000; border: 1px solid #bbb; }

  /* Stop: neutral when stopped, red when playing */
  #top #btnStop { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnStop { background: #770000; color: #fff; border: 1px solid #770000; }

  /* Pause: yellow when paused */
  #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }
  body.playing #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }

  /* Mute button active: yellow */
  #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  body.playing #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }

  /* Neutral buttons */
  #top #btnTap, #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnTap, body.playing #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }

  /* Acquire and Track inherit the default top-row blue/green style */

  button.flash { background: #4CAF50; color: #fff; }

  /* BPM display: 5 chars with decimal */
  #bpmDisplay {
    font-size: 5.5vh;
    font-weight: bold;
    padding: 0.5vh 0.3vw;
    background: #f4f4f4;
    border: 1px solid #bbb;
    border-radius: 4px;
    width: 5.2ch;
    text-align: center;
    box-sizing: border-box;
  }

  /* Status area */
  #statusBar{
    padding: 0.8vh 1vw;
    background:#f8f8f8;
    border-top:1px solid #ddd;
    font-size: 2.2vh;
    display:flex;
    gap: 2vw;
    flex-wrap: wrap;
    align-items: baseline;
  }
  #lockLamp{
    display:inline-block;
    padding: 0.2vh 0.8vw;
    border:1px solid #bbb;
    border-radius: 999px;
    background:#eee;
    font-weight:700;
  }
  body.listening #lockLamp{
    background:#ffcc00;
    color:#000;
    border-color:#ccaa00;
  }
  body.tracking #lockLamp{
    background:#2680ff;
    color:#fff;
    border-color:#2680ff;
  }
  body.locked #lockLamp{
    background:#0a0;
    color:#fff;
    border-color:#0a0;
  }

  #mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    white-space: nowrap;
  }
</style>
</head>
<body>
  <div id="top">
    <button id="btnPlay"   class="primary">‚ñ∂Ô∏è Play</button>
    <button id="btnPause">‚è∏ Pause</button>
    <button id="btnStop"   class="danger stopped">‚èπ Stop</button>
    <button id="btnAcquire">üéô Acquire</button>
    <button id="btnTrack">üéØ Track</button>
    <button id="btnMute"   class="mute">üîä Sound</button>
    <button id="btnTap">üïí Tap Tempo</button>
    <input id="bpmDisplay" type="text" value="110.0" maxlength="5">
  </div>

  <div id="statusBar">
    <span id="lockLamp">IDLE</span>
    <span id="statusText">A: acquire   R: track   SPACE: play</span>
    <span id="mono">err: <span id="errMs">‚Äî</span> ms | floor: <span id="floorV">‚Äî</span> | e: <span id="eV">‚Äî</span></span>
  </div>

<script>
// =========================
// Beat Follower v0.3
// State machine: IDLE | ACQUIRE | TRACK | LOCKED
//
// IDLE      --A--> ACQUIRE   (start mic, collect beats)
// IDLE      --R--> TRACK     (use current BPM, start mic, play)
// IDLE   --SPACE-> LOCKED    (use current BPM, no mic, play)
// ACQUIRE   --auto-> TRACK   (4 good beats collected)
// ACQUIRE   --auto-> IDLE    (20s timeout, error)
// ACQUIRE   --R--> LOCKED    (commit estimate early)
// TRACK     --auto-> LOCKED  (phase stable OR 8 beats seen)
// TRACK     --R--> LOCKED    (force lock now)
// LOCKED    --R--> TRACK     (re-open mic, phase-adjust)
// LOCKED    --A--> ACQUIRE   (re-open mic, re-collect)
// any playing --SPACE-> IDLE (stop everything)
// =========================

let bpm = 110.0;
let playing = false;
let paused = false;
let pausedElapsed = 0;
let muted = false;
let startTime = 0;
const taps = [];

const el = {};

const ctx = new (window.AudioContext || window.webkitAudioContext)();
const master = ctx.createGain();
master.connect(ctx.destination);

// =========================
// UI helpers
// =========================
function fmtBpm(x) {
  x = Math.max(30, Math.min(300, x));
  return x.toFixed(1);
}
function setBpmDisplay(x) {
  bpm = Math.max(30, Math.min(300, x));
  el.bpmDisplay.value = fmtBpm(bpm);
}
function setLamp(text) { el.lockLamp.textContent = text; }
function setStatus(msg) { el.statusText.textContent = msg; }

function setBodyFlags() {
  document.body.classList.toggle('playing',  playing);
  document.body.classList.toggle('listening', BF.active && BF.state === 'ACQUIRE');
  document.body.classList.toggle('tracking',  BF.active && BF.state === 'TRACK');
  document.body.classList.toggle('locked',    BF.state === 'LOCKED');  // mic may be off
}

// =========================
// Transport
// =========================
function tickRAF() {
  if (!playing || paused) return;
  // When mic is off (LOCKED), tickRAF owns tick scheduling
  if (!BF.active) scheduleTicks(ctx.currentTime);
  requestAnimationFrame(tickRAF);
}

function ensurePlayingUI() {
  if (playing) return;
  playing = true;
  startTime = ctx.currentTime + 0.03;
  el.btnPlay.classList.add('playing');
  el.btnStop.classList.remove('stopped');
  setBodyFlags();
  updateMuteButton();
  requestAnimationFrame(tickRAF);
}

function ensureStoppedUI() {
  playing = false;
  paused = false;
  pausedElapsed = 0;
  el.btnPause.classList.remove('paused');
  el.btnPlay.classList.remove('playing');
  el.btnStop.classList.add('stopped');
  setBodyFlags();
  updateMuteButton();
}

// =========================
// Tick sound
// =========================
function playTick(atTime, accent=false) {
  if (muted) return;
  const osc = ctx.createOscillator();
  const g   = ctx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(accent ? 1320 : 990, atTime);
  g.gain.setValueAtTime(0.0001, atTime);
  g.gain.exponentialRampToValueAtTime(accent ? 0.25 : 0.18, atTime + 0.0015);
  g.gain.exponentialRampToValueAtTime(0.0001, atTime + 0.030);
  osc.connect(g); g.connect(master);
  osc.start(atTime);
  osc.stop(atTime + 0.040);
}

// =========================
// Beat follower state
// =========================
const BF = {
  active: false,
  state: 'IDLE',

  stream: null, src: null, hp: null, analyser: null, buf: null,

  // detector
  floor: 0.0, e: 0.0,
  threshMul: 6.0, refractoryBase: 0.12, lastTrig: -1e9,

  // acquisition
  acquireStart: 0.0, events: [], estPeriod: null, estBpm: null,

  // clock  (nextTick = -1 means "not yet set")
  period: 60/110, t0: 0.0, nextTick: -1.0, lookahead: 0.20,

  // tracking
  alpha: 0.14, errAbsHist: [], lockWindow: 12, lockMedMs: 22.0,
  trackBeatCount: 0,   // beats seen in TRACK; auto-lock after 8

  lastBeatSeen: -1e9, maxAcquireSec: 20.0,
};

function resetFollowerUI() {
  el.errMs.textContent  = '‚Äî';
  el.floorV.textContent = '‚Äî';
  el.eV.textContent     = '‚Äî';
  setLamp('IDLE');
  setStatus('A: acquire   R: track   SPACE: play');
  setBodyFlags();
}

function hardResetFollowerState() {
  BF.state = 'IDLE';
  BF.events = []; BF.estPeriod = null; BF.estBpm = null;
  BF.floor = 0.0; BF.e = 0.0; BF.lastTrig = -1e9;
  BF.errAbsHist = []; BF.lastBeatSeen = -1e9;
  BF.trackBeatCount = 0;
  BF.nextTick = -1.0;
  resetFollowerUI();
}

function median(arr) {
  const a = arr.slice().sort((x,y)=>x-y);
  const n = a.length;
  if (!n) return NaN;
  return (n % 2) ? a[n>>1] : 0.5*(a[(n>>1)-1] + a[n>>1]);
}
function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

// =========================
// Mic management
// =========================
function stopMicHardware() {
  if (BF.src)      { try { BF.src.disconnect();     } catch(_) {} }
  if (BF.hp)       { try { BF.hp.disconnect();      } catch(_) {} }
  if (BF.analyser) { try { BF.analyser.disconnect();} catch(_) {} }
  BF.src = null; BF.hp = null; BF.analyser = null; BF.buf = null;
  if (BF.stream) { for (const t of BF.stream.getTracks()) t.stop(); }
  BF.stream = null;
  BF.active = false;
}

async function openMic() {
  const constraints = {
    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
  };
  BF.stream = await navigator.mediaDevices.getUserMedia(constraints);
  BF.src = ctx.createMediaStreamSource(BF.stream);

  BF.hp = ctx.createBiquadFilter();
  BF.hp.type = 'highpass';
  BF.hp.frequency.value = 600;
  BF.hp.Q.value = 0.707;

  BF.analyser = ctx.createAnalyser();
  BF.analyser.fftSize = 2048;
  BF.buf = new Float32Array(BF.analyser.fftSize);

  BF.src.connect(BF.hp);
  BF.hp.connect(BF.analyser);
  BF.active = true;
}

// Full stop: mic off, state IDLE, stop playing
function stopEverything() {
  stopMicHardware();
  hardResetFollowerState();
  ensureStoppedUI();
}

// =========================
// Transition to LOCKED (mic off, ticks continue)
// =========================
function transitionToLocked() {
  stopMicHardware();     // mic off; beatFollowerRAF exits next frame
  BF.state = 'LOCKED';
  setLamp('LOCKED');
  setStatus(`Locked. ${fmtBpm(60/BF.period)} BPM. SPACE: stop   R: track   A: re-acquire`);
  setBodyFlags();
  ensurePlayingUI();     // tickRAF will schedule ticks (BF.active now false)
}

// =========================
// Beat detector
// =========================
function currentRefractory() {
  if (BF.state === 'TRACK' || BF.state === 'LOCKED')
    return clamp(0.40 * BF.period, 0.08, 0.25);
  return BF.refractoryBase;
}

function detectBeat(now) {
  if (!BF.analyser) return null;

  BF.analyser.getFloatTimeDomainData(BF.buf);
  let sum = 0.0, prev = BF.buf[0];
  for (let i = 1; i < BF.buf.length; i++) {
    const x = BF.buf[i];
    sum += Math.abs(x - prev);
    prev = x;
  }
  const e = sum / (BF.buf.length - 1);
  BF.e = e;

  if (BF.floor === 0.0) BF.floor = e;
  const capped = Math.min(e, BF.floor * 2.0);
  BF.floor = BF.floor * 0.99 + capped * 0.01;

  el.floorV.textContent = BF.floor.toFixed(4);
  el.eV.textContent     = BF.e.toFixed(4);

  const enoughTime = (now - BF.lastTrig) > currentRefractory();
  const above      = e > (BF.floor * BF.threshMul);

  if (enoughTime && above) {
    BF.lastTrig = now; BF.lastBeatSeen = now;
    return now;
  }
  return null;
}

// =========================
// ACQUIRE: collect beats ‚Üí auto-promote to TRACK
// =========================
function updateAcquireEstimate() {
  if (BF.events.length < 2) return;
  const t = BF.events, n = t.length;
  const dts = [];
  for (let i = Math.max(1, n-6); i < n; i++) dts.push(t[i] - t[i-1]);
  const minT = 60/240, maxT = 60/40;
  const ok = dts.filter(dt => dt >= minT && dt <= maxT);
  if (!ok.length) return;
  const T = median(ok);
  BF.estPeriod = T; BF.estBpm = 60/T;
  setBpmDisplay(BF.estBpm);
  setLamp('LISTEN');
  setStatus(`Estimating‚Ä¶ ~${fmtBpm(BF.estBpm)} BPM (${BF.events.length} beats). R to commit.`);
}

function tryPromoteToTrackFromAcquire() {
  if (BF.events.length < 4) return false;
  const t = BF.events, n = t.length;
  const dts = [t[n-1]-t[n-2], t[n-2]-t[n-3], t[n-3]-t[n-4]];
  const minT = 60/240, maxT = 60/40;
  if (dts.some(dt => dt < minT || dt > maxT)) return false;
  const T = median(dts);
  if (Math.max(...dts.map(dt => Math.abs(dt-T))) > 0.060) return false;

  BF.period = T;
  BF.t0 = t[n-1];
  BF.nextTick = BF.t0 + BF.period;
  BF.trackBeatCount = 0;
  setBpmDisplay(60 / BF.period);

  BF.state = 'TRACK';
  BF.errAbsHist = [];
  setLamp('TRACK');
  setStatus(`Tracking‚Ä¶ ${fmtBpm(60/BF.period)} BPM. Locks after 8 beats. R to lock now.`);
  setBodyFlags();
  ensurePlayingUI();
  return true;
}

// =========================
// TRACK: phase correction ‚Üí auto-lock after 8 beats or stable phase
// =========================
function phaseError(tBeat) {
  const T = BF.period;
  let ph = (tBeat - BF.t0) % T;
  if (ph < 0) ph += T;
  if (ph > T/2) ph -= T;
  return ph;
}

function onBeatDetected(tBeat) {
  if (BF.state === 'ACQUIRE') {
    BF.events.push(tBeat);
    if (BF.events.length > 16) BF.events.shift();
    updateAcquireEstimate();
    tryPromoteToTrackFromAcquire();
    return;
  }

  if (BF.state === 'TRACK') {
    const err = phaseError(tBeat);
    el.errMs.textContent = (err * 1000).toFixed(1);

    BF.t0 += BF.alpha * err;
    const now = ctx.currentTime;
    while (BF.nextTick < now + 0.01) BF.nextTick += BF.period;

    BF.trackBeatCount++;

    const errMs = Math.abs(err) * 1000.0;
    BF.errAbsHist.push(errMs);
    while (BF.errAbsHist.length > BF.lockWindow) BF.errAbsHist.shift();

    const phaseStable = BF.errAbsHist.length >= BF.lockWindow &&
                        median(BF.errAbsHist) <= BF.lockMedMs;
    const eightBeats  = BF.trackBeatCount >= 8;

    if (phaseStable || eightBeats) {
      transitionToLocked();
    }
  }
}

// =========================
// Commit: R during ACQUIRE ‚Üí LOCKED immediately
// =========================
function commitFromAcquire() {
  if (!BF.estPeriod || BF.events.length < 3) {
    setStatus('Need at least 3 beats first.');
    return;
  }
  BF.period = BF.estPeriod;
  const last = BF.events[BF.events.length-1];
  BF.t0 = last;
  BF.nextTick = last + BF.period;
  setBpmDisplay(60 / BF.period);
  transitionToLocked();
}

// =========================
// Tick scheduler
// =========================
let beatCount = 0;

function scheduleTicks(now) {
  if (paused) return;
  if (BF.state !== 'TRACK' && BF.state !== 'LOCKED' &&
      !(BF.state === 'ACQUIRE' && BF.nextTick >= 0)) return;
  if (BF.nextTick < 0) return;  // not yet initialized
  // skip stale cursor (e.g. long pause) without burst
  if (BF.nextTick < now - BF.period) BF.nextTick = now;

  const horizon = now + BF.lookahead;
  while (BF.nextTick < horizon) {
    playTick(BF.nextTick, (beatCount % 4) === 0);
    beatCount++;
    BF.nextTick += BF.period;
  }
}

function beatFollowerRAF() {
  if (!BF.active) return;
  const now = ctx.currentTime;

  // ACQUIRE timeout ‚Üí IDLE
  if (BF.state === 'ACQUIRE' && (now - BF.acquireStart) > BF.maxAcquireSec) {
    setStatus('Gave up (20s). Press A to try again.');
    stopMicHardware();
    hardResetFollowerState();
    ensureStoppedUI();
    return;
  }

  const trig = detectBeat(now);
  if (trig !== null) onBeatDetected(trig);

  scheduleTicks(now);
  requestAnimationFrame(beatFollowerRAF);
}

// =========================
// Actions
// =========================
async function actionAcquire() {
  await ctx.resume();
  if (BF.state === 'ACQUIRE' || BF.state === 'TRACK') return; // already listening

  // Stop mic if somehow on (shouldn't happen in normal flow)
  if (BF.active) stopMicHardware();

  // Preserve period/nextTick so ticks continue if coming from LOCKED
  BF.state       = 'ACQUIRE';
  BF.acquireStart = ctx.currentTime;
  BF.events      = []; BF.estPeriod = null; BF.estBpm = null;
  BF.floor       = 0.0; BF.e = 0.0; BF.lastTrig = -1e9;
  BF.errAbsHist  = []; BF.lastBeatSeen = -1e9; BF.trackBeatCount = 0;

  try {
    await openMic();
  } catch (err) {
    console.error(err);
    BF.state = 'IDLE'; BF.active = false;
    setLamp('ERROR');
    setStatus('Mic failed (permission? HTTPS/localhost?).');
    setBodyFlags();
    return;
  }

  setLamp('LISTEN');
  setStatus('Listening‚Ä¶ wait for 4 beats. R to commit early.');
  setBodyFlags();
  requestAnimationFrame(beatFollowerRAF);
}

async function actionTrack() {
  await ctx.resume();

  if (BF.state === 'IDLE') {
    // IDLE ‚Üí TRACK: use current BPM, open mic
    BF.period = 60 / bpm;
    BF.t0 = ctx.currentTime;
    BF.nextTick = BF.t0;
    BF.errAbsHist = []; BF.trackBeatCount = 0;
    BF.lastBeatSeen = -1e9; beatCount = 0;

    try { await openMic(); } catch (err) {
      console.error(err);
      setLamp('ERROR');
      setStatus('Mic failed (permission? HTTPS/localhost?).');
      setBodyFlags();
      return;
    }

    BF.state = 'TRACK';
    setLamp('TRACK');
    setStatus(`Tracking‚Ä¶ ${fmtBpm(bpm)} BPM. Locks after 8 beats. R to lock now.`);
    setBodyFlags();
    ensurePlayingUI();
    requestAnimationFrame(beatFollowerRAF);
    return;
  }

  if (BF.state === 'ACQUIRE') { commitFromAcquire(); return; }

  if (BF.state === 'TRACK') { transitionToLocked(); return; }

  if (BF.state === 'LOCKED') {
    // LOCKED ‚Üí TRACK: re-open mic
    BF.errAbsHist = []; BF.trackBeatCount = 0; BF.lastBeatSeen = -1e9;

    try { await openMic(); } catch (err) {
      console.error(err);
      setLamp('ERROR');
      setStatus('Mic failed (permission? HTTPS/localhost?).');
      setBodyFlags();
      return;
    }

    BF.state = 'TRACK';
    setLamp('TRACK');
    setStatus(`Tracking‚Ä¶ ${fmtBpm(60/BF.period)} BPM. Locks after 8 beats. R to lock now.`);
    setBodyFlags();
    requestAnimationFrame(beatFollowerRAF);
  }
}

async function actionPlay() {
  // Direct LOCKED play at current BPM (SPACE from IDLE)
  if (playing) return;
  await ctx.resume();
  BF.period  = 60 / bpm;
  BF.t0      = ctx.currentTime;
  BF.nextTick = BF.t0;
  beatCount  = 0;
  BF.state   = 'LOCKED';
  setLamp('LOCKED');
  setStatus(`Playing. ${fmtBpm(bpm)} BPM. SPACE: stop   R: track   A: acquire`);
  setBodyFlags();
  ensurePlayingUI();
  scheduleTicks(ctx.currentTime);  // kick off immediately; don't wait for RAF
}

function actionStop() { stopEverything(); }

function actionPause() {
  if (!playing && !BF.active) return;
  if (!paused) {
    paused = true;
    pausedElapsed = ctx.currentTime - startTime;
    el.btnPause.classList.add('paused');
    setStatus('Paused.');
  } else {
    paused = false;
    startTime = ctx.currentTime - pausedElapsed;
    el.btnPause.classList.remove('paused');
    requestAnimationFrame(tickRAF);
    setStatus('Resumed.');
  }
}

function actionMuteToggle() {
  muted = !muted;
  updateMuteButton();
  el.btnMute.classList.add('flash');
  setTimeout(() => el.btnMute.classList.remove('flash'), 150);
}

function updateMuteButton() {
  const active = muted && (playing || BF.state === 'TRACK' || BF.state === 'LOCKED');
  el.btnMute.classList.toggle('active', active);
  el.btnMute.textContent = muted ? 'üîá Muted' : 'üîä Sound';
}

function actionTapTempo() {
  const now = performance.now();
  taps.push(now);
  while (taps.length > 6) taps.shift();
  if (taps.length >= 2) {
    const diffs = taps.slice(1).map((t,i) => t - taps[i]);
    const avg   = diffs.reduce((a,b) => a+b, 0) / diffs.length;
    setBpmDisplay(clamp(60000 / avg, 30, 300));
    el.btnTap.classList.add('flash');
    setTimeout(() => el.btnTap.classList.remove('flash'), 150);
  }
}

function actionSetBPM(val) {
  const x = parseFloat(val);
  if (!Number.isFinite(x)) { el.bpmDisplay.value = fmtBpm(bpm); return; }
  setBpmDisplay(clamp(x, 30, 300));
}

function actionKeyDown(e) {
  if (e.code === 'Space') {
    e.preventDefault();
    if (BF.active || playing) actionStop();
    else actionPlay();
    return;
  }
  if (e.code === 'KeyA') { e.preventDefault(); actionAcquire();   return; }
  if (e.code === 'KeyR') { e.preventDefault(); actionTrack();     return; }
  if (e.code === 'KeyT') { e.preventDefault(); actionTapTempo();  return; }
  if (e.code === 'KeyP') { e.preventDefault(); actionPause();     return; }
  if (e.code === 'KeyM') { e.preventDefault(); actionMuteToggle();return; }
  if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
    setBpmDisplay(clamp(Math.ceil(bpm/5)*5 - 5, 30, 300)); return;
  }
  if (e.code === 'Equal' || e.code === 'NumpadAdd') {
    setBpmDisplay(clamp(Math.floor(bpm/5)*5 + 5, 30, 300)); return;
  }
}

function getButtonAndAddAction(name, action) {
  var btn = document.getElementById(name);
  btn.addEventListener('click', action);
  return btn;
}

// =========================
// Wiring
// =========================
function init() {
  el.btnPlay    = getButtonAndAddAction('btnPlay',    actionPlay);
  el.btnPause   = getButtonAndAddAction('btnPause',   actionPause);
  el.btnStop    = getButtonAndAddAction('btnStop',    actionStop);
  el.btnAcquire = getButtonAndAddAction('btnAcquire', actionAcquire);
  el.btnTrack   = getButtonAndAddAction('btnTrack',   actionTrack);
  el.btnMute    = getButtonAndAddAction('btnMute',    actionMuteToggle);
  el.btnTap     = getButtonAndAddAction('btnTap',     actionTapTempo);

  el.bpmDisplay = document.getElementById('bpmDisplay');
  el.bpmDisplay.addEventListener('input', e => {
    let s = e.target.value.replace(/[^0-9.]/g, '');
    const d = s.indexOf('.');
    if (d >= 0) s = s.slice(0, d+1) + s.slice(d+1).replace(/\./g, '');
    e.target.value = s.slice(0, 5);
  });
  el.bpmDisplay.addEventListener('change', e => {
    actionSetBPM(e.target.value);
    e.target.value = fmtBpm(bpm);
  });

  el.lockLamp  = document.getElementById('lockLamp');
  el.statusText = document.getElementById('statusText');
  el.errMs     = document.getElementById('errMs');
  el.floorV    = document.getElementById('floorV');
  el.eV        = document.getElementById('eV');

  document.body.addEventListener('keydown', actionKeyDown);

  setBpmDisplay(bpm);
  hardResetFollowerState();
  ensureStoppedUI();
}

// Boot
init();
</script>

<div style="padding: 1vh 1vw;">
  <button id="btnHelp" onclick="document.getElementById('helpSection').scrollIntoView({behavior:'smooth'})">Help ‚Üì</button>
</div>

<div style="height: 120vh;"></div>

<div id="helpSection" style="padding: 1vh 1vw; font-size: 2vh;">
State machine:
<ul>
  <li><b>IDLE ‚ÜíA‚Üí ACQUIRING</b>: mic opens, listens for beats to estimate BPM</li>
  <li><b>IDLE ‚ÜíR‚Üí TRACKING</b>: mic opens, starts playing at current BPM, phase-adjusts</li>
  <li><b>IDLE ‚ÜíSPACE‚Üí LOCKED</b>: plays at current BPM immediately (no mic)</li>
  <li><b>ACQUIRING ‚Üíauto‚Üí TRACKING</b>: after 4 consistent beats</li>
  <li><b>ACQUIRING ‚ÜíR‚Üí LOCKED</b>: commit current estimate early</li>
  <li><b>ACQUIRING ‚Üíauto‚Üí IDLE</b>: error after 20s timeout</li>
  <li><b>TRACKING ‚Üíauto‚Üí LOCKED</b>: after phase stabilises or 8 beats</li>
  <li><b>TRACKING ‚ÜíR‚Üí LOCKED</b>: force lock now</li>
  <li><b>LOCKED ‚ÜíR‚Üí TRACKING</b>: re-open mic, phase-adjust</li>
  <li><b>LOCKED ‚ÜíA‚Üí ACQUIRING</b>: re-open mic, re-collect (ticks continue)</li>
  <li><b>any ‚ÜíSPACE‚Üí IDLE</b>: stop everything</li>
</ul>

Key bindings:
<ul>
  <li><b>A</b>: Acquire</li>
  <li><b>R</b>: Track / commit / lock</li>
  <li><b>SPACE</b>: Play (from IDLE) or stop everything</li>
  <li>P: pause/resume</li>
  <li>T: tap tempo</li>
  <li>M: mute</li>
  <li>- / +: change tempo by 5 BPM</li>
</ul>

Notes:
<ul>
  <li>Mic access requires HTTPS or localhost.</li>
  <li>For a mechanical metronome, aim the mic at it and keep speaker volume moderate.</li>
  <li>When re-acquiring from LOCKED, existing ticks keep playing while new beats are collected.</li>
</ul>
</div>
</body>
</html>