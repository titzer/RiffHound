<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RiffHound Beat Follower</title>
<style>
  body { font-family: sans-serif; background: #fff; color: #000; margin: 0; }
  #top { display: flex; flex-wrap: nowrap; gap: 1vh; padding: 1vh; background: #eee; align-items: stretch; }
  #top button { flex: 1 1 0; font-size: 3.2vh; padding: 1.2vh 1vw; }
  button { cursor: pointer; border: 1px solid #bbb; }

  /* Top row buttons: blue by default, green when playing */
  #top button { background: #8389ff; color: #fff; border: 1px solid #8389ff; }
  body.playing #top button { background: #007700; color: #fff; border: 1px solid #007700; }

  /* Play: green when not playing, neutral when playing */
  #top #btnPlay { background: #007700; color: #fff; border: 1px solid #007700; }
  body.playing #top #btnPlay { background: #f4f4f4; color: #000; border: 1px solid #bbb; }

  /* Stop: neutral when stopped, red when playing */
  #top #btnStop { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnStop { background: #770000; color: #fff; border: 1px solid #770000; }

  /* Pause: yellow when paused */
  #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }
  body.playing #top #btnPause.paused { background: #ffcc00; color: #000; border: 1px solid #ccaa00; }

  /* Mute button active: yellow */
  #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }
  body.playing #top button.mute.active { background: #ffcc00; color: #000; border: 1px solid #ffcc00; }

  /* Neutral buttons */
  #top #btnTap, #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }
  body.playing #top #btnTap, body.playing #top #btnPause { background: #f4f4f4; color: #000; border: 1px solid #bbb; }

  /* Acquire and Track inherit the default top-row blue/green style */

  button.flash { background: #4CAF50; color: #fff; }

  /* BPM display: 5 chars with decimal */
  #bpmDisplay {
    font-size: 5.5vh;
    font-weight: bold;
    padding: 0.5vh 0.3vw;
    background: #f4f4f4;
    border: 1px solid #bbb;
    border-radius: 4px;
    width: 5.2ch;
    text-align: center;
    box-sizing: border-box;
  }

  /* Status area */
  #statusBar{
    padding: 0.8vh 1vw;
    background:#f8f8f8;
    border-top:1px solid #ddd;
    font-size: 2.2vh;
    display:flex;
    gap: 2vw;
    flex-wrap: wrap;
    align-items: baseline;
  }
  #lockLamp{
    display:inline-block;
    padding: 0.3vh 0.9vw;
    border:1px solid #bbb;
    border-radius: 999px;
    background:#eee;
    font-weight:700;
  }
  body.listening #lockLamp{
    background:#ffcc00;
    color:#000;
    border-color:#ccaa00;
  }
  body.tracking #lockLamp{
    background:#2680ff;
    color:#fff;
    border-color:#2680ff;
  }
  body.locked #lockLamp{
    background:#0a0;
    color:#fff;
    border-color:#0a0;
  }

  #mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    white-space: nowrap;
  }

  #visCanvas {
    display: block;
    width: 100%;
    height: 75vh;
    border-top: 1px solid #ddd;
  }
</style>
</head>
<body>
  <div id="top">
    <button id="btnPlay"   class="primary">‚ñ∂Ô∏è Play</button>
    <button id="btnPause">‚è∏ Pause</button>
    <button id="btnStop"   class="danger stopped">‚èπ Stop</button>
    <button id="btnAcquire">‚ö°Acquire</button>
    <button id="btnTrack">üéØ Track</button>
    <button id="btnMute"   class="mute">üîä Sound</button>
    <button id="btnTap">üïí Tap Tempo</button>
    <input id="bpmDisplay" type="text" value="110.0" maxlength="5">
  </div>

  <div id="statusBar">
    <div style="padding: 1vh 1vw;">
      <button id="btnHelp" onclick="document.getElementById('helpSection').scrollIntoView({behavior:'smooth'})">Help ‚Üì</button>
    </div>

    <span id="lockLamp">IDLE</span>
    <span id="statusText">A: acquire   R: track   SPACE: play</span>
    <span id="mono">err: <span id="errMs">‚Äî</span> ms | floor: <span id="floorV">‚Äî</span> | e: <span id="eV">‚Äî</span></span>
  </div>
  <canvas id="visCanvas"></canvas>

<script>
// =========================
// Beat Follower v0.3
// State machine: IDLE | ACQUIRE | TRACK | LOCKED
//
// IDLE      --A--> ACQUIRE   (start mic, collect beats)
// IDLE      --R--> TRACK     (use current BPM, start mic, play)
// IDLE   --SPACE-> LOCKED    (use current BPM, no mic, play)
// ACQUIRE   --auto-> TRACK   (4 good beats collected)
// ACQUIRE   --auto-> IDLE    (20s timeout, error)
// ACQUIRE   --R--> LOCKED    (commit estimate early)
// TRACK     --auto-> LOCKED  (phase stable OR 8 beats seen)
// TRACK     --R--> LOCKED    (force lock now)
// LOCKED    --R--> TRACK     (re-open mic, phase-adjust)
// LOCKED    --A--> ACQUIRE   (re-open mic, re-collect)
// any playing --SPACE-> IDLE (stop everything)
// =========================

let bpm = 110.0;
let playing = false;
let paused = false;
let pausedElapsed = 0;
let muted = false;
let startTime = 0;
const taps = [];

const el = {};

const ctx = new (window.AudioContext || window.webkitAudioContext)();
const master = ctx.createGain();
master.connect(ctx.destination);

// =========================
// UI helpers
// =========================
function fmtBpm(x) {
  x = Math.max(30, Math.min(300, x));
  return x.toFixed(1);
}
function setBpmDisplay(x) {
  bpm = Math.max(30, Math.min(300, x));
  el.bpmDisplay.value = fmtBpm(bpm);
  // Propagate immediately when free-running (no mic adjusting the period)
  if (BF.state === 'LOCKED') BF.period = 60 / bpm;
}
function setLamp(text) { el.lockLamp.textContent = text; }
function setStatus(msg) { el.statusText.textContent = msg; }

function setBodyFlags() {
  document.body.classList.toggle('playing',  playing);
  document.body.classList.toggle('listening', BF.active && BF.state === 'ACQUIRE');
  document.body.classList.toggle('tracking',  BF.active && BF.state === 'TRACK');
  document.body.classList.toggle('locked',    BF.state === 'LOCKED');  // mic may be off
}

// =========================
// Transport
// =========================
function tickRAF() {
  if (!playing || paused) return;
  // When mic is off (LOCKED), tickRAF owns tick scheduling
  if (!BF.active) scheduleTicks(ctx.currentTime);
  requestAnimationFrame(tickRAF);
}

function ensurePlayingUI() {
  if (playing) return;
  playing = true;
  startTime = ctx.currentTime + 0.03;
  el.btnPlay.classList.add('playing');
  el.btnStop.classList.remove('stopped');
  setBodyFlags();
  updateMuteButton();
  requestAnimationFrame(tickRAF);
}

function ensureStoppedUI() {
  playing = false;
  paused = false;
  pausedElapsed = 0;
  el.btnPause.classList.remove('paused');
  el.btnPlay.classList.remove('playing');
  el.btnStop.classList.add('stopped');
  setBodyFlags();
  updateMuteButton();
}

// =========================
// Tick sound
// =========================
function playTick(atTime, accent=false) {
  if (muted) return;
  const osc = ctx.createOscillator();
  const g   = ctx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(accent ? 1320 : 990, atTime);
  g.gain.setValueAtTime(0.0001, atTime);
  g.gain.exponentialRampToValueAtTime(accent ? 0.25 : 0.18, atTime + 0.0015);
  g.gain.exponentialRampToValueAtTime(0.0001, atTime + 0.030);
  osc.connect(g); g.connect(master);
  osc.start(atTime);
  osc.stop(atTime + 0.040);
}

// =========================
// Beat follower state
// =========================
const BF = {
  active: false,
  state: 'IDLE',

  stream: null, src: null, hp: null, analyser: null, buf: null,

  // detector
  floor: 0.0, e: 0.0, eRef: 0,   // eRef = fast visual reference (separate from slow floor)
  threshMul: 6.0, refractoryBase: 0.12, lastTrig: -1e9,

  // acquisition
  acquireStart: 0.0, events: [], estPeriod: null, estBpm: null,

  // clock  (nextTick = -1 means "not yet set")
  period: 60/110, t0: 0.0, nextTick: -1.0, lookahead: 0.20,

  // tracking
  alpha: 0.14, errAbsHist: [], lockWindow: 12, lockMedMs: 22.0,
  trackBeatCount: 0,   // beats seen in TRACK; auto-lock after 8

  lastBeatSeen: -1e9, maxAcquireSec: 20.0,
};

function resetFollowerUI() {
  el.errMs.textContent  = '‚Äî';
  el.floorV.textContent = '‚Äî';
  el.eV.textContent     = '‚Äî';
  setLamp('IDLE');
  setStatus('A: acquire   R: track   SPACE: play');
  setBodyFlags();
}

function hardResetFollowerState() {
  BF.state = 'IDLE';
  BF.events = []; BF.estPeriod = null; BF.estBpm = null;
  BF.floor = 0.0; BF.e = 0.0; BF.eRef = 0; BF.lastTrig = -1e9;
  BF.errAbsHist = []; BF.lastBeatSeen = -1e9;
  BF.trackBeatCount = 0;
  BF.nextTick = -1.0;
  resetFollowerUI();
}

function median(arr) {
  const a = arr.slice().sort((x,y)=>x-y);
  const n = a.length;
  if (!n) return NaN;
  return (n % 2) ? a[n>>1] : 0.5*(a[(n>>1)-1] + a[n>>1]);
}
function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

// =========================
// Mic management
// =========================
function stopMicHardware() {
  if (BF.src)      { try { BF.src.disconnect();     } catch(_) {} }
  if (BF.hp)       { try { BF.hp.disconnect();      } catch(_) {} }
  if (BF.analyser) { try { BF.analyser.disconnect();} catch(_) {} }
  BF.src = null; BF.hp = null; BF.analyser = null; BF.buf = null;
  if (BF.stream) { for (const t of BF.stream.getTracks()) t.stop(); }
  BF.stream = null;
  BF.active = false;
}

async function openMic() {
  const constraints = {
    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
  };
  BF.stream = await navigator.mediaDevices.getUserMedia(constraints);
  BF.src = ctx.createMediaStreamSource(BF.stream);

  BF.hp = ctx.createBiquadFilter();
  BF.hp.type = 'highpass';
  BF.hp.frequency.value = 600;
  BF.hp.Q.value = 0.707;

  BF.analyser = ctx.createAnalyser();
  BF.analyser.fftSize = 2048;
  BF.buf = new Float32Array(BF.analyser.fftSize);

  BF.src.connect(BF.hp);
  BF.hp.connect(BF.analyser);
  BF.active = true;
}

// Full stop: mic off, state IDLE, stop playing
function stopEverything() {
  VIS.frozenNow = ctx.currentTime;
  stopMicHardware();
  hardResetFollowerState();
  ensureStoppedUI();
}

// =========================
// Transition to LOCKED (mic stays open for energy display; beatFollowerRAF keeps running)
// =========================
function transitionToLocked() {
  BF.state = 'LOCKED';
  setLamp('LOCKED');
  setStatus(`Locked. ${fmtBpm(60/BF.period)} BPM. SPACE: stop   R: track   A: re-acquire`);
  setBodyFlags();
  ensurePlayingUI();
}

// =========================
// Beat detector
// =========================
function currentRefractory() {
  if (BF.state === 'TRACK' || BF.state === 'LOCKED')
    return clamp(0.40 * BF.period, 0.08, 0.25);
  return BF.refractoryBase;
}

function detectBeat(now) {
  if (!BF.analyser) return null;

  BF.analyser.getFloatTimeDomainData(BF.buf);
  let sum = 0.0, prev = BF.buf[0];
  for (let i = 1; i < BF.buf.length; i++) {
    const x = BF.buf[i];
    sum += Math.abs(x - prev);
    prev = x;
  }
  const e = sum / (BF.buf.length - 1);
  BF.e = e;

  if (BF.floor === 0.0) BF.floor = e;
  const capped = Math.min(e, BF.floor * 2.0);
  BF.floor = BF.floor * 0.99 + capped * 0.01;

  // Fast-adapting visual reference (Œ±=0.15, no cap) ‚Äî seeded on first non-zero sample.
  // eRefPrev is stored with the sample so bar height reflects the pre-sample background.
  const eRefPrev = BF.eRef > 0 ? BF.eRef : e;
  BF.eRef = BF.eRef > 0 ? BF.eRef * 0.85 + e * 0.15 : e;

  el.floorV.textContent = BF.floor.toFixed(4);
  el.eV.textContent     = BF.e.toFixed(4);
  VIS.energySamples.push({time: now, e, floor: BF.floor, eRef: eRefPrev});

  const enoughTime = (now - BF.lastTrig) > currentRefractory();
  const above      = e > (BF.floor * BF.threshMul);

  if (enoughTime && above) {
    BF.lastTrig = now; BF.lastBeatSeen = now;
    return now;
  }
  return null;
}

// =========================
// ACQUIRE: collect beats ‚Üí auto-promote to TRACK
// =========================
function updateAcquireEstimate() {
  if (BF.events.length < 2) return;
  const t = BF.events, n = t.length;
  const dts = [];
  for (let i = Math.max(1, n-6); i < n; i++) dts.push(t[i] - t[i-1]);
  const minT = 60/240, maxT = 60/40;
  const ok = dts.filter(dt => dt >= minT && dt <= maxT);
  if (!ok.length) return;
  const T = median(ok);
  BF.estPeriod = T; BF.estBpm = 60/T;
  setBpmDisplay(BF.estBpm);
  setLamp('ACQUIRE');
  setStatus(`Estimating‚Ä¶ ~${fmtBpm(BF.estBpm)} BPM (${BF.events.length} beats). R to commit.`);
}

function tryPromoteToTrackFromAcquire() {
  if (BF.events.length < 4) return false;
  const t = BF.events, n = t.length;
  const dts = [t[n-1]-t[n-2], t[n-2]-t[n-3], t[n-3]-t[n-4]];
  const minT = 60/240, maxT = 60/40;
  if (dts.some(dt => dt < minT || dt > maxT)) return false;
  const T = median(dts);
  if (Math.max(...dts.map(dt => Math.abs(dt-T))) > 0.060) return false;

  BF.period = T;
  BF.t0 = t[n-1];
  BF.nextTick = BF.t0 + BF.period;
  BF.trackBeatCount = 0;
  setBpmDisplay(60 / BF.period);

  BF.state = 'TRACK';
  BF.errAbsHist = [];
  setLamp('TRACK');
  setStatus(`Tracking‚Ä¶ ${fmtBpm(60/BF.period)} BPM. Locks after 8 beats. R to lock now.`);
  setBodyFlags();
  ensurePlayingUI();
  return true;
}

// =========================
// TRACK: phase correction ‚Üí auto-lock after 8 beats or stable phase
// =========================
function phaseError(tBeat) {
  const T = BF.period;
  let ph = (tBeat - BF.t0) % T;
  if (ph < 0) ph += T;
  if (ph > T/2) ph -= T;
  return ph;
}

function onBeatDetected(tBeat) {
  if (BF.state === 'ACQUIRE') {
    BF.events.push(tBeat);
    if (BF.events.length > 16) BF.events.shift();
    updateAcquireEstimate();
    VIS.detectedBeats.push({time: tBeat, bpm: BF.estBpm, errMs: null});
    if (BF.estBpm != null) VIS.bpmSamples.push({time: tBeat, bpm: BF.estBpm, errMs: null});
    tryPromoteToTrackFromAcquire();
    return;
  }

  if (BF.state === 'TRACK') {
    const err = phaseError(tBeat);
    el.errMs.textContent = (err * 1000).toFixed(1);
    VIS.detectedBeats.push({time: tBeat, bpm: 60 / BF.period, errMs: err * 1000});
    VIS.bpmSamples.push({time: tBeat, bpm: 60 / BF.period, errMs: err * 1000});

    BF.t0 += BF.alpha * err;
    const now = ctx.currentTime;
    while (BF.nextTick < now + 0.01) BF.nextTick += BF.period;

    BF.trackBeatCount++;

    const errMs = Math.abs(err) * 1000.0;
    BF.errAbsHist.push(errMs);
    while (BF.errAbsHist.length > BF.lockWindow) BF.errAbsHist.shift();

    const phaseStable = BF.errAbsHist.length >= BF.lockWindow &&
                        median(BF.errAbsHist) <= BF.lockMedMs;
    const eightBeats  = BF.trackBeatCount >= 8;

    if (phaseStable || eightBeats) {
      transitionToLocked();
    }
  }
}

// =========================
// Commit: R during ACQUIRE ‚Üí LOCKED immediately
// =========================
function commitFromAcquire() {
  if (!BF.estPeriod || BF.events.length < 3) {
    setStatus('Need at least 3 beats first.');
    return;
  }
  BF.period = BF.estPeriod;
  const last = BF.events[BF.events.length-1];
  BF.t0 = last;
  BF.nextTick = last + BF.period;
  setBpmDisplay(60 / BF.period);
  transitionToLocked();
}

// =========================
// Tick scheduler
// =========================
let beatCount = 0;

function scheduleTicks(now) {
  if (paused) return;
  if (BF.state !== 'TRACK' && BF.state !== 'LOCKED') return;
  if (BF.nextTick < 0) return;  // not yet initialized
  // skip stale cursor (e.g. long pause) without burst
  if (BF.nextTick < now - BF.period) BF.nextTick = now;

  const horizon = now + BF.lookahead;
  while (BF.nextTick < horizon) {
    playTick(BF.nextTick, (beatCount % 4) === 0);
    beatCount++;
    BF.nextTick += BF.period;
  }
}

function beatFollowerRAF() {
  if (!BF.active) return;
  const now = ctx.currentTime;

  // ACQUIRE timeout ‚Üí IDLE
  if (BF.state === 'ACQUIRE' && (now - BF.acquireStart) > BF.maxAcquireSec) {
    setStatus('Gave up (20s). Press A to try again.');
    VIS.frozenNow = now;
    stopMicHardware();
    hardResetFollowerState();
    ensureStoppedUI();
    return;
  }

  const trig = detectBeat(now);
  if (trig !== null) onBeatDetected(trig);

  scheduleTicks(now);
  requestAnimationFrame(beatFollowerRAF);
}

// =========================
// Actions
// =========================
async function actionAcquire() {
  await ctx.resume();
  if (BF.state === 'ACQUIRE' || BF.state === 'TRACK') return; // already listening

  // Stop mic if somehow on (shouldn't happen in normal flow)
  if (BF.active) stopMicHardware();

  // Fresh start from IDLE: clear visualization and stale phase
  if (BF.state === 'IDLE') { VIS.detectedBeats = []; VIS.energySamples = []; VIS.bpmSamples = []; BF.t0 = 0; }

  // Preserve period/nextTick so ticks continue if coming from LOCKED
  BF.state       = 'ACQUIRE';
  BF.acquireStart = ctx.currentTime;
  BF.events      = []; BF.estPeriod = null; BF.estBpm = null;
  BF.floor       = 0.0; BF.e = 0.0; BF.eRef = 0; BF.lastTrig = -1e9;
  BF.errAbsHist  = []; BF.lastBeatSeen = -1e9; BF.trackBeatCount = 0;

  try {
    await openMic();
  } catch (err) {
    console.error(err);
    BF.state = 'IDLE'; BF.active = false;
    setLamp('ERROR');
    setStatus('Mic failed (permission? HTTPS/localhost?).');
    setBodyFlags();
    return;
  }

  setLamp('ACQUIRE');
  setStatus('Listening‚Ä¶');
  setBodyFlags();
  requestAnimationFrame(beatFollowerRAF);
}

async function actionTrack() {
  await ctx.resume();

  if (BF.state === 'IDLE') {
    // IDLE ‚Üí TRACK: use current BPM, open mic
    VIS.detectedBeats = []; VIS.energySamples = []; VIS.bpmSamples = [];
    BF.period = 60 / bpm;
    BF.t0 = ctx.currentTime;
    BF.nextTick = BF.t0;
    BF.errAbsHist = []; BF.trackBeatCount = 0;
    BF.lastBeatSeen = -1e9; beatCount = 0;

    try { await openMic(); } catch (err) {
      console.error(err);
      setLamp('ERROR');
      setStatus('Mic failed (permission? HTTPS/localhost?).');
      setBodyFlags();
      return;
    }

    BF.state = 'TRACK';
    setLamp('TRACK');
    setStatus(`Tracking‚Ä¶ ${fmtBpm(bpm)} BPM. Locks after 8 beats. R to lock now.`);
    setBodyFlags();
    ensurePlayingUI();
    requestAnimationFrame(beatFollowerRAF);
    return;
  }

  if (BF.state === 'ACQUIRE') { commitFromAcquire(); return; }

  if (BF.state === 'TRACK') { transitionToLocked(); return; }

  if (BF.state === 'LOCKED') {
    // LOCKED ‚Üí TRACK: mic may already be open (kept on for energy display)
    BF.errAbsHist = []; BF.trackBeatCount = 0; BF.lastBeatSeen = -1e9;
    const wasActive = BF.active;

    if (!wasActive) {
      // Mic was off (came via SPACE‚ÜíLOCKED); open it now
      try { await openMic(); } catch (err) {
        console.error(err);
        setLamp('ERROR');
        setStatus('Mic failed (permission? HTTPS/localhost?).');
        setBodyFlags();
        return;
      }
    }

    BF.state = 'TRACK';
    setLamp('TRACK');
    setStatus(`Tracking‚Ä¶ ${fmtBpm(60/BF.period)} BPM. Locks after 8 beats. R to lock now.`);
    setBodyFlags();
    if (!wasActive) requestAnimationFrame(beatFollowerRAF);  // only start if not already running
  }
}

async function actionPlay() {
  // Direct LOCKED play at current BPM (SPACE from IDLE)
  if (playing) return;
  await ctx.resume();
  BF.period  = 60 / bpm;
  BF.t0      = ctx.currentTime;
  BF.nextTick = BF.t0;
  beatCount  = 0;
  BF.state   = 'LOCKED';
  setLamp('LOCKED');
  setStatus(`Playing. ${fmtBpm(bpm)} BPM. SPACE: stop   R: track   A: acquire`);
  setBodyFlags();
  ensurePlayingUI();
  scheduleTicks(ctx.currentTime);  // kick off immediately; don't wait for RAF
}

function actionStop() { stopEverything(); }

function actionPause() {
  if (!playing && !BF.active) return;
  if (!paused) {
    paused = true;
    pausedElapsed = ctx.currentTime - startTime;
    el.btnPause.classList.add('paused');
    setStatus('Paused.');
  } else {
    paused = false;
    startTime = ctx.currentTime - pausedElapsed;
    el.btnPause.classList.remove('paused');
    requestAnimationFrame(tickRAF);
    setStatus('Resumed.');
  }
}

function actionMuteToggle() {
  muted = !muted;
  updateMuteButton();
  el.btnMute.classList.add('flash');
  setTimeout(() => el.btnMute.classList.remove('flash'), 150);
}

function updateMuteButton() {
  const active = muted && (playing || BF.state === 'TRACK' || BF.state === 'LOCKED');
  el.btnMute.classList.toggle('active', active);
  el.btnMute.textContent = muted ? 'üîá Muted' : 'üîä Sound';
}

function actionTapTempo() {
  const now = performance.now();
  taps.push(now);
  while (taps.length > 6) taps.shift();
  if (taps.length >= 2) {
    const diffs = taps.slice(1).map((t,i) => t - taps[i]);
    const avg   = diffs.reduce((a,b) => a+b, 0) / diffs.length;
    setBpmDisplay(clamp(60000 / avg, 30, 300));
    el.btnTap.classList.add('flash');
    setTimeout(() => el.btnTap.classList.remove('flash'), 150);
  }
}

function actionSetBPM(val) {
  const x = parseFloat(val);
  if (!Number.isFinite(x)) { el.bpmDisplay.value = fmtBpm(bpm); return; }
  setBpmDisplay(clamp(x, 30, 300));
}

function actionKeyDown(e) {
  if (e.code === 'Space') {
    e.preventDefault();
    if (BF.active || playing) actionStop();
    else actionPlay();
    return;
  }
  if (e.code === 'KeyA') { e.preventDefault(); actionAcquire();   return; }
  if (e.code === 'KeyR') { e.preventDefault(); actionTrack();     return; }
  if (e.code === 'KeyT') { e.preventDefault(); actionTapTempo();  return; }
  if (e.code === 'KeyP') { e.preventDefault(); actionPause();     return; }
  if (e.code === 'KeyM') { e.preventDefault(); actionMuteToggle();return; }
  if (e.code === 'Minus' || e.code === 'NumpadSubtract') {
    setBpmDisplay(clamp(Math.ceil(bpm/5)*5 - 5, 30, 300)); return;
  }
  if (e.code === 'Equal' || e.code === 'NumpadAdd') {
    setBpmDisplay(clamp(Math.floor(bpm/5)*5 + 5, 30, 300)); return;
  }
}

function getButtonAndAddAction(name, action) {
  var btn = document.getElementById(name);
  btn.addEventListener('click', action);
  return btn;
}

// =========================
// Visualization
// =========================
const VIS = {
  detectedBeats: [],   // {time, bpm, errMs}
  energySamples: [],   // {time, e, floor}
  bpmSamples:    [],   // {time, bpm, errMs} ‚Äî one per beat detection
  windowSec: 6.0,
  nowFrac:   2/3,      // "now" line at 2/3 canvas width
  frozenNow: null,     // ctx.currentTime captured when entering IDLE (canvas freezes)
};

function drawDiamond(cx, x, y, r, filled) {
  cx.beginPath();
  cx.moveTo(x,     y - r);
  cx.lineTo(x + r, y    );
  cx.lineTo(x,     y + r);
  cx.lineTo(x - r, y    );
  cx.closePath();
  if (filled) cx.fill();
  cx.stroke();
}

function drawVis() {
  requestAnimationFrame(drawVis);

  const canvas = document.getElementById('visCanvas');
  if (!canvas) return;

  // Resize canvas buffer to match CSS size (DPR-aware)
  const dpr = window.devicePixelRatio || 1;
  const W   = canvas.offsetWidth;
  const H   = canvas.offsetHeight;
  if (W === 0 || H === 0) return;
  if (canvas.width !== W * dpr || canvas.height !== H * dpr) {
    canvas.width  = W * dpr;
    canvas.height = H * dpr;
  }

  const cx  = canvas.getContext('2d');
  cx.setTransform(dpr, 0, 0, dpr, 0, 0);   // reset to CSS-pixel space

  // In IDLE, freeze at the captured snapshot time so the canvas doesn't animate
  const now      = (BF.state === 'IDLE' && VIS.frozenNow !== null)
                   ? VIS.frozenNow : ctx.currentTime;
  const pxPerSec = W / VIS.windowSec;
  const nowX     = W * VIS.nowFrac;
  function timeToX(t) { return nowX + (t - now) * pxPerSec; }

  // Layout rows
  const detectedY  = H * 0.11;
  const predictedY = H * 0.23;
  const bpmTopY    = H * 0.34;
  const bpmBotY    = H * 0.62;
  const bpmCenterY = (bpmTopY + bpmBotY) / 2;
  const bpmH       = bpmBotY - bpmTopY;
  const energyTopY = H * 0.68;
  const energyH    = H - energyTopY;

  // Time window edges
  const leftT  = now - VIS.windowSec * VIS.nowFrac;
  const rightT = now + VIS.windowSec * (1 - VIS.nowFrac);

  // Background
  cx.fillStyle = '#f8f8f8';
  cx.fillRect(0, 0, W, H);
  cx.fillStyle = '#f2f0f8';  // subtle tint for BPM zone
  cx.fillRect(0, bpmTopY, W, bpmH);
  cx.fillStyle = '#efefef';
  cx.fillRect(0, energyTopY, W, energyH);

  // --- 250ms vertical grid lines ---
  {
    const gridInterval = 0.250;
    let gridT = Math.ceil(leftT / gridInterval) * gridInterval;
    cx.strokeStyle = '#e4e4e4';
    cx.lineWidth   = 1;
    cx.setLineDash([]);
    cx.beginPath();
    while (gridT <= rightT) {
      const gx = timeToX(gridT);
      cx.moveTo(gx, 0);
      cx.lineTo(gx, H);
      gridT += gridInterval;
    }
    cx.stroke();
  }

  // Track guide lines
  cx.strokeStyle = '#d0d0d0';
  cx.lineWidth   = 1;
  cx.setLineDash([]);
  cx.beginPath();
  cx.moveTo(0, detectedY);  cx.lineTo(W, detectedY);
  cx.moveTo(0, predictedY); cx.lineTo(W, predictedY);
  cx.moveTo(0, bpmTopY);    cx.lineTo(W, bpmTopY);
  cx.moveTo(0, energyTopY); cx.lineTo(W, energyTopY);
  cx.stroke();

  // Track labels
  cx.fillStyle    = '#bbb';
  cx.font         = '10px sans-serif';
  cx.textAlign    = 'left';
  cx.textBaseline = 'bottom';
  cx.fillText('beats',     4, detectedY  - 3);
  cx.fillText('predicted', 4, predictedY - 3);
  cx.textBaseline = 'top';
  cx.fillText('bpm',       4, bpmTopY    + 2);
  cx.fillText('energy',    4, energyTopY + 2);

  // "Now" line
  cx.strokeStyle = '#bbb';
  cx.lineWidth   = 1;
  cx.setLineDash([4, 4]);
  cx.beginPath();
  cx.moveTo(nowX, 0);
  cx.lineTo(nowX, H);
  cx.stroke();
  cx.setLineDash([]);
  cx.fillStyle    = '#bbb';
  cx.textAlign    = 'center';
  cx.textBaseline = 'top';
  cx.fillText('now', nowX, 2);

  // --- Detected beats ---
  cx.textAlign = 'center';
  for (const b of VIS.detectedBeats) {
    const x = timeToX(b.time);
    if (x < -30 || x > W + 30) continue;

    // Filled diamond
    cx.fillStyle   = '#2266ee';
    cx.strokeStyle = '#2266ee';
    cx.lineWidth   = 1.5;
    drawDiamond(cx, x, detectedY, 10, true);

    // BPM label above diamond
    if (b.bpm != null) {
      cx.fillStyle    = '#2266ee';
      cx.font         = 'bold 12px monospace';
      cx.textBaseline = 'bottom';
      cx.fillText(b.bpm.toFixed(1), x, detectedY - 11);
    }

    // Error label below diamond
    if (b.errMs != null) {
      const sign = b.errMs >= 0 ? '+' : '';
      cx.fillStyle    = '#888';
      cx.font         = '11px monospace';
      cx.textBaseline = 'top';
      cx.fillText(`${sign}${b.errMs.toFixed(0)}ms`, x, detectedY + 11);
    }
  }

  // --- Predicted beats ---
  // Show only when actively tracking or locked (not in IDLE or early ACQUIRE)
  if ((BF.state === 'TRACK' || BF.state === 'LOCKED') && BF.t0 > 0 && BF.period > 0) {
    let beatT = BF.t0 + Math.ceil((leftT - BF.t0) / BF.period) * BF.period;
    while (beatT <= rightT) {
      const x = timeToX(beatT);
      if (x >= -10 && x <= W + 10) {
        cx.strokeStyle = beatT > now ? '#ee8800' : '#ccc';
        cx.lineWidth   = 1.5;
        drawDiamond(cx, x, predictedY, 10, false);
      }
      beatT += BF.period;
    }
  }

  // --- BPM zone ---
  {
    const nomBpm = bpm;                  // display BPM ‚Äî center reference line
    const halfRange = 15;                // ¬±15 BPM visible range
    const bpmToY = b => bpmCenterY - Math.max(-1, Math.min(1, (b - nomBpm) / halfRange)) * (bpmH / 2);

    // Dashed center line at nominal BPM
    cx.strokeStyle = '#ccc8dd';
    cx.lineWidth   = 1;
    cx.setLineDash([4, 4]);
    cx.beginPath();
    cx.moveTo(0, bpmCenterY); cx.lineTo(W, bpmCenterY);
    cx.stroke();
    cx.setLineDash([]);

    // Nominal BPM label on right edge of center line
    cx.fillStyle    = '#aaa';
    cx.font         = '10px monospace';
    cx.textAlign    = 'right';
    cx.textBaseline = 'middle';
    cx.fillText(nomBpm.toFixed(1), W - 4, bpmCenterY);

    const visBpm = VIS.bpmSamples.filter(s => s.bpm != null);
    if (visBpm.length > 0) {
      // BPM line connecting dots
      cx.strokeStyle = '#7755bb';
      cx.lineWidth   = 1.5;
      cx.setLineDash([]);
      cx.beginPath();
      let first = true;
      for (const s of visBpm) {
        const x = timeToX(s.time);
        const y = bpmToY(s.bpm);
        if (first) { cx.moveTo(x, y); first = false; } else { cx.lineTo(x, y); }
      }
      // Extend flat to "now" when LOCKED (mic off, no new beats)
      if (BF.state === 'LOCKED') {
        cx.lineTo(nowX, bpmToY(60 / BF.period));
      }
      cx.stroke();

      // Dots + error ticks
      for (const s of visBpm) {
        const x = timeToX(s.time);
        const y = bpmToY(s.bpm);

        // Dot
        cx.fillStyle = '#7755bb';
        cx.beginPath();
        cx.arc(x, y, 3, 0, Math.PI * 2);
        cx.fill();

        // Error tick: extends from center line, proportional to phase error
        // ¬±50ms of phase error ‚Üí ¬±45% of bpm zone height
        if (s.errMs != null) {
          const tickH = Math.max(-bpmH * 0.45, Math.min(bpmH * 0.45,
                        s.errMs * (bpmH * 0.45) / 50));
          cx.strokeStyle = Math.abs(s.errMs) > 30 ? '#cc5544' : '#9988cc';
          cx.lineWidth   = 1.5;
          cx.beginPath();
          cx.moveTo(x, bpmCenterY);
          cx.lineTo(x, bpmCenterY - tickH);
          cx.stroke();
        }
      }
    }
  }

  // --- Energy bar graph ---
  for (const s of VIS.energySamples) {
    const x = timeToX(s.time);
    if (x < 0 || x > W) continue;
    // Height: use fast visual reference so bars show transients above recent background.
    // Color: use beat-detector floor so red = actually above trigger threshold.
    const ref        = s.eRef > 0 ? s.eRef : s.floor;
    const ratio      = ref > 0 ? s.e / ref : 0;
    const normalized = ratio > 1 ? Math.min(Math.log(ratio) / Math.log(BF.threshMul), 1.0) : 0;
    const threshold  = s.floor * BF.threshMul;
    const barH       = normalized * energyH;
    cx.fillStyle = s.e > threshold ? '#dd4444' : '#44aa66';
    cx.fillRect(x - 1.5, H - barH, 3, barH);
  }

  // Cull data older than the visible window
  const cullBefore = now - VIS.windowSec - 0.5;
  if (VIS.detectedBeats.length && VIS.detectedBeats[0].time < cullBefore)
    VIS.detectedBeats = VIS.detectedBeats.filter(b => b.time >= cullBefore);
  if (VIS.energySamples.length && VIS.energySamples[0].time < cullBefore)
    VIS.energySamples = VIS.energySamples.filter(s => s.time >= cullBefore);
  if (VIS.bpmSamples.length && VIS.bpmSamples[0].time < cullBefore)
    VIS.bpmSamples = VIS.bpmSamples.filter(s => s.time >= cullBefore);
}

// =========================
// Wiring
// =========================
function init() {
  el.btnPlay    = getButtonAndAddAction('btnPlay',    actionPlay);
  el.btnPause   = getButtonAndAddAction('btnPause',   actionPause);
  el.btnStop    = getButtonAndAddAction('btnStop',    actionStop);
  el.btnAcquire = getButtonAndAddAction('btnAcquire', actionAcquire);
  el.btnTrack   = getButtonAndAddAction('btnTrack',   actionTrack);
  el.btnMute    = getButtonAndAddAction('btnMute',    actionMuteToggle);
  el.btnTap     = getButtonAndAddAction('btnTap',     actionTapTempo);

  el.bpmDisplay = document.getElementById('bpmDisplay');
  el.bpmDisplay.addEventListener('input', e => {
    let s = e.target.value.replace(/[^0-9.]/g, '');
    const d = s.indexOf('.');
    if (d >= 0) s = s.slice(0, d+1) + s.slice(d+1).replace(/\./g, '');
    e.target.value = s.slice(0, 5);
  });
  el.bpmDisplay.addEventListener('change', e => {
    actionSetBPM(e.target.value);
    e.target.value = fmtBpm(bpm);
  });

  el.lockLamp  = document.getElementById('lockLamp');
  el.statusText = document.getElementById('statusText');
  el.errMs     = document.getElementById('errMs');
  el.floorV    = document.getElementById('floorV');
  el.eV        = document.getElementById('eV');

  document.body.addEventListener('keydown', actionKeyDown);

  setBpmDisplay(bpm);
  hardResetFollowerState();
  ensureStoppedUI();
  requestAnimationFrame(drawVis);
}

// Boot
init();
</script>

<div style="height: 120vh;"></div>

<div id="helpSection" style="padding: 1vh 1vw; font-size: 2vh;">
Buttons &amp; keys:
<table style="border-collapse:collapse; font-size:inherit;">
<tr><th style="text-align:left;padding:0.3em 1em 0.3em 0">Button</th><th style="text-align:left;padding:0.3em 1em 0.3em 0">Key</th><th style="text-align:left;padding:0.3em 0">Action</th></tr>
<tr><td>‚ñ∂Ô∏è Play</td><td><b>SPACE</b></td><td>From IDLE: start playing ticks at current BPM (no mic)</td></tr>
<tr><td>‚è∏ Pause</td><td><b>P</b></td><td>Pause / resume</td></tr>
<tr><td>‚èπ Stop</td><td><b>SPACE</b></td><td>Stop everything and return to IDLE</td></tr>
<tr><td>üéô Acquire</td><td><b>A</b></td><td>Open mic, listen for beats to estimate BPM; from LOCKED, re-acquires while ticks continue</td></tr>
<tr><td>üéØ Track</td><td><b>R</b></td><td>Open mic and phase-track at current BPM (from IDLE); commit estimate (from ACQUIRING); force lock (from TRACKING); re-open mic (from LOCKED)</td></tr>
<tr><td>üîä Sound</td><td><b>M</b></td><td>Mute / unmute tick output</td></tr>
<tr><td>üïí Tap Tempo</td><td><b>T</b></td><td>Tap to set BPM; takes effect immediately if playing</td></tr>
<tr><td>BPM display</td><td><b>- / +</b></td><td>Edit BPM directly or step by 5; takes effect immediately if playing</td></tr>
</table>

State machine:
<ul>
  <li><b>IDLE ‚ÜíA‚Üí ACQUIRING</b>: mic opens, collects beats to estimate BPM</li>
  <li><b>IDLE ‚ÜíR‚Üí TRACKING</b>: mic opens, plays at current BPM, phase-adjusts to mic</li>
  <li><b>IDLE ‚ÜíSPACE‚Üí LOCKED</b>: plays at current BPM immediately (no mic)</li>
  <li><b>ACQUIRING ‚Üíauto‚Üí TRACKING</b>: after 4 consistent beats detected</li>
  <li><b>ACQUIRING ‚ÜíR‚Üí LOCKED</b>: commit current estimate early</li>
  <li><b>ACQUIRING ‚Üíauto‚Üí IDLE</b>: timeout after 20 s</li>
  <li><b>TRACKING ‚Üíauto‚Üí LOCKED</b>: after phase stabilises or 8 beats seen</li>
  <li><b>TRACKING ‚ÜíR‚Üí LOCKED</b>: force lock now</li>
  <li><b>LOCKED ‚ÜíR‚Üí TRACKING</b>: re-open mic, resume phase-adjustment</li>
  <li><b>LOCKED ‚ÜíA‚Üí ACQUIRING</b>: re-open mic, re-collect (ticks keep playing)</li>
  <li><b>any ‚ÜíSPACE‚Üí IDLE</b>: stop everything</li>
</ul>

Canvas:
<ul>
  <li>Filled blue diamonds = detected beats; BPM estimate above, phase error below.</li>
  <li>Empty orange diamonds = predicted future beats; grey = predicted past.</li>
  <li>Bar graph = acoustic energy; red bars = beat triggered.</li>
  <li>"now" line is at ‚Öî width; 6 seconds spans the full canvas.</li>
</ul>

Notes:
<ul>
  <li>Mic access requires HTTPS or localhost.</li>
  <li>For a mechanical metronome, aim the mic at it and keep speaker volume moderate.</li>
</ul>

TODO:
<ul>
  <li>Graph state over time as well. Use some vertical space in the timeline canvas to show the state over time as a line about the thickness of text. Use yellow for ACQUIRING, red for TRACKING and green for locked. Display the text name of the current state just to the right of the now line. </li>
  <li>Fix the beat detection. Energy levels still look weird, often fully red at the start</li>
  <li>Add manual tracking adjustment buttons. Plus 10ms (the ] key) and Minus 10ms (the [ key) for when the tone is played.</li>
  <li>Fix tone detection. Use suggestions from ChatGPT. (multiple tones, listen for *the end* of specific tones).
</ul>
</ul>

</div>
</body>
</html>
