// Copyright (c) 2025 Ben L. Titzer. All rights reserved.

// Parses the various components of RiffText.
class RiffParser(input: string) {
	def r = TextReader.new("<input>", input);

	def parseKey() -> Key {
		r.req1('K');
		var tone = parsePitch();
		var scale = Scale.Major;
		for (s in Scale) {
			if (r.optN(s.abbrev) >= 0) { scale = s; break; }
		}
		return Key(tone.note, scale);
	}
	// T <int>
	def parseTempo() -> Tempo {
		r.req1('T');
		var p = r.pos;
		var bpm = u16.!(parseInt(1, u16.max));
		return Tempo(bpm);
	}
	// M (step[duration])+
	def parseMelodySteps() -> Array<(MelodyStep, Duration)> {
		r.req1('M');
		var steps = parseListOf(fun => parseWithDuration(parseMelodyStep, Durations.QUARTER));
		return steps;
	}
	// R (duration)+
	def parseRhythm() -> Array<Duration> {
		r.req1('R');
		var durations = parseListOf(parseDuration);
		return durations;
	}
	// ((+|-)?<int>) | _
	def parseMelodyStep() -> MelodyStep {
		match (r.char) {
			'-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' => {
				var d = parseInt(i8.min, i8.max);
				return MelodyStep.Voice(i16.view(d));
			}
			'[' => {
				eat1();
				if (r.char == ']') {
					eat1();
					return MelodyStep.Rest;
				}
				var voices = parseListOf(fun => i16.view(parseInt(i8.min, i8.max)));
				r.req1(']');
				match (voices.length) {
					0 => return MelodyStep.Rest;
					1 => return MelodyStep.Voice(voices[0]);
					_ => return MelodyStep.Chord(voices);
				}
			}
			'_' => {
				eat1();
				return MelodyStep.Rest;
			}
			_ => {
				r.fail("expected number or _");
				return MelodyStep.Rest;
			}
		}
	}
	// ((K|S|T...)[<int>])+
	def parseDrumStep() -> DrumStep {
		if (r.char == '_') {
			eat1();
			return DrumStep(Drums.NONE);
		}
		var buf = Vector<Drum>.new();
		buf.put(parseDrum());
		while (r.ok && isDrum(r.char)) buf.put(parseDrum());
		return DrumStep(buf.extract());
	}
	// (K|S|T...)[<int>]
	def parseDrum() -> Drum {
		for (d in DrumKind) {
			if (d.mnemonic == r.char) {
				eat1();
				var num = byte.!(if(Chars.isDecimal(r.char), parseInt(1, 9)));
				return Drum(d, num);
			}
		}
		var buf = StringBuilder.new().puts("expected drum (");
		for (d in DrumKind) {
			buf.putc(d.mnemonic);
			buf.sp();
		}
		r.fail(buf.toString());
		return Drum(DrumKind.Kick, byte.max);
	}
	def isDrum(ch: byte) -> bool {
		for (d in DrumKind) if (d.mnemonic == ch) return true;
		return false;
	}
	// ((w|h|q|e|s|t)[.][/<int>]) (^(w|h|q|e|s|t)[.][/<int>])*
	def parseDuration() -> Duration {
		var cur = Durations.NONE;
		while (r.ok) {
			var t = Duration(0, 1);
			match (r.char) {
				'w' => t = Durations.WHOLE;
				'h' => t = Durations.HALF;
				'q' => t = Durations.QUARTER;
				'e' => t = Durations.EIGHTH;
				's' => t = Durations.SIXTEENTH;
				't' => t = Durations.THIRTY_SECOND;
				_ => r.fail("expected duration (w,h,q,e,s, or t)");
			}
			eat1();
			if (r.opt1('.') >= 0) {
				var p = r.pos;
				var n = 2u * t.denom;
				if (n > u16.max) r.failRel(p - r.pos, "fractional note too small to represent");
				else t = t.plus(Durations.of(t.num, n));
			}
			if (r.opt1('/') >= 0) {
				// handle fractions of a note
				var p = r.pos;
				var d = parseInt(1, u16.max);
				if (d == 0) r.failRel(p - r.pos, "divide by zero");
				var n = d * t.denom;
				if (n > u16.max) r.failRel(p - r.pos, "fractional note too small to represent");
				else t = Durations.of(t.num, u16.view(n));
			}
			cur = cur.plus(t);
			if (r.opt1('^') < 0) break; // not a tie
		}
		return cur;
	}
	def isDuration(ch: byte) -> bool {
		match (ch) {
			'w', 'h', 'q', 'e', 's', 't' => return true;
		}
		return false;
	}
	def parsePitch() -> Pitch {
		var note: Note;
		match (r.char) {
			'A' => note = Note.A;
			'B' => note = Note.B;
			'C' => note = Note.C;
			'D' => note = Note.D;
			'E' => note = Note.E;
			'F' => note = Note.F;
			'G' => note = Note.G;
			_ => {
				r.fail("expected A, B, C, D, E, F, or G");
			}
		}
		eat1();
		var octave = 4u4;
		if (Chars.isDecimal(r.char)) octave = u4.!(parseInt(1, 9));
		var tone = Pitch(note, octave);
		while (true) {
			match (r.char) {
				'#' => { tone = tone.plus(1, NoteDir.SHARP); eat1(); }
				'b' => { tone = tone.plus(-1, NoteDir.FLAT); eat1(); }
				_ => break;
			}
		}
		return tone;
	}
	def parseWithDuration<T>(f: void -> T, d: Duration) -> (T, Duration) {
		var v = f();
		if (isDuration(r.char)) d = parseDuration();
		return (v, d);
	}
	def parseListOf<T>(parse: void -> T) -> Array<T> {
		var buf = Vector<T>.new();
		while (true) {
			var d = parse();
			buf.put(d);
			if (r.opt1(',') < 0) break;
		}
		return buf.extract();
	}
	def parseInt(min: int, max: int) -> int {
		var i = r.pos;
		var t = Ints.parseDecimal(r.data, i);
		if (t.0 > 0) {
			r.advance(t.0);
			var val = t.1;
			if (val < min) {
				r.failRel(i - r.pos, Strings.format2("expected integer >= %d, got %d", min, val));
				return min;
			} else if (val > max) {
				r.failRel(i - r.pos, Strings.format2("expected integer <= %d, got %d", max, val));
				return max;
			}
			return val;
		}
		r.failRel(i - r.pos, "expected integer");
		return min;
	}
	def isNoteStart(ch: byte) -> bool {
		return ch >= 'A' && ch <= 'G';
	}
	def eat1() {
		r.advance1(); // TODO: don't skip space
	}
}
