// Copyright (c) 2025 Ben L. Titzer. All rights reserved.

// Parses the various components of RiffText.
class RiffParser(input: string) {
	def r = TextReader.new("<input>", input);

	def parseKey() -> Key {
		r.req1('K');
		var tone = parsePitch();
		var scale = Scale.Major;
		for (s in Scale) {
			if (r.optN(s.abbrev) >= 0) { scale = s; break; }
		}
		return Key(tone.note, scale);
	}
	// T <int>
	def parseTempo() -> Tempo {
		r.req1('T');
		var p = r.pos;
		var bpm = u16.!(parseInt(1, u16.max));
		return Tempo(bpm);
	}
	// M ((<int> | _) duration)+
	def parseMelody() -> Array<Step> {
		r.req1('M');
		var steps = parseListOf(parseStep);
		return steps;
	}
	// R (duration)+
	def parseRhythm() -> Array<Duration> {
		r.req1('R');
		var durations = parseListOf(parseDuration);
		return durations;
	}
	// ((+|-)?<int>) | _
	def parseStep() -> Step {
		match (r.char) {
			'-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' => {
				var d = parseInt(i8.min, i8.max);
				return Step.Voice(i16.view(d));
			}
			'[' => {
				eat1();
				if (r.char == ']') {
					eat1();
					return Step.Rest;
				}
				var voices = parseListOf(fun => i16.view(parseInt(i8.min, i8.max)));
				r.req1(']');
				match (voices.length) {
					0 => return Step.Rest;
					1 => return Step.Voice(voices[0]);
					_ => return Step.Chord(voices);
				}
			}
			'_' => {
				eat1();
				return Step.Rest;
			}
			_ => {
				r.fail("expected number or _");
				return Step.Rest;
			}
		}
	}
	// ((w|h|q|e|s|t)[.][/<int>]) (^(w|h|q|e|s|t)[.][/<int>])*
	def parseDuration() -> Duration {
		var cur = Durations.NONE;
		while (true) {
			var t = Duration(0, 1);
			match (r.char) {
				'w' => t = Durations.WHOLE;
				'h' => t = Durations.HALF;
				'q' => t = Durations.QUARTER;
				'e' => t = Durations.EIGHTH;
				's' => t = Durations.SIXTEENTH;
				't' => t = Durations.THIRTY_SECOND;
				_ => r.fail("expected duration (w,h,q,e,s, or t)");
			}
			eat1();
			if (r.opt1('.') >= 0) {
				var p = r.pos;
				var n = 2u * t.denom;
				if (n > u16.max) r.failRel(p - r.pos, "fractional note too small to represent");
				else t = t.plus(Durations.of(t.num, n));
			}
			if (r.opt1('/') >= 0) {
				// handle fractions of a note
				var p = r.pos;
				var d = parseInt(1, u16.max);
				if (d == 0) r.failRel(p - r.pos, "divide by zero");
				var n = d * t.denom;
				if (n > u16.max) r.failRel(p - r.pos, "fractional note too small to represent");
				else t = Durations.of(t.num, u16.view(n));
			}
			cur = cur.plus(t);
			if (r.opt1('^') < 0) break; // not a tie
		}
		return cur;
	}
	def parsePitch() -> Pitch {
		var note: Note;
		match (r.char) {
			'A' => note = Note.A;
			'B' => note = Note.B;
			'C' => note = Note.C;
			'D' => note = Note.D;
			'E' => note = Note.E;
			'F' => note = Note.F;
			'G' => note = Note.G;
			_ => {
				r.fail("expected A, B, C, D, E, F, or G");
			}
		}
		eat1();
		var octave = 4u4;
		if (Chars.isDecimal(r.char)) octave = u4.!(parseInt(1, 9));
		var tone = Pitch(note, octave);
		while (true) {
			match (r.char) {
				'#' => { tone = tone.plus(1, NoteDir.SHARP); eat1(); }
				'b' => { tone = tone.plus(-1, NoteDir.FLAT); eat1(); }
				_ => break;
			}
		}
		return tone;
	}
	def parseListOf<T>(parse: void -> T) -> Array<T> {
		var buf = Vector<T>.new();
		while (true) {
			var d = parse();
			buf.put(d);
			if (r.opt1(',') < 0) break;
		}
		return buf.extract();
	}
	def parseInt(min: int, max: int) -> int {
		var i = r.pos;
		var t = Ints.parseDecimal(r.data, i);
		if (t.0 > 0) {
			r.advance(t.0);
			var val = t.1;
			if (val < min) {
				r.failRel(i - r.pos, Strings.format2("expected integer >= %d, got %d", min, val));
				return min;
			} else if (val > max) {
				r.failRel(i - r.pos, Strings.format2("expected integer <= %d, got %d", max, val));
				return max;
			}
			return val;
		}
		r.failRel(i - r.pos, "expected integer");
		return 0;
	}
	def isNoteStart(ch: byte) -> bool {
		return ch >= 'A' && ch <= 'G';
	}
	def eat1() {
		r.advance1(); // TODO: don't skip space
	}
}
