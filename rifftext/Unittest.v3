// Copyright 2025 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def reg = UnitTests.register;
def X_ = void(
	reg("tempos", test_tempos),
	reg("simple_steps", test_simple_steps),
	reg("invalid_steps", test_invalid_steps),
	reg("simple_melodies1", test_simple_melodies1),
	reg("simple_melodies2", test_simple_melodies2),
	reg("invalid_melodies", test_invalid_melodies),
	reg("simple_durations", test_simple_durations),
	reg("dotted_durations", test_dotted_durations),
	reg("fractional_durations", test_fractional_durations),
	reg("tied_durations", test_tied_durations),
	reg("invalid_durations", test_invalid_durations),
	reg("melody_durations", test_melody_durations),
	reg("notes0", test_notes0),
	reg("notes1", test_notes1),
	reg("notes2", test_notes2),
	reg("tones0", test_tones0),
	reg("keys", test_keys),
	reg("chords0", test_chords0),
	reg("drums0", test_drums0),
	()
);

def parseNote(p: RiffParser) -> Note {
	return p.parsePitch().note;
}

def assert_invalid<T>(t: Tester, str: string, parse: RiffParser -> T) {
	var p = RiffParser.new(str);
	var got = parse(p);
	if (p.r.ok) return t.fail("expected fail, but passed");
}

def assert_valid<T>(t: Tester, str: string, parse: RiffParser -> T, expected: T, cmp: (T, T) -> bool) {
	if (cmp == null) cmp = T.==;
	var p = RiffParser.new(str);
	var got = parse(p);
	if (!p.r.ok) return t.fail(p.r.error_msg);
	if (!cmp(got, expected)) {
		var buf = StringBuilder.new();
		buf.puts("expected ");
		render(buf, expected);
		buf.puts(", got ");
		render(buf, got);
		t.fail(buf.toString());
	}
}


def assert_invalid_tempo = assert_invalid(_, _, RiffParser.parseTempo);
def assert_invalid_duration = assert_invalid(_, _, RiffParser.parseDuration);
def assert_invalid_step = assert_invalid(_, _, RiffParser.parseMelodyStep);
def assert_invalid_steps = assert_invalid(_, _, RiffParser.parseMelodySteps);
def assert_invalid_note = assert_invalid(_, _, parseNote);
def assert_invalid_tone = assert_invalid(_, _, RiffParser.parsePitch);
def assert_invalid_key = assert_invalid(_, _, RiffParser.parseKey);
def assert_invalid_drums = assert_invalid(_, _, RiffParser.parseDrumStep);

def assert_valid_array<T>(t: Tester, str: string, parse: RiffParser -> Array<T>, expected: Array<T>, cmp: (T, T) -> bool) {
	if (cmp == null) cmp = T.==;
	var p = RiffParser.new(str);
	var got = parse(p);
	if (!p.r.ok) return t.fail(p.r.error_msg);
	if (got.length != expected.length) {
		t.fail(Strings.format2("expected length = %d, got %d", expected.length, got.length));
		return;
	}
	for (i < expected.length) {
		var g = got[i], e = expected[i];
		if (!cmp(g, e)) {
			var buf = StringBuilder.new();
			buf.put1("expected [%d]=", i);
			render(buf, e);
			buf.puts(", got ");
			render(buf, g);
			t.fail(buf.toString());
		}
	}
}

def assert_step = assert_valid(_, _, RiffParser.parseMelodyStep, _, null);
def assert_tempo = assert_valid(_, _, RiffParser.parseTempo, _, null);
def assert_duration = assert_valid(_, _, RiffParser.parseDuration, _, null);
def assert_note = assert_valid(_, _, parseNote, _, null);
def assert_tone = assert_valid(_, _, RiffParser.parsePitch, _, null);
def assert_key = assert_valid(_, _, RiffParser.parseKey, _, null);
def assert_steps = assert_valid_array(_, _, RiffParser.parseMelodySteps, _,
	fun (a: (MelodyStep, Duration), b: (MelodyStep, Duration)) => MelodyStep.equals(a.0, b.0) && Duration.==(a.1, b.1));
def assert_drum_step = assert_valid(_, _, RiffParser.parseDrumStep, _, DrumStep.equals);

def render<T>(buf: StringBuilder, val: T) -> StringBuilder {
	match (val) {
		x: Note => buf.puts(x.abbrev);
		x: Scale => buf.puts(x.abbrev);
		x: Pitch => {
			buf.putc(x.note.abbrev[0]);
			buf.putd(x.octave);
			buf.puts(x.note.dir.abbrev);
		}
		x: Tempo => buf.putd(x.bpm);
		x: Key => {
			buf.puts(x.tonic.abbrev);
			buf.puts(x.scale.abbrev);
		}
		x: MelodyStep => match (x) {
			Rest => buf.puts("_");
			Voice(y) => buf.putd(y);
			Chord(y) => {
				// TODO
			}
		}
		x: Duration => {
			if (x == Durations.WHOLE) return buf.puts("w");
			if (x == Durations.HALF) return buf.puts("h");
			if (x == Durations.QUARTER) return buf.puts("q");
			if (x == Durations.EIGHTH) return buf.puts("e");
			if (x == Durations.SIXTEENTH) return buf.puts("s");
			if (x == Durations.THIRTY_SECOND) return buf.puts("t");
			return buf.put2("%d/%d", x.num, x.denom);
		}
		x: (MelodyStep, Duration) => {
			buf.puts("(");
			render(buf, x.0);
			buf.csp();
			render(buf, x.1);
			buf.puts(")");
		}
		x: (DrumStep, Duration) => {
			if (x.0.hits.length == 0) buf.puts("_");
			else for (d in x.0.hits) render(buf, d);
			if (x.1 != Durations.DEFAULT_DRUM) render(buf, x.1);
		}
		x: Drum => {
			buf.putc(x.kind.mnemonic);
			if (x.num != 0) buf.putd(x.num);
		}
	}
	return buf;
}

def test_tempos(t: Tester) {
	def T = assert_tempo(t, _, _);
	T("T1", Tempo(1));
	T("T120", Tempo(120));
	T("T155", Tempo(155));
	def N = assert_invalid_tempo(t, _);
	N("Y88");
	N("T-120");
	N("T0");
	N("T65536");
}

def test_simple_steps(t: Tester) {
	def T = assert_step(t, _, _), A = MelodyStep.Voice;
	T("0", A(0));
	T("-1", A(-1));
	T("1", A(1));
	T("2", A(2));
	T("3", A(3));
	T("-1", A(-1));
	T("-13", A(-13));
	T("14", A(14));
	T("22", A(22));
	T("33", A(33));
	T("_", MelodyStep.Rest);
}

def test_invalid_steps(t: Tester) {
	def N = assert_invalid_step(t, _);
	N("A");	
	N("&");	
	N("-");	
	N("--");
	N("^");
}

def V(x: short) => (MelodyStep.Voice(x), Durations.QUARTER);
def C(x: Array<short>) => (MelodyStep.Chord(x), Durations.QUARTER);
def R = (MelodyStep.Rest, Durations.QUARTER);

def test_simple_melodies1(t: Tester) {
	def T = assert_steps(t, _, _);
	T("M0", [V(0)]);
	T("M-1", [V(-1)]);
	T("M-12", [V(-12)]);
	T("M12", [V(12)]);
	T("M_", [R]);
}

def test_simple_melodies2(t: Tester) {
	def T = assert_steps(t, _, _);
	T("M0,1", [V(0), V(1)]);
	T("M3,-1", [V(3), V(-1)]);
	T("M_,-9", [R, V(-9)]);
	T("M_,_,_", [R, R, R]);
	T("M0,0,0,_,1", [V(0), V(0), V(0), R, V(1)]);
}

def test_invalid_melodies(t: Tester) {
	def N = assert_invalid_steps(t, _);
	N("T");
	N("Y");
	N("+");
	N("Ma");
	N("M,");
	N("M+");
	N("M7,");
}

def test_simple_durations(t: Tester) {
	def T = assert_duration(t, _, _);

	T("w", Duration(1, 1));
	T("h", Duration(1, 2));
	T("q", Duration(1, 4));
	T("e", Duration(1, 8));
	T("s", Duration(1, 16));
	T("t", Duration(1, 32));
}

def test_dotted_durations(t: Tester) {
	def T = assert_duration(t, _, _);

	T("w.", Duration(3, 2));
	T("h.", Duration(3, 4));
	T("q.", Duration(3, 8));
	T("e.", Duration(3, 16));
	T("s.", Duration(3, 32));
	T("t.", Duration(3, 64));
}

def test_fractional_durations(t: Tester) {
	def T = assert_duration(t, _, _);

	T("w/3", Duration(1, 3));
	T("h/3", Duration(1, 6));
	T("q/3", Duration(1, 12));
	T("e/3", Duration(1, 24));
	T("s/3", Duration(1, 48));
	T("t/3", Duration(1, 96));

	T("w/5", Duration(1, 5));
	T("w/7", Duration(1, 7));
	T("w/9", Duration(1, 9));
	T("w/11", Duration(1, 11));
}

def test_tied_durations(t: Tester) {
	def T = assert_duration(t, _, _);

	T("w^w", Duration(2, 1));
	T("w^w^w", Duration(3, 1));
	T("w^q", Duration(5, 4));
	T("q/3^q/3", Duration(1, 6));
	T("q/3^q/3^q/3", Duration(1, 4));
	T("q/5^q/7^q/11", Duration(167, 1540));
}

def test_invalid_durations(t: Tester) {
	def N = assert_invalid_duration(t, _);
	N(".");
	N("0");
	N("+");
	N("/");
	N("-");
	N("q/0");
	N("q/7788383");
}

def test_melody_durations(t: Tester) {
	def T = assert_steps(t, _, _), V = MelodyStep.Voice;
	T("M0q", [(V(0), Durations.QUARTER)]);
	T("M1e", [(V(1), Durations.EIGHTH)]);
	T("M2s", [(V(2), Durations.SIXTEENTH)]);
	T("M-7w/3", [(V(-7), Durations.WHOLE.divide(3))]);
	T("M5,2s,3", [(V(5), Durations.QUARTER), (V(2), Durations.SIXTEENTH), (V(3), Durations.QUARTER)]);
	T("M5,2s^s,3", [(V(5), Durations.QUARTER), (V(2), Durations.EIGHTH), (V(3), Durations.QUARTER)]);
}

def test_notes0(t: Tester) {
	def T = assert_note(t, _, _);
	T("A", Note.A);
	T("B", Note.B);
	T("C", Note.C);
	T("D", Note.D);
	T("E", Note.E);
	T("F", Note.F);
	T("G", Note.G);
}

def test_notes1(t: Tester) {
	def T = assert_note(t, _, _);
	T("A#", Note.Asharp);
	T("B#", Note.Bsharp);
	T("C#", Note.Csharp);
	T("D#", Note.Dsharp);
	T("E#", Note.Esharp);
	T("F#", Note.Fsharp);
	T("G#", Note.Gsharp);
	T("Ab", Note.Aflat);
	T("Bb", Note.Bflat);
	T("Cb", Note.Cflat);
	T("Db", Note.Dflat);
	T("Eb", Note.Eflat);
	T("Fb", Note.Fflat);
	T("Gb", Note.Gflat);
}

def test_notes2(t: Tester) {
	def N = assert_invalid_note(t, _);
	N("c");
	N("+");
	N("T");
	N("0");
	N("12");
}

def test_tones0(t: Tester) {
	def T = assert_tone(t, _, _);
	T("A", Pitch(Note.A, 4));
	T("A1", Pitch(Note.A, 1));
	T("A2", Pitch(Note.A, 2));
	T("A3", Pitch(Note.A, 3));
	T("A4", Pitch(Note.A, 4));
	T("C5#", Pitch(Note.Csharp, 5));
	T("G6b", Pitch(Note.Gflat, 6));
	T("F2", Pitch(Note.F, 2));
	
	def N = assert_invalid_tone(t, _);
	N("A0");
	N("H2");
	N("C10");
}

def test_keys(t: Tester) {
	def T = assert_key(t, _, _);
	T("KA", Key(Note.A, Scale.Major));
	T("KB", Key(Note.B, Scale.Major));
	T("KC", Key(Note.C, Scale.Major));
	T("KD", Key(Note.D, Scale.Major));
	T("KE", Key(Note.E, Scale.Major));
	T("KF#", Key(Note.Fsharp, Scale.Major));
	T("KG#", Key(Note.Gsharp, Scale.Major));
	T("KCb", Key(Note.Cflat, Scale.Major));
	T("KDb", Key(Note.Dflat, Scale.Major));
	T("KEb", Key(Note.Eflat, Scale.Major));

	T("KAmaj", Key(Note.A, Scale.Major));
	T("KAm", Key(Note.A, Scale.Phrygian));
	T("KCmaj", Key(Note.C, Scale.Major));
	T("KCdor", Key(Note.C, Scale.Dorian));
	T("KClyd", Key(Note.C, Scale.Lydian));
	T("KCmix", Key(Note.C, Scale.Mixolydian));
	T("KCaeo", Key(Note.C, Scale.Aeolian));
	T("KCloc", Key(Note.C, Scale.Locrian));
	T("KCm", Key(Note.C, Scale.Phrygian));
}

def test_chords0(t: Tester) {
	def T = assert_steps(t, _, _);
	T("M[]", [R]);
	T("M[0]", [V(0)]);
	T("M[0,1,2]", [C([0, 1, 2])]);
	T("M[-2,-3],[4,5]", [C([-2, -3]), C([4, 5])]);
}

def test_drums0(t: Tester) {
	def T = assert_drum_step(t, _, _);
	def K = fun (x: byte) => Drum(DrumKind.Kick, x);
	def S = fun (x: byte) => Drum(DrumKind.Snare, x);
	T("K", DrumStep([K(0)]));
	T("K1", DrumStep([K(1)]));
	T("KS", DrumStep([K(0), S(0)]));
	T("KST1", DrumStep([K(0), S(0), Drum(DrumKind.Tom, 1)]));
	T("KT1R", DrumStep([K(0), Drum(DrumKind.Tom, 1), Drum(DrumKind.Ride, 0)]));
	T("LX", DrumStep([Drum(DrumKind.Clap, 0), Drum(DrumKind.Shaker, 0)]));
}

def main(args: Array<string>) -> int {
	return UnitTests.run(args);
}
