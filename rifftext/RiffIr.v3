// Copyright 2025 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// For notes that are altered up or down, the note direction encodes spelling.
enum NoteDir(abbrev: string) {
	FLAT("b"), NATURAL(""), SHARP("#")
}

// Notes have names and have a chromatic index (0-11).
enum Note(pitch_class: u4, abbrev: string, dir: NoteDir) {
	A(0, "A", NoteDir.NATURAL),
	Asharp(1, "A#", NoteDir.SHARP), Bflat(1, "Bb", NoteDir.FLAT),
	B(2, "B", NoteDir.NATURAL), Cflat(2, "Cb", NoteDir.FLAT),
	Bsharp(3, "B#", NoteDir.SHARP), C(3, "C", NoteDir.NATURAL),
	Csharp(4, "C#", NoteDir.SHARP), Dflat(4, "Db", NoteDir.FLAT),
	D(5, "D", NoteDir.NATURAL),
	Dsharp(6, "D#", NoteDir.SHARP), Eflat(6, "Eb", NoteDir.FLAT),
	E(7, "E", NoteDir.NATURAL), Fflat(7, "Fb", NoteDir.FLAT)
	Esharp(8, "E#", NoteDir.SHARP), F(8, "F", NoteDir.NATURAL),
	Fsharp(9, "F#", NoteDir.SHARP), Gflat(9, "Gb", NoteDir.FLAT),
	G(10, "G", NoteDir.NATURAL),
	Gsharp(11, "G#", NoteDir.SHARP), Aflat(11, "Ab", NoteDir.FLAT)
}

// Compute an array of all the notes for tone math.
def ALL_NOTES = (fun -> Array<Array<Note>> {
	var result = Array<Array<Note>>.new(12);
	for (n in Note) {
		var i = n.pitch_class;
		var prev = result[i];
		if (prev == null) result[i] = [n];
		else result[i] = Arrays.append(n, prev);
	}
	return result;
})();

// Scales. (only harmonic scale modes for now)
enum Scale(abbrev: string, degree: int) {
	Major("maj", 0),
	Dorian("dor", 1),
	Lydian("lyd", 3),
	Mixolydian("mix", 4),
	Aeolian("aeo", 5),
	Locrian("loc", 6)
	Phrygian("m", 2), // minor
}

// A Pitch is a Note at a specific octave.
type Pitch(note: Note, octave: u4) {
	// Add {n} semitones to this tone, moving up or down the chromatic scale.
	def plus(n: int, dir: NoteDir) -> Pitch {
		var oct = octave;
		var next = int.!(note.pitch_class) + n;
		while (next < 0) {
			oct--;
			next += 12;
		}
		while (next >= 12) {
			oct++;
			next -= 12;
		}
		var notes = ALL_NOTES[next];
		for (i < notes.length) {
			var n = notes[i];
			if (n.dir == dir) return Pitch(n, oct);
		}
		return Pitch(notes[0], oct);
	}
}

// A Key is a tonic note and a scale.
type Key(tonic: Note, scale: Scale);

// A Tempo is expressed in beats per minute (bpm).
type Tempo(bpm: u16);

// A Duration is expressed as a fraction of a measure and is based on 4/4 time
// so that 1 measure equals 4 beats.
type Duration(num: u16, denom: u16) {
	def plus(that: Duration) -> Duration {
		// Same denominator => easy case.
		if (this.denom == that.denom) return Durations.of(this.num + that.num, this.denom);

		// Cross-multiply to add different denominators.
		var a: u32 = this.num;
		var b: u32 = this.denom;
		var c: u32 = that.num;
		var d: u32 = that.denom;

		return Durations.of(a * d + c * b, b * d);
	}
}

// A step is either voiced with one or more voices or a rest.
type Step {
	case Rest;			// Rest step
	case Voice(val: i16);		// Tonic + val
	case Chord(vals: Array<i16>);	// Tonic + vals

	def equals(that: Step) -> bool {
		if (this == that) return true;
		match (this) {
			Chord(x) => match (that) {
				Chord(y) => return Arrays.equal(x, y);
				_ => return false;
			}
			_ => return false;
		}
	}
}

// A melody consists of a tonic, steps, and a rhythm.
type Melody(tonic: Pitch, steps: Array<Step>, rhythm: Array<Duration>) {
	def equals(that: Melody) -> bool {
		if (this == that) return true;
		return Arrays.equal(this.steps, that.steps) && Arrays.equal(this.rhythm, that.rhythm);
	}
}

// Utility to reduce a fraction.
def reduce(num: u32, denom: u32) -> (u32, u32) {
	if (denom == 0) {
		// Leave invalid fractions unchanged.
		return (num, denom);
	}
	var g = Ints.gcd(num, denom);
	if (g == 0) {
		// Covers the (0, 0) case.
		return (num, denom);
	}
	return (num / g, denom / g);
}

// Global utilities associated with durations.
component Durations {
	def NONE = Duration(0, 1);
	def WHOLE = Duration(1, 1);
	def HALF = Duration(1, 2);
	def QUARTER = Duration(1, 4);
	def EIGHTH = Duration(1, 8);
	def SIXTEENTH = Duration(1, 16);
	def THIRTY_SECOND = Duration(1, 32);


	def of(num: u32, denom: u32) -> Duration {
		var t = reduce(num, denom);
		return Duration(u16.!(t.0), u16.!(t.1));
	}
}

enum Drum(mnemonic: byte) {
	Kick('K'),
	Tom('T'),
	Snare('S'),
	Clap('L'),
	Shaker('X'),
	Crash('C'),
	Hihat('H'),
	Ride('R'),
	Openhat('O')
}
