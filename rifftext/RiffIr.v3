// Names for notes.
enum Note(chromatic_index: u4, abbreviation: string) {
	A(0, "A"),
	Asharp(1, "A#"), Bflat(1, "Bb"),
	B(2, "B"), Cflat(2, "Cb"),
	Bsharp(3, "B#"), C(3, "C"),
	Csharp(4, "C#"), Dflat(4, "Db"),
	D(5, "D"),
	Dsharp(6, "D#"), Eflat(5, "Eb"),
	E(7, "E"), Fflat(6, "Fb")
	Esharp(8, "E#"), F(7, "F"),
	Fsharp(9, "F#"), Gflat(8, "Gb"),
	G(10, "G"),
	Gsharp(11, "G#"), Aflat(11, "Ab")
}

// Compute an array of all the notes for tone math.
def ALL_NOTES = (fun -> Array<Note> {
	var result = Array<Note>.new(Note.count);
	for (n in Note) result[n.tag] = n;
	return result;
})();

// Scales. (only harmonic scale modes for now)
enum Scale(abbreviation: string) {
	Major("maj"),
	Dorian("dor"),
	Phrygian("m"), // minor
	Lydian("lyd"),
	Mixolydian("mix"),
	Aeolian("aeo"),
	Locrian("loc")
}

// Tones are notes and a specific octave.
type Tone(note: Note, octave: u4) {
	// Add {n} semitones to this tone, moving up or down the chromatic scale.
	def plus(n: int) -> Tone {
		var oct = octave;
		var next = int.!(note.tag) + n;
		while (next < 0) {
			oct--;
			next += Note.count;
		}
		while (next >= Note.count) {
			oct++;
			next -= Note.count;
		}
		return Tone(ALL_NOTES[next], oct);
	}
}

// A key is a tonic and a scale.
type Key(tonic: Tone, scale: Scale);

// A tempo is expressed in BPM.
type Tempo(bpm: u16);

// A duration is expressed as a fraction of a measure and is based on 4/4 time
// so that 1 measure equals 4 beats.
type Duration(num: u16, denom: u16) {
	def plus(that: Duration) -> Duration {
		// Same denominator => easy case.
		if (this.denom == that.denom) return Durations.of(this.num + that.num, this.denom);

		// Cross-multiply to add different denominators.
		var a: u32 = this.num;
		var b: u32 = this.denom;
		var c: u32 = that.num;
		var d: u32 = that.denom;

		return Durations.of(a * d + c * b, b * d);
	}
}

// Each part of a melody consists of a step.
type Step {
	case Abs(val: i32);	// Tonic + val
	case Rest;		// Rest step
}

class Rhythm {
}

class Melody {
}

// Utility to compute greatest common divisor of two u32 values.
def gcd(a: u32, b: u32) -> u32 {
	var x = a;
	var y = b;
	while (y != 0) {
		var r = x % y;
		x = y;
		y = r;
	}
	return x;
}

// Utility to reduce a fraction.
def reduce(num: u32, denom: u32) -> (u32, u32) {
	if (denom == 0) {
		// Leave invalid fractions unchanged.
		return (num, denom);
	}
	var g = gcd(num, denom);
	if (g == 0) {
		// Covers the (0, 0) case.
		return (num, denom);
	}
	return (num / g, denom / g);
}

// Global utilities associated with durations.
component Durations {
	def NONE = Duration(0, 1);
	def WHOLE = Duration(1, 1);
	def HALF = Duration(1, 2);
	def QUARTER = Duration(1, 4);
	def EIGHTH = Duration(1, 8);
	def SIXTEENTH = Duration(1, 16);
	def THIRTY_SECOND = Duration(1, 32);


	def of(num: u32, denom: u32) -> Duration {
		var t = reduce(num, denom);
		return Duration(u16.!(t.0), u16.!(t.1));
	}
}
