enum NoteDir(abbrev: string) {
	FLAT("b"), NATURAL(""), SHARP("#")
}

// Names for notes.
enum Note(chromatic_index: u4, abbrev: string, dir: NoteDir) {
	A(0, "A", NoteDir.NATURAL),
	Asharp(1, "A#", NoteDir.SHARP), Bflat(1, "Bb", NoteDir.FLAT),
	B(2, "B", NoteDir.NATURAL), Cflat(2, "Cb", NoteDir.FLAT),
	Bsharp(3, "B#", NoteDir.SHARP), C(3, "C", NoteDir.NATURAL),
	Csharp(4, "C#", NoteDir.SHARP), Dflat(4, "Db", NoteDir.FLAT),
	D(5, "D", NoteDir.NATURAL),
	Dsharp(6, "D#", NoteDir.SHARP), Eflat(6, "Eb", NoteDir.FLAT),
	E(7, "E", NoteDir.NATURAL), Fflat(7, "Fb", NoteDir.FLAT)
	Esharp(8, "E#", NoteDir.SHARP), F(8, "F", NoteDir.NATURAL),
	Fsharp(9, "F#", NoteDir.SHARP), Gflat(9, "Gb", NoteDir.FLAT),
	G(10, "G", NoteDir.NATURAL),
	Gsharp(11, "G#", NoteDir.SHARP), Aflat(11, "Ab", NoteDir.FLAT)
}

// Compute an array of all the notes for tone math.
def ALL_NOTES = (fun -> Array<Array<Note>> {
	var result = Array<Array<Note>>.new(12);
	for (n in Note) {
		var i = n.chromatic_index;
		var prev = result[i];
		if (prev == null) result[i] = [n];
		else result[i] = Arrays.append(n, prev);
	}
	return result;
})();

// Scales. (only harmonic scale modes for now)
enum Scale(abbrev: string, degree: int) {
	Major("maj", 0),
	Dorian("dor", 1),
	Lydian("lyd", 3),
	Mixolydian("mix", 4),
	Aeolian("aeo", 5),
	Locrian("loc", 6)
	Phrygian("m", 2), // minor
}

// Tones are notes and a specific octave.
type Tone(note: Note, octave: u4) {
	// Add {n} semitones to this tone, moving up or down the chromatic scale.
	def plus(n: int, dir: NoteDir) -> Tone {
		var oct = octave;
		var next = int.!(note.chromatic_index) + n;
		while (next < 0) {
			oct--;
			next += 12;
		}
		while (next >= Note.count) {
			oct++;
			next -= 12;
		}
		var notes = ALL_NOTES[next];
		for (i < notes.length) {
			var n = notes[i];
			if (n.dir == dir) return Tone(n, oct);
		}
		return Tone(notes[0], oct);
	}
}

// A key is a tonic and a scale.
type Key(tonic: Note, scale: Scale);

// A tempo is expressed in BPM.
type Tempo(bpm: u16);

// A duration is expressed as a fraction of a measure and is based on 4/4 time
// so that 1 measure equals 4 beats.
type Duration(num: u16, denom: u16) {
	def plus(that: Duration) -> Duration {
		// Same denominator => easy case.
		if (this.denom == that.denom) return Durations.of(this.num + that.num, this.denom);

		// Cross-multiply to add different denominators.
		var a: u32 = this.num;
		var b: u32 = this.denom;
		var c: u32 = that.num;
		var d: u32 = that.denom;

		return Durations.of(a * d + c * b, b * d);
	}
}

// Each part of a melody consists of a step.
type Step {
	case Abs(val: i32);	// Tonic + val
	case Rest;		// Rest step
}

class Rhythm {
}

class Melody {
}

// Utility to compute greatest common divisor of two u32 values.
def gcd(a: u32, b: u32) -> u32 {
	var x = a;
	var y = b;
	while (y != 0) {
		var r = x % y;
		x = y;
		y = r;
	}
	return x;
}

// Utility to reduce a fraction.
def reduce(num: u32, denom: u32) -> (u32, u32) {
	if (denom == 0) {
		// Leave invalid fractions unchanged.
		return (num, denom);
	}
	var g = gcd(num, denom);
	if (g == 0) {
		// Covers the (0, 0) case.
		return (num, denom);
	}
	return (num / g, denom / g);
}

// Global utilities associated with durations.
component Durations {
	def NONE = Duration(0, 1);
	def WHOLE = Duration(1, 1);
	def HALF = Duration(1, 2);
	def QUARTER = Duration(1, 4);
	def EIGHTH = Duration(1, 8);
	def SIXTEENTH = Duration(1, 16);
	def THIRTY_SECOND = Duration(1, 32);


	def of(num: u32, denom: u32) -> Duration {
		var t = reduce(num, denom);
		return Duration(u16.!(t.0), u16.!(t.1));
	}
}
